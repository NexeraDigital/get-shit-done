---
phase: 06-notification-system
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - autopilot/src/notifications/adapters/teams.ts
  - autopilot/src/notifications/adapters/slack.ts
  - autopilot/src/notifications/adapters/webhook.ts
  - autopilot/src/notifications/adapters/system.ts
  - autopilot/src/notifications/loader.ts
  - autopilot/src/notifications/__tests__/teams.test.ts
  - autopilot/src/notifications/__tests__/slack.test.ts
  - autopilot/src/notifications/__tests__/adapters.test.ts
  - autopilot/example-adapter.js
autonomous: true

must_haves:
  truths:
    - "Teams adapter POSTs Adaptive Card JSON to the configured webhook URL via fetch"
    - "Slack adapter POSTs Block Kit JSON to the configured webhook URL via fetch"
    - "Custom webhook adapter POSTs raw Notification JSON to any URL via fetch"
    - "System adapter sends OS-native toast notifications via node-notifier"
    - "Custom adapter loaded from user-provided file path via dynamic import"
    - "example-adapter.js ships alongside dist/ as a copyable starting point"
  artifacts:
    - path: "autopilot/src/notifications/adapters/teams.ts"
      provides: "TeamsAdapter with Adaptive Card formatting"
      exports: ["TeamsAdapter"]
    - path: "autopilot/src/notifications/adapters/slack.ts"
      provides: "SlackAdapter with Block Kit formatting"
      exports: ["SlackAdapter"]
    - path: "autopilot/src/notifications/adapters/webhook.ts"
      provides: "CustomWebhookAdapter with raw JSON POST"
      exports: ["CustomWebhookAdapter"]
    - path: "autopilot/src/notifications/adapters/system.ts"
      provides: "SystemAdapter with node-notifier"
      exports: ["SystemAdapter"]
    - path: "autopilot/src/notifications/loader.ts"
      provides: "loadCustomAdapter function for dynamic import"
      exports: ["loadCustomAdapter"]
    - path: "autopilot/example-adapter.js"
      provides: "Example custom adapter for users to copy and modify"
  key_links:
    - from: "autopilot/src/notifications/adapters/teams.ts"
      to: "fetch"
      via: "Node.js built-in fetch for HTTP POST"
      pattern: "fetch\\("
    - from: "autopilot/src/notifications/adapters/slack.ts"
      to: "fetch"
      via: "Node.js built-in fetch for HTTP POST"
      pattern: "fetch\\("
    - from: "autopilot/src/notifications/adapters/system.ts"
      to: "node-notifier"
      via: "createRequire for CJS-only library in ESM project"
      pattern: "createRequire"
    - from: "autopilot/src/notifications/loader.ts"
      to: "import()"
      via: "dynamic import for user-provided adapter path"
      pattern: "import\\("
---

<objective>
Create all remote notification adapters (Teams, Slack, Webhook, System) and the custom adapter loader with an example file.

Purpose: Adds the full set of notification channels so users can receive notifications via Teams Adaptive Cards, Slack Block Kit, raw webhooks, OS toasts, or their own custom adapter. These adapters plug into the NotificationManager from Plan 01.
Output: Four adapter classes, one loader function, one example file, tests.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-notification-system/06-01-SUMMARY.md
@autopilot/src/types/notification.ts
@autopilot/src/notifications/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Teams, Slack, and Webhook adapters with tests</name>
  <files>
    autopilot/src/notifications/adapters/teams.ts
    autopilot/src/notifications/adapters/slack.ts
    autopilot/src/notifications/adapters/webhook.ts
    autopilot/src/notifications/__tests__/teams.test.ts
    autopilot/src/notifications/__tests__/slack.test.ts
  </files>
  <action>
**1. Create `autopilot/src/notifications/adapters/teams.ts` -- TeamsAdapter:**

Implements NotificationAdapter. Constructor takes `{ webhookUrl: string }`.

Per user locked decisions:
- **Link only, no inline action buttons**
- **Minimal content: phase name, question/status text, dashboard link**
- **Same minimal style for both question and stop notifications**
- **Use Adaptive Card format** (NOT deprecated MessageCard -- research finding)

`send(notification)` POSTs to webhookUrl with Adaptive Card JSON envelope. Use Node.js built-in `fetch` (available since Node 18, project requires >=20).

Adaptive Card structure (per research -- Teams Workflows accepts this format):
```json
{
  "type": "message",
  "attachments": [{
    "contentType": "application/vnd.microsoft.card.adaptive",
    "content": {
      "$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
      "type": "AdaptiveCard",
      "version": "1.4",
      "body": [
        {
          "type": "TextBlock",
          "text": notification.title,
          "weight": "Bolder",
          "size": "Medium"
        },
        {
          "type": "TextBlock",
          "text": notification.body,
          "wrap": true
        },
        // Only if respondUrl exists:
        {
          "type": "TextBlock",
          "text": "[Open Dashboard](respondUrl)",
          "wrap": true
        }
      ]
    }
  }]
}
```

If fetch response is not ok (status >= 400), throw an error with status code and response text (this triggers the NotificationManager fallback).

`init()` and `close()` are no-ops. `name` returns `'teams'`.

**2. Create `autopilot/src/notifications/adapters/slack.ts` -- SlackAdapter:**

Same pattern as Teams. Constructor takes `{ webhookUrl: string }`.

Uses Slack Block Kit format with required `text` fallback field (research finding):
```json
{
  "text": `${notification.title}: ${notification.body}`,
  "blocks": [
    {
      "type": "header",
      "text": { "type": "plain_text", "text": notification.title }
    },
    {
      "type": "section",
      "text": { "type": "mrkdwn", "text": notification.body }
    },
    // Only if respondUrl exists:
    {
      "type": "section",
      "text": { "type": "mrkdwn", "text": `<${respondUrl}|Open Dashboard>` }
    }
  ]
}
```

`name` returns `'slack'`.

**3. Create `autopilot/src/notifications/adapters/webhook.ts` -- CustomWebhookAdapter:**

Generic webhook adapter per NOTF-06. Constructor takes `{ webhookUrl: string }`.

`send(notification)` POSTs the raw Notification JSON object to webhookUrl with `Content-Type: application/json`. No transformation -- the full Notification object is the payload.

`name` returns `'webhook'`.

**4. Create `autopilot/src/notifications/__tests__/teams.test.ts`:**

Mock `global.fetch` with `vi.fn()`:
- `send() POSTs Adaptive Card to webhook URL`: Verify fetch called with correct URL, method POST, Content-Type application/json, body containing "AdaptiveCard".
- `send() includes dashboard link when respondUrl present`: Verify body contains the respondUrl.
- `send() throws on non-ok response`: Mock fetch returning 400, verify send() rejects.
- `send() omits dashboard link when no respondUrl`: Verify body does NOT contain "Open Dashboard" link block.

**5. Create `autopilot/src/notifications/__tests__/slack.test.ts`:**

Same pattern as Teams tests:
- `send() POSTs Block Kit to webhook URL`: Verify fetch called with blocks array.
- `send() includes fallback text field`: Required by Slack API. Verify `text` property exists at top level.
- `send() includes dashboard link when respondUrl present`: Verify blocks contain mrkdwn with `<url|Open Dashboard>`.
- `send() throws on non-ok response`: Mock fetch returning 400, verify send() rejects.
  </action>
  <verify>
Run `cd C:/GitHub/GetShitDone/get-shit-done/autopilot && npx vitest run src/notifications/__tests__/teams.test.ts src/notifications/__tests__/slack.test.ts` -- all tests pass.
Run `npx tsc --noEmit` -- no type errors.
  </verify>
  <done>
TeamsAdapter POSTs Adaptive Cards, SlackAdapter POSTs Block Kit, CustomWebhookAdapter POSTs raw JSON. All use Node.js built-in fetch, throw on HTTP errors. 8+ tests passing across Teams and Slack test files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SystemAdapter, custom adapter loader, and example-adapter.js</name>
  <files>
    autopilot/src/notifications/adapters/system.ts
    autopilot/src/notifications/loader.ts
    autopilot/src/notifications/__tests__/adapters.test.ts
    autopilot/example-adapter.js
  </files>
  <action>
**1. Create `autopilot/src/notifications/adapters/system.ts` -- SystemAdapter:**

Uses node-notifier for OS-native toast notifications (NOTF-03). Per research Pitfall 2, node-notifier is CJS-only and requires `createRequire` workaround in this ESM project.

```typescript
import { createRequire } from 'node:module';
import type { Notification, NotificationAdapter } from '../types.js';

const require = createRequire(import.meta.url);

export class SystemAdapter implements NotificationAdapter {
  readonly name = 'system';
  private notifier: { notify: (opts: Record<string, unknown>, cb?: (err: unknown) => void) => void } | null = null;

  async init(): Promise<void> {
    // Dynamic require to avoid bundling issues
    const nn = require('node-notifier') as { notify: (...args: unknown[]) => void };
    this.notifier = nn;
  }

  async send(notification: Notification): Promise<void> {
    if (!this.notifier) throw new Error('SystemAdapter not initialized');
    return new Promise<void>((resolve, reject) => {
      this.notifier!.notify(
        {
          title: notification.title,
          message: notification.body,
          sound: notification.type === 'question',
          wait: false,
        },
        (err: unknown) => {
          if (err) reject(err);
          else resolve();
        },
      );
    });
  }

  async close(): Promise<void> {
    this.notifier = null;
  }
}
```

Note: node-notifier must be installed as an **optional** dependency. Add it in Plan 03 when updating package.json. If `require('node-notifier')` fails (not installed), init() will throw and NotificationManager will gracefully remove it (per Plan 01 init failure handling).

**2. Create `autopilot/src/notifications/loader.ts` -- loadCustomAdapter:**

Per user decision (NOTF-07), loads a user-provided adapter from a local file path.

```typescript
import { resolve } from 'node:path';
import { pathToFileURL } from 'node:url';
import type { NotificationAdapter } from '../types/notification.js';

export async function loadCustomAdapter(adapterPath: string): Promise<NotificationAdapter> {
  // Resolve relative to process.cwd() per research Pitfall 6
  const absolutePath = resolve(process.cwd(), adapterPath);
  const fileUrl = pathToFileURL(absolutePath).href;

  const mod = await import(fileUrl);

  // Expect default export to be a class with new() or an already-instantiated adapter
  const AdapterClass = mod.default ?? mod;

  let adapter: NotificationAdapter;
  if (typeof AdapterClass === 'function') {
    adapter = new AdapterClass();
  } else if (typeof AdapterClass === 'object' && AdapterClass !== null && 'send' in AdapterClass) {
    adapter = AdapterClass as NotificationAdapter;
  } else {
    throw new Error(
      `Custom adapter at ${adapterPath} must export a class with init()/send()/close() methods or an adapter instance as default export`
    );
  }

  // Validate the adapter has required methods
  if (typeof adapter.send !== 'function') {
    throw new Error(`Custom adapter at ${adapterPath} is missing required send() method`);
  }
  if (typeof adapter.init !== 'function') {
    throw new Error(`Custom adapter at ${adapterPath} is missing required init() method`);
  }
  if (typeof adapter.close !== 'function') {
    throw new Error(`Custom adapter at ${adapterPath} is missing required close() method`);
  }

  return adapter;
}
```

**3. Create `autopilot/src/notifications/__tests__/adapters.test.ts`:**

Tests for SystemAdapter and loader:
- `SystemAdapter.init() loads node-notifier via createRequire` -- mock `createRequire` chain to return a fake notifier. Verify init() succeeds.
- `SystemAdapter.send() calls notifier.notify with title and message` -- verify correct params.
- `SystemAdapter.send() rejects when notifier callback has error` -- mock callback with error.
- `loadCustomAdapter() loads adapter from file path` -- create a temp file exporting a mock adapter class, call loadCustomAdapter, verify it returns an adapter with send/init/close.
- `loadCustomAdapter() throws on missing send method` -- create temp file with incomplete export, verify throws.
- `CustomWebhookAdapter.send() POSTs raw notification JSON` -- mock fetch, verify body is the full notification object.

**4. Create `autopilot/example-adapter.js`:**

Per user decision -- shipped alongside dist/ for users to copy and modify. Plain JavaScript (not TypeScript) since users may not have a TS build pipeline.

```javascript
/**
 * Example custom notification adapter for gsd-autopilot.
 *
 * Copy this file and modify it to create your own notification channel.
 * Load it with: gsd-autopilot --adapter-path ./my-adapter.js
 *
 * The adapter must export a default class with three methods:
 *   init()  - Called once at startup. Set up connections, validate config.
 *   send(notification) - Called for each notification. Fire and forget.
 *   close() - Called at shutdown. Clean up resources.
 *
 * The notification object has this shape:
 *   {
 *     id: string,          // Unique notification ID
 *     type: 'question' | 'progress' | 'error' | 'complete',
 *     title: string,       // Short title
 *     body: string,        // Full notification text
 *     severity: 'info' | 'warning' | 'critical',
 *     respondUrl?: string, // Dashboard URL to respond (for questions)
 *     options?: string[],  // Question option labels
 *     phase?: number,      // Current phase number
 *     step?: string,       // Current step name
 *     createdAt: string,   // ISO timestamp
 *     summary?: string,    // Build summary (for stop notifications)
 *     nextSteps?: string,  // What to do next (for stop notifications)
 *     errorMessage?: string // Error details (for error notifications)
 *   }
 */
export default class MyCustomAdapter {
  get name() {
    return 'my-custom';
  }

  async init() {
    // Called once at startup.
    // Example: validate environment variables, open connections
    console.log('[my-custom] Adapter initialized');
  }

  async send(notification) {
    // Called for each notification.
    // Example: send to your logging service, chat tool, email, etc.
    console.log(`[my-custom] ${notification.type}: ${notification.title}`);
    console.log(`[my-custom] ${notification.body}`);
    if (notification.respondUrl) {
      console.log(`[my-custom] Respond at: ${notification.respondUrl}`);
    }
  }

  async close() {
    // Called at shutdown.
    // Example: close connections, flush buffers
    console.log('[my-custom] Adapter closed');
  }
}
```
  </action>
  <verify>
Run `cd C:/GitHub/GetShitDone/get-shit-done/autopilot && npx vitest run src/notifications/__tests__/adapters.test.ts` -- all tests pass.
Run `npx tsc --noEmit` -- no type errors.
Verify `autopilot/example-adapter.js` exists and contains the class export.
  </verify>
  <done>
SystemAdapter wraps node-notifier via createRequire. TeamsAdapter, SlackAdapter, CustomWebhookAdapter all use fetch. loadCustomAdapter dynamically imports from user path with validation. example-adapter.js provides a copyable starting point. 6+ tests passing.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run src/notifications/` -- all notification tests pass
- `npx tsc --noEmit` -- full project compiles
- All 5 adapters importable: ConsoleAdapter (Plan 01), TeamsAdapter, SlackAdapter, CustomWebhookAdapter, SystemAdapter
- loadCustomAdapter function importable from loader.ts
- example-adapter.js exists at autopilot/example-adapter.js
</verification>

<success_criteria>
- Teams adapter formats Adaptive Card JSON and POSTs to webhook URL
- Slack adapter formats Block Kit JSON with fallback text field and POSTs to webhook URL
- Custom webhook adapter POSTs raw Notification JSON
- System adapter uses node-notifier via createRequire for ESM compatibility
- Custom adapter loader validates init/send/close methods exist
- example-adapter.js is complete and self-documenting
- All tests pass, TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/06-notification-system/06-02-SUMMARY.md`
</output>
