---
phase: 06-notification-system
plan: 03
type: execute
wave: 3
depends_on: ["06-01", "06-02"]
files_modified:
  - autopilot/src/types/config.ts
  - autopilot/src/cli/index.ts
  - autopilot/src/notifications/index.ts
  - autopilot/src/index.ts
  - autopilot/package.json
autonomous: true

must_haves:
  truths:
    - "CLI creates NotificationManager, adds adapters based on config.notify, and wires orchestrator/claude events to notification dispatch"
    - "question:pending event triggers a question notification with full text, options, and dashboard URL"
    - "build:complete event triggers a complete notification with summary and next steps"
    - "error:escalation event triggers an error notification with error details and resume instructions"
    - "Question reminders start on question:pending and cancel on question:answered"
    - "NotificationManager close() is registered in ShutdownManager for cleanup"
    - "node-notifier added as optionalDependency in package.json"
    - "All notification exports available from @gsd/autopilot package entry point"
  artifacts:
    - path: "autopilot/src/cli/index.ts"
      provides: "NotificationManager wiring with event listeners"
      contains: "NotificationManager"
    - path: "autopilot/src/types/config.ts"
      provides: "questionReminderMs config field"
      contains: "questionReminderMs"
    - path: "autopilot/src/index.ts"
      provides: "Notification system exports from package entry"
      contains: "NotificationManager"
    - path: "autopilot/package.json"
      provides: "node-notifier as optionalDependency"
      contains: "node-notifier"
  key_links:
    - from: "autopilot/src/cli/index.ts"
      to: "autopilot/src/notifications/index.ts"
      via: "import { NotificationManager, ConsoleAdapter }"
      pattern: "import.*NotificationManager"
    - from: "autopilot/src/cli/index.ts"
      to: "orchestrator events"
      via: "orchestrator.on('build:complete') -> manager.notify()"
      pattern: "orchestrator\\.on\\('build:complete'"
    - from: "autopilot/src/cli/index.ts"
      to: "claudeService events"
      via: "claudeService.on('question:pending') -> manager.notify() + manager.startReminder()"
      pattern: "claudeService\\.on\\('question:pending'"
    - from: "autopilot/src/cli/index.ts"
      to: "claudeService events"
      via: "claudeService.on('question:answered') -> manager.cancelReminder()"
      pattern: "claudeService\\.on\\('question:answered'"
---

<objective>
Wire the NotificationManager into the CLI bootstrap, connect orchestrator and ClaudeService events to notification dispatch, update config schema, add package exports, and add node-notifier as optional dependency.

Purpose: This is the integration plan that connects the notification system (Plans 01-02) to the running autopilot. After this plan, notifications actually fire during real autopilot runs based on question and stop events.
Output: Updated CLI with notification wiring, config schema with reminderMs, package exports, node-notifier dependency.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-notification-system/06-01-SUMMARY.md
@.planning/phases/06-notification-system/06-02-SUMMARY.md
@autopilot/src/cli/index.ts
@autopilot/src/types/config.ts
@autopilot/src/index.ts
@autopilot/package.json
@autopilot/src/notifications/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update config schema, wire NotificationManager in CLI, connect all events</name>
  <files>
    autopilot/src/types/config.ts
    autopilot/src/cli/index.ts
    autopilot/src/notifications/index.ts
  </files>
  <action>
**1. Update `autopilot/src/types/config.ts`:**

Add `questionReminderMs` field and update `notify` to use `z.enum` for known channels (research recommendation):

```typescript
export const AutopilotConfigSchema = z.object({
  // Notification
  notify: z.enum(['console', 'system', 'teams', 'slack', 'webhook']).default('console'),
  webhookUrl: z.string().url().optional(),
  adapterPath: z.string().optional(),
  questionReminderMs: z.number().int().min(0).default(300_000), // 5 min default

  // ... rest stays the same
});
```

Also add `--adapter-path` to the CLI option type in `options` type annotation (it's already in the config schema from Phase 1 but not wired as a CLI flag yet).

**2. Update `autopilot/src/notifications/index.ts`:**

Add all adapter exports so CLI can import them:

```typescript
export { NotificationManager } from './manager.js';
export { ConsoleAdapter } from './adapters/console.js';
export { TeamsAdapter } from './adapters/teams.js';
export { SlackAdapter } from './adapters/slack.js';
export { CustomWebhookAdapter } from './adapters/webhook.js';
export { SystemAdapter } from './adapters/system.js';
export { loadCustomAdapter } from './loader.js';
export type { NotificationManagerOptions } from './types.js';
```

**3. Update `autopilot/src/cli/index.ts`:**

Add NotificationManager creation and event wiring in the CLI action handler. Insert AFTER the StreamRenderer/StreamLogger wiring (section f) and BEFORE the orchestrator creation (section h).

**a. Add imports at top:**
```typescript
import {
  NotificationManager,
  ConsoleAdapter,
  TeamsAdapter,
  SlackAdapter,
  CustomWebhookAdapter,
  SystemAdapter,
  loadCustomAdapter,
} from '../notifications/index.js';
import { randomUUID } from 'node:crypto';
import type { Notification, NotificationType } from '../types/notification.js';
import type { QuestionEvent } from '../claude/types.js';
```

**b. Add `--adapter-path` CLI option** (add to the Commander option chain):
```typescript
.option('--adapter-path <path>', 'Path to custom notification adapter module')
```

Also add `adapterPath` to the options type annotation.

Pass `adapterPath` into loadConfig overrides (alongside existing fields).

**c. Create NotificationManager** (after streamLogger creation, before orchestrator):

```typescript
// Create NotificationManager
const notificationManager = new NotificationManager({
  port: config.port,
  questionReminderMs: config.questionReminderMs,
  stopSpinner: () => streamRenderer.stopSpinner(),
});

// Always add console adapter (default, zero-dependency)
notificationManager.addAdapter(new ConsoleAdapter({
  port: config.port,
  stopSpinner: () => streamRenderer.stopSpinner(),
}));

// Add channel-specific adapter based on config.notify
switch (config.notify) {
  case 'system':
    notificationManager.addAdapter(new SystemAdapter());
    break;
  case 'teams':
    if (config.webhookUrl) {
      notificationManager.addAdapter(new TeamsAdapter({ webhookUrl: config.webhookUrl }));
    } else {
      console.error('Warning: --notify teams requires --webhook-url');
    }
    break;
  case 'slack':
    if (config.webhookUrl) {
      notificationManager.addAdapter(new SlackAdapter({ webhookUrl: config.webhookUrl }));
    } else {
      console.error('Warning: --notify slack requires --webhook-url');
    }
    break;
  case 'webhook':
    if (config.webhookUrl) {
      notificationManager.addAdapter(new CustomWebhookAdapter({ webhookUrl: config.webhookUrl }));
    } else {
      console.error('Warning: --notify webhook requires --webhook-url');
    }
    break;
  case 'console':
  default:
    // Console already added above
    break;
}

// Load custom adapter if --adapter-path provided (NOTF-07)
if (config.adapterPath) {
  try {
    const customAdapter = await loadCustomAdapter(config.adapterPath);
    notificationManager.addAdapter(customAdapter);
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    console.error(`Warning: Failed to load custom adapter: ${msg}`);
  }
}

// Initialize all adapters (failures logged and adapter removed, not thrown)
await notificationManager.init();
```

**d. Wire question events to notifications:**

```typescript
// Wire question:pending -> notification dispatch + reminder
claudeService.on('question:pending', (event: QuestionEvent) => {
  const respondUrl = `http://localhost:${config.port}/questions/${event.id}`;
  const questionText = event.questions.map(q => q.question).join('\n');
  const optionLabels = event.questions.flatMap(q => q.options.map(o => o.label));

  const notification: Notification = {
    id: randomUUID(),
    type: 'question',
    title: `Question${event.phase ? ` (Phase ${event.phase})` : ''}: ${event.questions[0]?.header ?? 'Input needed'}`,
    body: questionText,
    severity: 'warning',
    respondUrl,
    options: optionLabels.length > 0 ? optionLabels : undefined,
    phase: event.phase,
    step: event.step,
    createdAt: new Date().toISOString(),
  };

  notificationManager.notify(notification);
  notificationManager.startReminder(event.id, notification);
});

// Wire question:answered -> cancel reminder
claudeService.on('question:answered', ({ id }: { id: string }) => {
  notificationManager.cancelReminder(id);
});
```

**e. Wire orchestrator stop events to notifications:**

```typescript
// Wire build:complete -> notification
orchestrator.on('build:complete', () => {
  const state = stateStore.getState();
  const completedCount = state.phases.filter(p => p.status === 'completed').length;
  const totalCount = state.phases.length;
  const elapsed = state.startedAt
    ? Math.round((Date.now() - new Date(state.startedAt).getTime()) / 60000)
    : 0;

  const notification: Notification = {
    id: randomUUID(),
    type: 'complete',
    title: 'Build complete',
    body: `All phases finished successfully.`,
    severity: 'info',
    createdAt: new Date().toISOString(),
    summary: `${completedCount} of ${totalCount} phases completed in ${elapsed} min`,
    nextSteps: 'Review output in .planning/ directory',
  };

  notificationManager.notify(notification);
});

// Wire error:escalation -> notification
orchestrator.on('error:escalation', ({ phase, step, error }: { phase: number; step: string; error: string }) => {
  const state = stateStore.getState();
  const completedCount = state.phases.filter(p => p.status === 'completed').length;
  const totalCount = state.phases.length;
  const elapsed = state.startedAt
    ? Math.round((Date.now() - new Date(state.startedAt).getTime()) / 60000)
    : 0;

  const notification: Notification = {
    id: randomUUID(),
    type: 'error',
    title: `Autopilot stopped (Phase ${phase}, ${step})`,
    body: error,
    severity: 'critical',
    phase,
    step,
    createdAt: new Date().toISOString(),
    summary: `${completedCount} of ${totalCount} phases completed in ${elapsed} min`,
    nextSteps: 'Run `gsd-autopilot --resume` to retry from the failed step',
    errorMessage: error,
  };

  notificationManager.notify(notification);
});
```

**f. Register NotificationManager shutdown** (add BEFORE the ResponseServer shutdown registration so it runs AFTER server but BEFORE logger flushes per LIFO):

```typescript
shutdown.register(async () => {
  logger.log('info', 'cli', 'Closing notification manager');
  await notificationManager.close();
});
```

**g. Also update the success path** in the try block after `orchestrator.run()` to close the notification manager:

```typescript
await notificationManager.close();
```
(Add before `await responseServer.close()`)

And in the catch block:
```typescript
await notificationManager.close();
```
(Add before `await responseServer.close()`)
  </action>
  <verify>
Run `cd C:/GitHub/GetShitDone/get-shit-done/autopilot && npx tsc --noEmit` -- no type errors.
Run `npx vitest run` -- all existing tests still pass (no regressions).
Grep for `NotificationManager` in `src/cli/index.ts` -- present.
Grep for `question:pending` listener in `src/cli/index.ts` -- present.
Grep for `build:complete` notification in `src/cli/index.ts` -- present.
  </verify>
  <done>
CLI creates NotificationManager with adapters based on config.notify, wires question:pending to notification + reminder, wires question:answered to cancel reminder, wires build:complete and error:escalation to stop notifications. Config schema has questionReminderMs. Notifications barrel exports all adapters.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update package exports and add node-notifier optional dependency</name>
  <files>
    autopilot/src/index.ts
    autopilot/package.json
  </files>
  <action>
**1. Update `autopilot/src/index.ts`:**

Add notification system exports to the package entry point:

```typescript
// Notifications
export { NotificationManager } from './notifications/index.js';
export { ConsoleAdapter } from './notifications/index.js';
export { TeamsAdapter } from './notifications/adapters/teams.js';
export { SlackAdapter } from './notifications/adapters/slack.js';
export { CustomWebhookAdapter } from './notifications/adapters/webhook.js';
export { SystemAdapter } from './notifications/adapters/system.js';
export { loadCustomAdapter } from './notifications/loader.js';
export type { NotificationManagerOptions } from './notifications/types.js';
```

Keep the existing Notification/NotificationAdapter type exports that are already there (from `./types/index.js`).

**2. Update `autopilot/package.json`:**

Add `node-notifier` as an **optionalDependency** (not a regular dependency -- it's only needed when `--notify system` is used):

```json
{
  "optionalDependencies": {
    "node-notifier": "^10.0.1"
  }
}
```

Also add `example-adapter.js` to the `files` array so it's included in the npm package:

```json
{
  "files": [
    "dist/",
    "dashboard/dist/",
    "example-adapter.js"
  ]
}
```

**3. Run `npm install` in the autopilot directory** to update package-lock.json with the new optional dependency.

**4. Run full build** to verify everything compiles:
```bash
cd autopilot && npx tsc
```
  </action>
  <verify>
Run `cd C:/GitHub/GetShitDone/get-shit-done/autopilot && npm install && npx tsc --noEmit` -- installs and compiles clean.
Run `npx vitest run` -- all tests pass (no regressions).
Verify `dist/notifications/manager.js` exists after build.
Verify `dist/notifications/adapters/console.js` exists after build.
Grep for `NotificationManager` in `src/index.ts` -- present.
Grep for `node-notifier` in `package.json` -- present in optionalDependencies.
  </verify>
  <done>
Package entry point exports all notification classes. node-notifier is an optional dependency. example-adapter.js included in package files. Full build compiles clean, all tests pass.
  </done>
</task>

</tasks>

<verification>
- `npm install && npx tsc` in autopilot/ -- full build succeeds
- `npx vitest run` -- all tests pass including notification tests
- CLI can be invoked: `node dist/cli/index.js --help` shows --notify, --webhook-url, --adapter-path flags
- Package entry point exports NotificationManager, all adapters, loadCustomAdapter
- Config schema includes questionReminderMs with default 300000
</verification>

<success_criteria>
- CLI creates NotificationManager and wires it to orchestrator/claude events
- question:pending fires question notification with text, options, URL, bell
- question:answered cancels reminder timer
- build:complete fires complete notification with summary and next steps
- error:escalation fires error notification with error details and resume instructions
- NotificationManager closed on shutdown and in success/error paths
- node-notifier is optionalDependency (not blocking install when unavailable)
- All notification classes exported from @gsd/autopilot
- Full test suite passes, TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/06-notification-system/06-03-SUMMARY.md`
</output>
