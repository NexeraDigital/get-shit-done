# Phase 06.1: Add Browser Notifications - Research

**Researched:** 2026-02-24
**Domain:** Web Notifications API, Web Push API, Service Workers, VAPID authentication
**Confidence:** HIGH

## Summary

Browser notifications for the GSD Autopilot dashboard require integrating three complementary web standards: the **Notifications API** (for displaying notifications), the **Web Push API** (for background delivery via Service Workers), and **VAPID authentication** (for secure server-to-client push messaging). The existing React 19/Vite 7/Zustand 5 dashboard already has SSE infrastructure for real-time events, which provides the foundation for notification triggers.

The standard approach uses `vite-plugin-pwa` (latest v1.2.0) to generate and register the Service Worker, `web-push` npm package (v3.6.7) on the server side for sending push notifications with VAPID keys, and localStorage for persisting per-type notification preferences. The Notifications API has excellent browser support (Chrome, Firefox, Edge, Safari desktop), though custom notification sounds are not supported by any browser despite being in the spec—requiring a workaround using message passing to open windows.

**Primary recommendation:** Use vite-plugin-pwa with Workbox for Service Worker generation, web-push for server-side push delivery, implement notification grouping via the `tag` parameter to avoid overwhelming users with multiple questions, and use `requireInteraction: true` for action-needed notifications (questions, errors) while auto-dismissing informational ones (phase-completed, build-complete). Badge API support is limited to installed PWAs but should be implemented as progressive enhancement.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Trigger events:**
- Fire browser notifications on: question-pending, error escalation, phase-completed, build-complete
- Do NOT fire on: phase-started, step-completed, log-entry (too noisy)
- Question reminders (5-min server-side cycle) do NOT re-fire browser notifications — only the initial question triggers one
- When multiple questions arrive at once, group into single notification (e.g. "3 questions need your attention") rather than individual notifications per question
- Per-type toggles: user can enable/disable notifications per event type (questions, errors, phase-completed, build-complete) independently
- Toggle preferences stored in browser localStorage (not server-side)

**Notification content & behavior:**
- Title prefix: "GSD Autopilot: " before all notification titles (e.g. "GSD Autopilot: Question needs your input")
- Click action: navigate to relevant page — question notifications open question page, error opens phase detail, completion opens overview
- Auto-dismiss behavior depends on type: questions persist until dismissed (action needed), phase-completed and build-complete auto-dismiss (informational)
- Sound: custom notification sound for questions only (action needed), other types are silent
- Error notifications include the error message in the body (not just "Error in Phase X")
- Build-complete notifications include summary stats (phases completed, duration)
- Use custom GSD icon/logo in notifications for brand recognition

**Permission & opt-in flow:**
- Request notification permission on first dashboard visit (automatic prompt)
- If denied: show persistent but subtle "Enable notifications" toggle link in header/footer
- No dedicated bell icon or status indicator — just the toggle link
- Per-type toggles accessible from the same UI area

**Background support:**
- Use Service Worker + Web Push API for notifications even when tab is closed
- Server pushes events to Service Worker using VAPID keys and push subscriptions (web-push npm package)
- Click on Service Worker notification opens new dashboard tab to the relevant page
- Badge: show pending question count on browser tab/icon via Badge API

### Claude's Discretion

- Phase-completed notification detail level (phase name vs phase name + stats)
- Exact notification sound file/tone for questions
- Service Worker cache strategy and update lifecycle
- VAPID key generation and storage approach
- Exact auto-dismiss timeout for informational notifications

### Deferred Ideas (OUT OF SCOPE)

None — discussion stayed within phase scope

</user_constraints>

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `vite-plugin-pwa` | ^1.2.0 | Service Worker generation + PWA manifest | Zero-config Workbox integration, TypeScript support, official Vite PWA solution |
| `web-push` | ^3.6.7 | Server-side push notification delivery with VAPID | Official Web Push Protocol implementation for Node.js, handles encryption automatically |
| Notifications API | Native | Display browser notifications | Standard web API, excellent browser support (Chrome, Firefox, Edge, Safari) |
| Service Worker API | Native | Background script for push events | Standard web API, required for notifications when tab closed |
| Badge API | Native | Tab/icon badge count | Standard web API, progressive enhancement (limited support) |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `@types/web-push` | ^3.6.3 | TypeScript types for web-push | TypeScript projects (already using TS) |
| `workbox-window` | ^7.3.0 | Client-side Service Worker lifecycle hooks | Advanced update UI (included in vite-plugin-pwa) |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| vite-plugin-pwa | Manual Service Worker + registration | Lose automatic Workbox precaching, manifest generation, and Vite build integration. Only justified for highly custom caching strategies. |
| web-push | Firebase Cloud Messaging (FCM) | FCM adds unnecessary complexity and vendor lock-in when you control both client and server. web-push uses open W3C standards. |
| Badge API | Custom favicon manipulation | Favicon hacks are unreliable across browsers and don't integrate with OS-level notification centers. Badge API is proper standard. |

**Installation:**
```bash
# Dashboard (Vite project)
cd autopilot/dashboard
npm install vite-plugin-pwa -D

# Server (Node.js)
cd autopilot
npm install web-push
npm install @types/web-push -D  # TypeScript types
```

## Architecture Patterns

### Recommended Project Structure
```
autopilot/
├── src/
│   ├── server/
│   │   ├── routes/
│   │   │   ├── api.ts              # Existing REST API routes
│   │   │   ├── sse.ts              # Existing SSE routes
│   │   │   └── push.ts             # NEW: Push subscription management
│   │   ├── push/
│   │   │   ├── manager.ts          # NEW: Push notification manager (wraps web-push)
│   │   │   ├── vapid.ts            # NEW: VAPID key loading/generation
│   │   │   └── subscription-store.ts # NEW: In-memory subscription storage
│   │   └── index.ts
│   └── notifications/
│       └── manager.ts              # Existing NotificationManager
└── dashboard/
    ├── src/
    │   ├── hooks/
    │   │   ├── useSSE.ts           # Existing SSE hook
    │   │   ├── useNotifications.ts # NEW: Notification permission + preferences
    │   │   └── usePushSubscription.ts # NEW: Push subscription management
    │   ├── components/
    │   │   └── NotificationToggle.tsx # NEW: Permission + per-type toggles
    │   ├── utils/
    │   │   └── notification-preferences.ts # NEW: localStorage persistence
    │   └── service-worker.ts       # NEW: Service Worker with push/notificationclick handlers
    ├── vite.config.ts              # Update with vite-plugin-pwa
    └── public/
        └── notification-sound.mp3  # NEW: Custom sound for questions
```

### Pattern 1: VAPID Key Generation and Loading

**What:** Generate VAPID keys once, store securely, load on server startup
**When to use:** Server initialization (once), before accepting push subscriptions
**Example:**
```typescript
// src/server/push/vapid.ts
import webpush from 'web-push';
import fs from 'node:fs/promises';
import path from 'node:path';

interface VAPIDKeys {
  publicKey: string;
  privateKey: string;
  subject: string; // mailto:your-email@example.com
}

/**
 * Load VAPID keys from environment or generate/persist to .vapid-keys.json
 * For production: use environment variables or secret manager
 * For development: auto-generate and persist to git-ignored file
 */
export async function loadVAPIDKeys(): Promise<VAPIDKeys> {
  // Production: load from environment
  if (process.env.VAPID_PUBLIC_KEY && process.env.VAPID_PRIVATE_KEY) {
    return {
      publicKey: process.env.VAPID_PUBLIC_KEY,
      privateKey: process.env.VAPID_PRIVATE_KEY,
      subject: process.env.VAPID_SUBJECT || 'mailto:support@gsd-autopilot.dev'
    };
  }

  // Development: generate once and persist
  const keysPath = path.join(process.cwd(), '.vapid-keys.json');
  try {
    const content = await fs.readFile(keysPath, 'utf-8');
    return JSON.parse(content);
  } catch {
    // Generate new keys
    const keys = webpush.generateVAPIDKeys();
    const vapidKeys: VAPIDKeys = {
      publicKey: keys.publicKey,
      privateKey: keys.privateKey,
      subject: 'mailto:dev@gsd-autopilot.local'
    };
    await fs.writeFile(keysPath, JSON.stringify(vapidKeys, null, 2));
    console.log('[VAPID] Generated new keys:', keysPath);
    return vapidKeys;
  }
}
```
**Source:** Based on [web-push documentation](https://github.com/web-push-libs/web-push) and [VAPID authentication best practices](https://rossta.net/blog/using-the-web-push-api-with-vapid.html)

### Pattern 2: Service Worker Push and Notification Click Handlers

**What:** Service Worker receives push events, displays notifications, and handles clicks
**When to use:** Service Worker script (runs in background, even when tab closed)
**Example:**
```typescript
// dashboard/src/service-worker.ts (registered by vite-plugin-pwa)
/// <reference lib="webworker" />
declare const self: ServiceWorkerGlobalScope;

// Push event: receive push from server, display notification
self.addEventListener('push', (event) => {
  if (!event.data) return;

  const data = event.data.json();
  const { title, body, icon, badge, tag, requireInteraction, data: payload } = data;

  event.waitUntil(
    self.registration.showNotification(title, {
      body,
      icon: icon || '/icon-192.png',
      badge: badge || '/badge-72.png',
      tag, // Group notifications with same tag
      requireInteraction, // Persist until dismissed for action-needed notifications
      silent: payload.silent ?? false,
      data: payload, // Store metadata for click handler
    })
  );
});

// Notification click: focus existing tab or open new one
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const urlToOpen = event.notification.data?.url || '/';

  event.waitUntil(
    self.clients
      .matchAll({ type: 'window', includeUncontrolled: true })
      .then((clientList) => {
        // Focus existing window if found
        for (const client of clientList) {
          if (client.url === urlToOpen && 'focus' in client) {
            return client.focus();
          }
        }
        // Open new window if no match
        if (self.clients.openWindow) {
          return self.clients.openWindow(urlToOpen);
        }
      })
  );
});
```
**Source:** [MDN: ServiceWorkerGlobalScope notificationclick event](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/notificationclick_event), [Common notification patterns](https://web.dev/articles/push-notifications-common-notification-patterns)

### Pattern 3: Client-Side Push Subscription Management

**What:** Request permission, subscribe to push, send subscription to server
**When to use:** Dashboard initialization, user enables notifications
**Example:**
```typescript
// dashboard/src/hooks/usePushSubscription.ts
import { useEffect, useState } from 'react';

export function usePushSubscription(vapidPublicKey: string) {
  const [subscription, setSubscription] = useState<PushSubscription | null>(null);
  const [permission, setPermission] = useState<NotificationPermission>('default');

  // Request permission and subscribe
  const subscribe = async () => {
    if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
      throw new Error('Push notifications not supported');
    }

    const permissionResult = await Notification.requestPermission();
    setPermission(permissionResult);

    if (permissionResult !== 'granted') {
      throw new Error('Notification permission denied');
    }

    const registration = await navigator.serviceWorker.ready;
    const sub = await registration.pushManager.subscribe({
      userVisibleOnly: true, // Required by spec
      applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),
    });

    // Send subscription to server
    await fetch('/api/push/subscribe', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(sub.toJSON()),
    });

    setSubscription(sub);
    return sub;
  };

  // Check existing subscription on mount
  useEffect(() => {
    navigator.serviceWorker.ready.then(async (registration) => {
      const existingSub = await registration.pushManager.getSubscription();
      setSubscription(existingSub);
      if (existingSub) {
        // Sync with server
        await fetch('/api/push/subscribe', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(existingSub.toJSON()),
        });
      }
    });

    setPermission(Notification.permission);
  }, []);

  return { subscription, permission, subscribe };
}

// Convert VAPID public key from base64 to Uint8Array
function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
  const rawData = window.atob(base64);
  return Uint8Array.from([...rawData].map((char) => char.charCodeAt(0)));
}
```
**Source:** [MDN: PushManager.subscribe()](https://developer.mozilla.org/en-US/docs/Web/API/PushManager/subscribe), [Web Push documentation](https://github.com/web-push-libs/web-push)

### Pattern 4: Server-Side Push Notification Delivery

**What:** Send push notification to subscribed clients using web-push library
**When to use:** When SSE events fire (question-pending, error, phase-completed, build-complete)
**Example:**
```typescript
// src/server/push/manager.ts
import webpush from 'web-push';
import type { VAPIDKeys } from './vapid.js';

export class PushNotificationManager {
  private subscriptions = new Map<string, webpush.PushSubscription>(); // In-memory store

  constructor(vapidKeys: VAPIDKeys) {
    webpush.setVapidDetails(
      vapidKeys.subject,
      vapidKeys.publicKey,
      vapidKeys.privateKey
    );
  }

  addSubscription(id: string, subscription: webpush.PushSubscription): void {
    this.subscriptions.set(id, subscription);
  }

  removeSubscription(id: string): void {
    this.subscriptions.delete(id);
  }

  async sendNotification(payload: {
    title: string;
    body: string;
    tag?: string;
    requireInteraction?: boolean;
    silent?: boolean;
    url?: string;
  }): Promise<void> {
    const notificationPayload = JSON.stringify(payload);

    const results = await Promise.allSettled(
      Array.from(this.subscriptions.entries()).map(async ([id, sub]) => {
        try {
          await webpush.sendNotification(sub, notificationPayload, {
            TTL: 3600, // 1 hour
            urgency: payload.requireInteraction ? 'high' : 'normal',
          });
        } catch (error: any) {
          // Remove expired/invalid subscriptions
          if (error.statusCode === 404 || error.statusCode === 410) {
            this.subscriptions.delete(id);
          }
          throw error;
        }
      })
    );

    const failures = results.filter((r) => r.status === 'rejected');
    if (failures.length > 0) {
      console.warn(`[Push] ${failures.length} notifications failed to send`);
    }
  }
}
```
**Source:** [web-push sendNotification API](https://github.com/web-push-libs/web-push), [Web Push Protocol TTL and urgency](https://web.dev/articles/push-notifications-web-push-protocol)

### Pattern 5: Notification Grouping with Tag Parameter

**What:** Use `tag` parameter to replace previous notifications instead of stacking
**When to use:** Multiple questions arrive simultaneously, avoid notification spam
**Example:**
```typescript
// When multiple questions pending, group into single notification
const questionCount = pendingQuestions.length;
if (questionCount > 1) {
  await pushManager.sendNotification({
    title: 'GSD Autopilot: Questions need your input',
    body: `${questionCount} questions are waiting for your response`,
    tag: 'questions-grouped', // Same tag = replace previous notification
    requireInteraction: true,
    url: '/questions',
  });
} else {
  // Single question notification
  await pushManager.sendNotification({
    title: 'GSD Autopilot: Question needs your input',
    body: question.title,
    tag: `question-${question.id}`,
    requireInteraction: true,
    url: `/questions/${question.id}`,
  });
}
```
**Source:** [MDN: Notification.tag](https://developer.mozilla.org/en-US/docs/Web/API/Notification/tag), [Common notification patterns](https://web.dev/articles/push-notifications-common-notification-patterns)

### Pattern 6: localStorage Notification Preferences

**What:** Persist per-type notification toggles in localStorage, sync with React state
**When to use:** User toggles notification preferences, load preferences on mount
**Example:**
```typescript
// dashboard/src/utils/notification-preferences.ts
export interface NotificationPreferences {
  questions: boolean;
  errors: boolean;
  phaseCompleted: boolean;
  buildComplete: boolean;
}

const STORAGE_KEY = 'gsd-notification-preferences';

export function loadNotificationPreferences(): NotificationPreferences {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored) {
      return { ...getDefaults(), ...JSON.parse(stored) };
    }
  } catch {
    // Ignore parse errors
  }
  return getDefaults();
}

export function saveNotificationPreferences(prefs: NotificationPreferences): void {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(prefs));
}

function getDefaults(): NotificationPreferences {
  return {
    questions: true,    // Action-needed: default on
    errors: true,       // Action-needed: default on
    phaseCompleted: false, // Informational: default off
    buildComplete: true,   // Informational but important: default on
  };
}

// React hook
import { useState, useEffect } from 'react';

export function useNotificationPreferences() {
  const [prefs, setPrefs] = useState<NotificationPreferences>(loadNotificationPreferences);

  const updatePref = (type: keyof NotificationPreferences, enabled: boolean) => {
    const updated = { ...prefs, [type]: enabled };
    setPrefs(updated);
    saveNotificationPreferences(updated);
  };

  return { prefs, updatePref };
}
```
**Source:** [localStorage with React patterns](https://www.robinwieruch.de/local-storage-react/), [Managing persistent browser data](https://www.yeti.co/blog/managing-persistent-browser-data-with-usesyncexternalstore)

### Pattern 7: Badge API for Question Count

**What:** Update browser tab/app icon badge with pending question count
**When to use:** Question state changes (new question, answered question)
**Example:**
```typescript
// dashboard/src/hooks/useBadgeCount.ts
import { useEffect } from 'react';
import { useDashboardStore } from '../store/index.js';

export function useBadgeCount() {
  const questions = useDashboardStore((s) => s.questions);

  useEffect(() => {
    const pendingCount = questions.filter((q) => q.status === 'pending').length;

    if ('setAppBadge' in navigator) {
      if (pendingCount > 0) {
        navigator.setAppBadge(pendingCount).catch(() => {
          // Badge API not supported or permission denied
        });
      } else {
        navigator.clearAppBadge().catch(() => {});
      }
    }
  }, [questions]);
}
```
**Source:** [MDN: Badge API](https://developer.mozilla.org/en-US/docs/Web/API/Badging_API), [Chrome Badging API guide](https://developer.chrome.com/docs/capabilities/web-apis/badging-api)

**Important:** Badge API support is limited (Chrome/Edge on Windows/macOS only, Safari on iOS/iPadOS 16.4+). Treat as progressive enhancement.

### Pattern 8: Vite PWA Plugin Configuration

**What:** Configure vite-plugin-pwa to generate Service Worker and manifest
**When to use:** Dashboard build configuration (vite.config.ts)
**Example:**
```typescript
// dashboard/vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      strategies: 'injectManifest', // Custom service-worker.ts
      srcDir: 'src',
      filename: 'service-worker.ts',
      registerType: 'autoUpdate', // Auto-update on new version
      injectRegister: 'auto', // Auto-register on page load
      manifest: {
        name: 'GSD Autopilot Dashboard',
        short_name: 'GSD',
        description: 'Get Shit Done Autopilot Dashboard',
        theme_color: '#1f2937',
        icons: [
          {
            src: '/icon-192.png',
            sizes: '192x192',
            type: 'image/png',
          },
          {
            src: '/icon-512.png',
            sizes: '512x512',
            type: 'image/png',
          },
        ],
      },
      devOptions: {
        enabled: true, // Enable in dev mode for testing
        type: 'module',
      },
    }),
  ],
});
```
**Source:** [vite-plugin-pwa documentation](https://vite-pwa-org.netlify.app/), [Vite PWA inject manifest guide](https://vite-pwa-org.netlify.app/guide/inject-manifest.html)

### Anti-Patterns to Avoid

- **Requesting permission on page load without context:** Modern browsers penalize or block this. Always request after user interaction or "soft ask" prompt explaining benefits.
- **Opening new window on every notification click:** Search for existing window with same URL first, focus it if found. Only use `clients.openWindow()` if no match exists.
- **Storing VAPID private key in client-side code:** Private key MUST stay server-side. Only public key goes to client.
- **Not handling expired/invalid push subscriptions:** web-push returns 404/410 for expired subscriptions. Remove them from storage to avoid repeated failures.
- **Hand-rolling notification grouping logic:** Use the `tag` parameter instead of custom client-side deduplication.
- **Blocking Node.js exit with Service Worker message loops:** Use `event.waitUntil()` in Service Worker to extend lifetime, not setInterval or infinite loops.
- **Caching Service Worker script itself:** Service Workers should be served with `Cache-Control: no-cache` to ensure updates propagate quickly.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Service Worker generation + registration | Custom webpack config + manual registration logic | `vite-plugin-pwa` | Service Worker bundling, registration, update lifecycle, and manifest generation have many edge cases. Workbox integration handles precaching, runtime caching, and offline support automatically. |
| Web Push encryption | Custom crypto for encrypting push payloads | `web-push` npm package | Web Push Protocol requires ECDH encryption, VAPID JWT signing, and specific header formatting. Crypto is complex and error-prone—use battle-tested library. |
| Push subscription storage | Custom database schema | In-memory Map for MVP, add Redis/database if needed | Push subscriptions are ephemeral (expire, users unsubscribe). In-memory storage is sufficient for single-server deployments. Only add persistence if scaling horizontally. |
| Notification permission UI | Custom modal dialogs | Native `Notification.requestPermission()` + soft ask banner | Native permission prompt is familiar to users and respects OS settings. Custom modals confuse users and don't integrate with browser permission memory. |
| Base64 URL decoding | Custom string manipulation | Standard `atob()` + typed array conversion | VAPID public key conversion has padding edge cases. Use proven pattern from Web Push docs. |
| Badge count display | Favicon manipulation via canvas | Badge API (`navigator.setAppBadge()`) | Favicon hacks don't integrate with OS notification centers and break on browser updates. Badge API is standard and progressive enhancement. |

**Key insight:** Browser notification APIs are well-standardized but have many sharp edges (permission states, encryption, Service Worker lifecycle, subscription expiry). Use established libraries and patterns from official docs—don't try to "simplify" by building custom solutions.

## Common Pitfalls

### Pitfall 1: Permission Denied State with No Recovery Path
**What goes wrong:** User clicks "Block" on permission prompt, notifications permanently disabled with no way to re-enable from app UI.
**Why it happens:** `Notification.permission === 'denied'` is permanent until user manually changes in browser settings. App has no programmatic way to re-trigger prompt.
**How to avoid:**
1. Only request permission after "soft ask" (user clicks "Enable Notifications" button after seeing benefits)
2. If permission is 'denied', show persistent help text: "Notifications blocked. Enable in browser settings: chrome://settings/content/notifications"
3. Check `Notification.permission` before calling `requestPermission()` to avoid repeated blocked prompts
**Warning signs:** Users complaining "notifications aren't working" without clear path to fix.

**Source:** [MDN: Notification.requestPermission()](https://developer.mozilla.org/en-US/docs/Web/API/Notification/requestPermission_static), [Push notification best practices](https://reteno.com/blog/push-notification-best-practices-ultimate-guide-for-2026)

### Pitfall 2: Service Worker Update Not Activating
**What goes wrong:** Deploy new Service Worker code, but clients stay on old version indefinitely.
**Why it happens:** Service Workers enter "waiting" state if old version still has active clients. New version won't activate until all tabs close.
**How to avoid:**
1. Use `vite-plugin-pwa` with `registerType: 'autoUpdate'` to auto-activate on page reload
2. For immediate updates, call `skipWaiting()` in Service Worker and `clients.claim()` in activate event
3. Show "Update available" UI to prompt user to reload
4. Serve Service Worker script with `Cache-Control: no-cache` header
**Warning signs:** Bug fixes or notification changes not appearing for users until they restart browser.

**Source:** [Service Worker lifecycle](https://web.dev/articles/service-worker-lifecycle), [Handling Service Worker updates](https://developer.chrome.com/docs/workbox/handling-service-worker-updates)

### Pitfall 3: Push Subscriptions Expiring Silently
**What goes wrong:** Server sends push notifications but they never arrive. No errors logged.
**Why it happens:** Push subscriptions expire after inactivity (~30 days), or user unsubscribes via browser settings. web-push returns 404/410 but server keeps trying.
**How to avoid:**
1. Wrap `webpush.sendNotification()` in try-catch
2. Remove subscriptions on 404/410 errors: `if (error.statusCode === 404 || error.statusCode === 410) { subscriptions.delete(id); }`
3. Implement `pushsubscriptionchange` event in Service Worker to detect endpoint changes and re-sync with server
4. Check `PushSubscription.expirationTime` if available (not widely supported)
**Warning signs:** Declining notification delivery rates over time, especially for long-idle users.

**Source:** [PushSubscription.unsubscribe()](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription/unsubscribe), [Web Push error 410](https://pushpad.xyz/blog/web-push-error-410-the-push-subscription-has-expired-or-the-user-has-unsubscribed)

### Pitfall 4: Notification Sound Not Playing (Browser Limitation)
**What goes wrong:** Set `sound` option in notification, but browser ignores it completely.
**Why it happens:** Despite being in Notifications API spec, **no browser currently supports custom notification sounds**. Feature is unimplemented.
**How to avoid:**
1. **Workaround for open tabs:** If dashboard tab is open, play audio via `<audio>` element or Web Audio API when SSE event fires (before showing notification)
2. **Workaround for closed tabs:** Service Worker can send `postMessage` to any open client windows, which then play audio
3. **Document limitation:** Tell users custom sounds only work when dashboard is open, rely on system notification sound otherwise
4. Set `silent: false` (default) to ensure system sound plays
**Warning signs:** Users expecting custom alert sound for questions, hearing only system default.

**Source:** [ServiceWorkerRegistration.showNotification()](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification), [Web notifications behavior](https://web.dev/articles/push-notifications-notification-behaviour)

### Pitfall 5: Notification Spam from Multiple Questions
**What goes wrong:** Three questions arrive in quick succession, user gets three separate notification popups, feels overwhelmed.
**Why it happens:** Default behavior is one notification per `showNotification()` call. No automatic grouping.
**How to avoid:**
1. Use `tag` parameter to group notifications: same tag = replace previous notification
2. Debounce question-pending events on server side (wait 500ms for more questions before sending push)
3. If multiple questions pending, send single notification: "3 questions need your attention"
4. Click on grouped notification opens `/questions` list page, not individual question
**Warning signs:** Users disabling notifications due to "too many alerts."

**Source:** [Notification.tag](https://developer.mozilla.org/en-US/docs/Web/API/Notification/tag), [Push notification best practices](https://reteno.com/blog/push-notification-best-practices-ultimate-guide-for-2026)

### Pitfall 6: requireInteraction Overuse Causing Clutter
**What goes wrong:** All notifications set `requireInteraction: true`, user's screen filled with persistent notifications.
**Why it happens:** `requireInteraction: true` prevents auto-dismiss—notifications stay until user clicks. Appropriate for action-needed, not informational.
**How to avoid:**
1. Use `requireInteraction: true` ONLY for: questions (need answer), errors (need resolution)
2. Use `requireInteraction: false` (or omit) for: phase-completed, build-complete (informational)
3. Auto-dismiss informational notifications after ~8 seconds (browser default on Chrome desktop)
4. Set `silent: true` for informational notifications to avoid unnecessary audio alerts
**Warning signs:** Notification tray cluttered with old "Phase completed" notifications.

**Source:** [Notification.requireInteraction](https://developer.mozilla.org/en-US/docs/Web/API/Notification/requireInteraction), [Notification behavior](https://web.dev/articles/push-notifications-notification-behaviour)

### Pitfall 7: VAPID Keys Committed to Git
**What goes wrong:** Developer commits `.vapid-keys.json` or adds keys to `.env.example`, leaking private key to public repository.
**Why it happens:** VAPID key generation happens early in development, easy to forget to add to `.gitignore`.
**How to avoid:**
1. Add `.vapid-keys.json` to `.gitignore` IMMEDIATELY after generating keys
2. For production, use environment variables or secret manager (AWS Secrets Manager, HashiCorp Vault)
3. Never commit private keys—only public keys are safe to share
4. Rotate keys if accidentally committed (generate new pair, update server config)
**Warning signs:** GitHub security alerts, unauthorized push notifications from attacker.

**Source:** [VAPID authentication](https://deepwiki.com/pushpad/web-push/2.1-vapid-authentication), [Environment variable security](https://qwiet.ai/keeping-secrets-a-deep-dive-into-robust-and-secure-environment-variable-management-for-developers/)

### Pitfall 8: Badge API Not Working (Limited Browser Support)
**What goes wrong:** Call `navigator.setAppBadge()`, no badge appears on browser tab or app icon.
**Why it happens:** Badge API support is limited: Chrome/Edge on Windows/macOS (only for installed PWAs), Safari on iOS/iPadOS 16.4+. Not supported on Linux or Firefox.
**How to avoid:**
1. Feature detect before using: `if ('setAppBadge' in navigator) { ... }`
2. Treat as progressive enhancement—don't break app if unavailable
3. Wrap calls in try-catch: `navigator.setAppBadge(count).catch(() => {})`
4. Document limitation: badges require PWA installation on some platforms
**Warning signs:** Users expecting badge count but seeing nothing (especially on Linux or Firefox).

**Source:** [Badge API browser support](https://developer.chrome.com/docs/capabilities/web-apis/badging-api), [Display badge on app icon](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/How_to/Display_badge_on_app_icon)

### Pitfall 9: Service Worker Scope Issues
**What goes wrong:** Service Worker registered but doesn't receive push events or can't control pages.
**Why it happens:** Service Worker scope defaults to directory where script is located. If script is in `/sw/`, can only control `/sw/**` pages.
**How to avoid:**
1. Use `vite-plugin-pwa` which automatically places Service Worker at root with correct scope (`/`)
2. If manually registering, ensure Service Worker script is served from root: `/service-worker.js`
3. Verify scope in DevTools: Application > Service Workers > scope should be `/`
4. Use `clients.claim()` in activate event to take control of existing clients
**Warning signs:** Service Worker shows as "activated" but notifications don't work, or only work after full browser restart.

**Source:** [Service Worker scope documentation](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers), [Service Worker gotchas](https://osvaldas.info/service-worker-gotchas/)

### Pitfall 10: localStorage Not Syncing Across Tabs
**What goes wrong:** User disables question notifications in one tab, other tabs still show as enabled.
**Why it happens:** localStorage changes don't automatically trigger re-renders in React. Need to listen for `storage` event.
**How to avoid:**
1. Listen for `storage` event and update Zustand store:
   ```typescript
   useEffect(() => {
     const handleStorageChange = (e: StorageEvent) => {
       if (e.key === 'gsd-notification-preferences') {
         setPrefs(loadNotificationPreferences());
       }
     };
     window.addEventListener('storage', handleStorageChange);
     return () => window.removeEventListener('storage', handleStorageChange);
   }, []);
   ```
2. Or use Zustand with localStorage middleware (persists state automatically)
3. Note: `storage` event only fires in OTHER tabs, not the tab that made the change
**Warning signs:** Notification preferences appearing out of sync between multiple dashboard tabs.

**Source:** [localStorage change detection](https://medium.com/@gauravap101/why-your-localstorage-changes-arent-being-detected-and-how-to-fix-it-62785d53b1ea), [Managing persistent browser data](https://www.yeti.co/blog/managing-persistent-browser-data-with-usesyncexternalstore)

## Code Examples

Verified patterns from official sources:

### Converting VAPID Public Key for PushManager
```typescript
// Source: https://github.com/web-push-libs/web-push
function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding)
    .replace(/-/g, '+')
    .replace(/_/g, '/');
  const rawData = window.atob(base64);
  return Uint8Array.from([...rawData].map((char) => char.charCodeAt(0)));
}
```

### Sending Push Notification with web-push
```typescript
// Source: https://github.com/web-push-libs/web-push
import webpush from 'web-push';

webpush.setVapidDetails(
  'mailto:support@example.com',
  process.env.VAPID_PUBLIC_KEY!,
  process.env.VAPID_PRIVATE_KEY!
);

const subscription = {
  endpoint: 'https://fcm.googleapis.com/fcm/send/...',
  keys: {
    p256dh: '...',
    auth: '...',
  },
};

await webpush.sendNotification(
  subscription,
  JSON.stringify({
    title: 'GSD Autopilot: Question needs your input',
    body: 'How should I handle the API error?',
    tag: 'question-123',
    requireInteraction: true,
    url: '/questions/123',
  }),
  {
    TTL: 3600, // 1 hour
    urgency: 'high', // 'very-low' | 'low' | 'normal' | 'high'
  }
);
```

### Service Worker Push Event Handler
```typescript
// Source: https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/push_event
/// <reference lib="webworker" />
declare const self: ServiceWorkerGlobalScope;

self.addEventListener('push', (event) => {
  if (!event.data) return;

  const payload = event.data.json();

  event.waitUntil(
    self.registration.showNotification(payload.title, {
      body: payload.body,
      icon: '/icon-192.png',
      badge: '/badge-72.png',
      tag: payload.tag,
      requireInteraction: payload.requireInteraction ?? false,
      silent: payload.silent ?? false,
      data: { url: payload.url },
    })
  );
});
```

### Notification Click Handler with Window Focus
```typescript
// Source: https://web.dev/articles/push-notifications-common-notification-patterns
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const urlToOpen = new URL(event.notification.data.url, self.location.origin).href;

  event.waitUntil(
    self.clients
      .matchAll({ type: 'window', includeUncontrolled: true })
      .then((windowClients) => {
        // Focus existing window if URL matches
        for (const client of windowClients) {
          if (client.url === urlToOpen && 'focus' in client) {
            return client.focus();
          }
        }
        // Open new window if no match
        if (self.clients.openWindow) {
          return self.clients.openWindow(urlToOpen);
        }
      })
  );
});
```

### Subscribing to Push Notifications
```typescript
// Source: https://developer.mozilla.org/en-US/docs/Web/API/PushManager/subscribe
async function subscribeToPush(vapidPublicKey: string): Promise<PushSubscription> {
  const registration = await navigator.serviceWorker.ready;

  const subscription = await registration.pushManager.subscribe({
    userVisibleOnly: true, // Required by spec
    applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),
  });

  return subscription;
}
```

### Badge API Usage
```typescript
// Source: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/setAppBadge
function updateQuestionBadge(count: number): void {
  if (!('setAppBadge' in navigator)) {
    return; // Badge API not supported
  }

  if (count > 0) {
    navigator.setAppBadge(count).catch(() => {
      // Silently fail if permission denied or not supported
    });
  } else {
    navigator.clearAppBadge().catch(() => {});
  }
}
```

### Vite Plugin PWA with Custom Service Worker
```typescript
// Source: https://vite-pwa-org.netlify.app/guide/inject-manifest.html
// vite.config.ts
import { defineConfig } from 'vite';
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
  plugins: [
    VitePWA({
      strategies: 'injectManifest',
      srcDir: 'src',
      filename: 'service-worker.ts',
      registerType: 'autoUpdate',
      injectRegister: 'auto',
      manifest: {
        name: 'GSD Autopilot Dashboard',
        short_name: 'GSD',
        icons: [
          { src: '/icon-192.png', sizes: '192x192', type: 'image/png' },
          { src: '/icon-512.png', sizes: '512x512', type: 'image/png' },
        ],
      },
      devOptions: {
        enabled: true,
        type: 'module',
      },
    }),
  ],
});
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| GCM (Google Cloud Messaging) | VAPID + Web Push Protocol | ~2016 | No longer need Google/Firebase account. Use open standard with any push service. |
| `new Notification()` in page context | `ServiceWorkerRegistration.showNotification()` | ~2017 | Background notifications now work even when tab closed. Required for persistent notifications. |
| Polling for new events | Server-Sent Events (SSE) + Push API | 2015+ | Real-time updates without polling overhead. GSD already uses SSE for in-tab updates, adding push for background. |
| Favicon badge hacks (canvas manipulation) | Badge API (`navigator.setAppBadge()`) | 2020+ | Native OS integration for badge counts. Limited support but proper standard. |
| Manual Service Worker generation | Workbox + build tool plugins | 2018+ | Auto-generated, versioned Service Workers with precaching. vite-plugin-pwa uses Workbox internally. |
| `skipWaiting()` immediately on install | Prompt user with "Update available" | 2019+ | Better UX—user controls when update activates. Prevents breaking active sessions. vite-plugin-pwa supports both patterns. |

**Deprecated/outdated:**
- **Firebase Cloud Messaging for Web (FCM)**: Still works but unnecessary complexity. VAPID + web-push gives same functionality without vendor lock-in. Only use FCM if already integrated for mobile push.
- **Notification.permission === 'default' triggering automatic prompt**: Browsers now penalize or block auto-prompts. Must request after user gesture.
- **Push without Service Worker**: Old "Push API" without Service Worker is deprecated. Must use Service Worker + PushManager.
- **GCM sender ID**: Legacy Google Cloud Messaging. Replaced by VAPID keys.

## Open Questions

### 1. Custom Notification Sound for Questions
**What we know:**
- Notifications API includes `sound` option in spec
- Zero browsers currently implement it (Chrome, Firefox, Edge, Safari all ignore)
- System default sound plays instead

**What's unclear:**
- Will browsers ever implement custom sounds? (Low priority for years)
- Is there a reliable workaround for background notifications?

**Recommendation:**
- **For open tabs**: Play custom sound via `<audio>` element when SSE event fires, BEFORE showing notification
- **For closed tabs**: Accept limitation, document that custom sound only works when dashboard open
- Set `silent: false` to ensure system sound plays as fallback
- Re-evaluate in 6-12 months if browser support changes

**Confidence:** MEDIUM (workaround proven, but browser support outlook unclear)

### 2. VAPID Key Rotation Strategy
**What we know:**
- VAPID keys should be rotated periodically for security
- Rotating keys invalidates ALL existing push subscriptions
- Users must re-subscribe after rotation

**What's unclear:**
- Optimal rotation frequency for low-risk application (yearly? never?)
- Best way to handle mass re-subscription (how to prompt users?)

**Recommendation:**
- **For MVP**: Don't implement rotation—complexity outweighs benefit for internal tool
- **If needed**: Rotate keys only on suspected compromise
- **Re-subscription UX**: Show banner "Notifications need to be re-enabled" with one-click re-subscribe
- Store key generation date in database to track age

**Confidence:** HIGH (rotation best practices well documented)

### 3. Push Subscription Storage Persistence
**What we know:**
- In-memory Map loses subscriptions on server restart
- Push subscriptions are ephemeral (expire, users unsubscribe)
- Single-server deployment (no horizontal scaling currently)

**What's unclear:**
- How often do subscriptions actually expire? (Need telemetry)
- Does restart frequency justify database complexity?

**Recommendation:**
- **For MVP**: Use in-memory Map—subscriptions auto-re-register when dashboard loads
- **Add persistence if**: Server restarts >1x/day OR users report missing notifications after restart
- **Persistence approach**: Redis (fast, ephemeral data) or SQLite (embedded, no external dependency)

**Confidence:** HIGH (in-memory sufficient for MVP based on usage patterns)

### 4. Badge API Limited Support Impact
**What we know:**
- Badge API only works: Chrome/Edge (Windows/macOS, PWA installed), Safari (iOS 16.4+)
- Not supported: Firefox (all platforms), Linux (all browsers), non-installed web apps

**What's unclear:**
- What % of users will actually see badges?
- Does lack of badge significantly harm UX?

**Recommendation:**
- Implement Badge API as progressive enhancement
- Primary notification method is push notifications (universal support)
- Badge is "nice to have" visual reminder, not critical
- Track usage via analytics to see adoption

**Confidence:** HIGH (badge is non-critical enhancement)

### 5. Notification Permission Prompt Timing
**What we know:**
- User constraints say "request on first dashboard visit"
- Best practices say "request after user interaction/soft ask"
- Modern browsers penalize immediate prompts

**What's unclear:**
- Is "first visit" automatic prompt or after soft ask?
- Will browsers block immediate prompts in future updates?

**Recommendation:**
- Show soft ask banner on first visit: "Enable notifications to get alerts when autopilot needs your input"
- Request permission ONLY when user clicks "Enable" button
- Interpret "first dashboard visit" as "first opportunity to show soft ask," not "automatic prompt"
- This balances user constraints with browser best practices

**Confidence:** HIGH (soft ask is current best practice, unlikely to change)

## Sources

### Primary (HIGH confidence)
- [MDN: Notifications API](https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API)
- [MDN: Using the Notifications API](https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API/Using_the_Notifications_API)
- [MDN: Service Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)
- [web-push npm package](https://www.npmjs.com/package/web-push)
- [web-push GitHub repository](https://github.com/web-push-libs/web-push)
- [vite-plugin-pwa documentation](https://vite-pwa-org.netlify.app/)
- [Chrome Developers: Web Push Protocol](https://web.dev/articles/push-notifications-web-push-protocol)
- [Chrome Developers: Notification behavior](https://web.dev/articles/push-notifications-notification-behaviour)
- [Chrome Developers: Service Worker lifecycle](https://web.dev/articles/service-worker-lifecycle)
- [MDN: Badge API](https://developer.mozilla.org/en-US/docs/Web/API/Badging_API)
- [Chrome: Badge API guide](https://developer.chrome.com/docs/capabilities/web-apis/badging-api)

### Secondary (MEDIUM confidence)
- [Web Push with VAPID](https://rossta.net/blog/using-the-web-push-api-with-vapid.html)
- [Push notification best practices 2026](https://reteno.com/blog/push-notification-best-practices-ultimate-guide-for-2026)
- [Common notification patterns](https://web.dev/articles/push-notifications-common-notification-patterns)
- [Service Worker gotchas](https://osvaldas.info/service-worker-gotchas/)
- [localStorage with React](https://www.robinwieruch.de/local-storage-react/)
- [Managing persistent browser data](https://www.yeti.co/blog/managing-persistent-browser-data-with-usesyncexternalstore)
- [VAPID authentication guide](https://deepwiki.com/pushpad/web-push/2.1-vapid-authentication)
- [Handling Service Worker updates](https://developer.chrome.com/docs/workbox/handling-service-worker-updates)

### Tertiary (LOW confidence, needs validation)
- [Web Push error 410](https://pushpad.xyz/blog/web-push-error-410-the-push-subscription-has-expired-or-the-user-has-unsubscribed)
- [Environment variable security](https://qwiet.ai/keeping-secrets-a-deep-dive-into-robust-and-secure-environment-variable-management-for-developers/)
- [localStorage change detection](https://medium.com/@gauravap101/why-your-localstorage-changes-arent-being-detected-and-how-to-fix-it-62785d53b1ea)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries are official, widely adopted, and well-documented
- Architecture: HIGH - Patterns verified from MDN, Chrome Developers, and official library docs
- Pitfalls: HIGH - Based on documented issues from GitHub, MDN, and developer blogs
- Open questions: MEDIUM - Most questions have clear recommendations, but some unknowns (custom sound browser support, subscription expiry telemetry)

**Research date:** 2026-02-24
**Valid until:** 2026-04-24 (60 days - stable web standards, but check for browser updates)

**Additional notes:**
- Existing GSD codebase already has: SSE infrastructure, Express server on port 3847, React 19 dashboard with Zustand 5, notification system with adapters
- This phase ADDS: Browser notification channel to existing notification system
- VAPID key generation should happen during phase execution, not pre-planning
- Test on multiple browsers (Chrome, Firefox, Edge, Safari) due to varying support for Badge API and Service Worker behaviors
