---
phase: 06.1-add-browser-notifications-to-alert-users-when-needed
plan: 04
type: execute
wave: 3
depends_on: ["06.1-01", "06.1-03"]
files_modified:
  - autopilot/src/server/index.ts
  - autopilot/src/server/standalone.ts
  - autopilot/src/server/routes/sse.ts
  - autopilot/dashboard/src/hooks/useSSE.ts
  - autopilot/dashboard/src/hooks/useNotificationSound.ts
autonomous: true

must_haves:
  truths:
    - "When a question-pending event fires, a push notification is sent to all subscribed browsers with title 'GSD Autopilot: Question needs your input' and requireInteraction=true"
    - "When an error escalation event fires, a push notification is sent with the error message in the body"
    - "When phase-completed fires, an auto-dismissing push notification is sent with phase name"
    - "When build-complete fires, a push notification includes summary stats (phases completed, duration)"
    - "Multiple simultaneous questions are grouped into a single notification (e.g. '3 questions need your attention')"
    - "Question reminders do NOT re-fire browser push notifications (only the initial question triggers one)"
    - "When dashboard tab is open, question notifications play a sound via HTML Audio API"
    - "Push subscription routes are mounted at /api/push on both in-process and standalone servers"
  artifacts:
    - path: "autopilot/src/server/index.ts"
      provides: "ResponseServer mounts push routes and initializes PushNotificationManager"
    - path: "autopilot/src/server/routes/sse.ts"
      provides: "SSE event handlers dispatch push notifications via PushNotificationManager"
    - path: "autopilot/dashboard/src/hooks/useNotificationSound.ts"
      provides: "Foreground notification sound for questions when tab is open"
      exports: ["useNotificationSound"]
  key_links:
    - from: "autopilot/src/server/routes/sse.ts"
      to: "autopilot/src/server/push/manager.ts"
      via: "pushManager.sendToAll() on SSE event broadcast"
      pattern: "pushManager\\.sendToAll"
    - from: "autopilot/src/server/index.ts"
      to: "autopilot/src/server/routes/push.ts"
      via: "app.use('/api/push', pushRouter)"
      pattern: "use.*api/push"
    - from: "autopilot/dashboard/src/hooks/useNotificationSound.ts"
      to: "notification-sound.mp3"
      via: "new Audio() on SSE question-pending event"
      pattern: "new Audio.*notification-sound"
---

<objective>
Wire everything together: mount push routes on the server, trigger push notifications from SSE events, add notification grouping for questions, and add foreground notification sound for the dashboard.

Purpose: This is the integration plan that connects the server push infrastructure (Plan 01) with the dashboard subscription (Plan 03) through the existing SSE event system, completing the end-to-end notification flow.

Output: Push notifications fire on the four trigger events (question-pending, error, phase-completed, build-complete), question grouping works, foreground sound plays for questions.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.1-add-browser-notifications-to-alert-users-when-needed/06.1-RESEARCH.md
@.planning/phases/06.1-add-browser-notifications-to-alert-users-when-needed/06.1-01-SUMMARY.md
@.planning/phases/06.1-add-browser-notifications-to-alert-users-when-needed/06.1-02-SUMMARY.md
@.planning/phases/06.1-add-browser-notifications-to-alert-users-when-needed/06.1-03-SUMMARY.md

# Key existing files for wiring
@autopilot/src/server/index.ts
@autopilot/src/server/standalone.ts
@autopilot/src/server/routes/sse.ts
@autopilot/src/server/routes/api.ts
@autopilot/dashboard/src/hooks/useSSE.ts
@autopilot/dashboard/src/components/Layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Mount push routes on ResponseServer and wire push dispatch to SSE events</name>
  <files>
    autopilot/src/server/index.ts
    autopilot/src/server/standalone.ts
    autopilot/src/server/routes/sse.ts
  </files>
  <action>
**Update `autopilot/src/server/index.ts` (ResponseServer):**

Add imports for push modules:
- `import { loadVAPIDKeys } from './push/vapid.js'`
- `import { SubscriptionStore } from './push/subscription-store.js'`
- `import { PushNotificationManager } from './push/manager.js'`
- `import { createPushRoutes } from './routes/push.js'`

Add to `ResponseServerOptions` interface:
- `planningDir?: string` -- path to project's .planning/ directory for VAPID key storage

Add to the ResponseServer class:
- Private field: `private pushManager: PushNotificationManager | null = null`
- New async method: `async initPush(planningDir: string): Promise<void>` that:
  1. Creates `SubscriptionStore`
  2. Calls `loadVAPIDKeys(planningDir)` to get VAPID keys
  3. Creates `PushNotificationManager(vapidKeys, subscriptionStore)`
  4. Creates push routes: `createPushRoutes({ subscriptionStore, vapidPublicKey: vapidKeys.publicKey })`
  5. Mounts: `this.app.use('/api/push', pushRouter)` (mount BEFORE the SPA fallback)
  6. Stores pushManager on instance
- Getter: `getPushManager(): PushNotificationManager | null`

Since the Express app setup is in the constructor and push routes need async VAPID key loading, the best approach is:
- Keep the constructor synchronous (existing pattern)
- Add `initPush()` as a separate async method called AFTER construction but BEFORE `start()`
- Alternatively: accept an optional `pushManager` and `subscriptionStore` in options if they're pre-created. But the simpler approach is the separate init method.

**Update `autopilot/src/server/standalone.ts`:**

After creating the ResponseServer and before `server.start(port)`:
- Import `join` from 'node:path' (already imported)
- Calculate `planningDir`: `join(projectDir, '.planning')`
- Call `await server.initPush(planningDir)`
- Log: `console.log('Push notifications: enabled')`

**Update `autopilot/src/server/routes/sse.ts`:**

Add optional `pushManager` to both SSEDeps interfaces:
- Add to `SSEDepsInProcess`: `pushManager?: { sendToAll(payload: any): Promise<void> }`
- Add to `SSEDepsFileTail`: `pushManager?: { sendToAll(payload: any): Promise<void> }`

In the `setupSSE` function, after the existing event wiring, add push notification dispatch for the four trigger events:

For in-process mode, add AFTER the existing orchestrator/claudeService/logger event wiring:

```
if (deps.pushManager) {
  const pm = deps.pushManager;
```

1. **question-pending** -- Fire push with grouping logic:
   - Listen to `claudeService.on('question:pending', ...)` (second listener on same event)
   - Get pending question count. If the data contains question info, use it. For grouping: since this fires per-question, use a debounce approach -- set a 500ms timeout on first question, and when it fires, check total pending count
   - If 1 question: title "GSD Autopilot: Question needs your input", body = first question text (truncated), tag = 'gsd-question', url = '/questions/{id}', requireInteraction = true, silent = false
   - If multiple: title "GSD Autopilot: Questions need your input", body = "{N} questions are waiting for your response", tag = 'gsd-question' (same tag replaces), url = '/questions', requireInteraction = true, silent = false
   - Debounce: Use a simple pattern -- store a timer, on each question-pending reset it to 500ms. When timer fires, send the grouped notification. This handles rapid-fire question arrivals.

2. **error escalation** -- Fire push immediately:
   - Listen to `orchestrator.on('error:escalation', ...)`
   - Title: "GSD Autopilot: Error needs attention"
   - Body: include error message from data (per user decision: "Error notifications include the error message in the body"). Extract from `data.error` or `data.message`
   - tag: 'gsd-error', url: '/phases/{phaseNumber}' (from data), requireInteraction: true, silent: true

3. **phase-completed** -- Fire push immediately:
   - Listen to `orchestrator.on('phase:completed', ...)`
   - Title: "GSD Autopilot: Phase completed"
   - Body: phase name from data (per Claude's discretion: include phase name)
   - tag: 'gsd-phase-complete', url: '/', requireInteraction: false, silent: true

4. **build-complete** -- Fire push immediately:
   - Listen to `orchestrator.on('build:complete', ...)`
   - Title: "GSD Autopilot: Build complete!"
   - Body: Include summary stats from state if available (per user decision: "include summary stats (phases completed, duration)")
   - tag: 'gsd-build-complete', url: '/', requireInteraction: false, silent: true

For file-tail mode, add similar push dispatch in the eventTailer event handler by checking `evt.event` type.

Close the debounce timer cleanly: add `questionDebounceTimer` to module scope, clear it in `closeAll()`.

Important per user decision: "Question reminders (5-min server-side cycle) do NOT re-fire browser notifications -- only the initial question triggers one." The NotificationManager's reminder system is separate from push. The SSE events only fire on initial question, not on reminders, so this is naturally handled. No extra logic needed.
  </action>
  <verify>
Run `cd autopilot && npx tsc --noEmit` -- should compile without errors. Verify the sse.ts file has push dispatch for all four event types. Verify standalone.ts calls initPush.
  </verify>
  <done>
Server mounts push routes at /api/push, initializes VAPID keys and subscription store. SSE events trigger push notifications for questions, errors, phase-completed, and build-complete. Question notifications are debounced and grouped.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add foreground notification sound and SSE-triggered browser notifications</name>
  <files>
    autopilot/dashboard/src/hooks/useNotificationSound.ts
    autopilot/dashboard/src/hooks/useSSE.ts
  </files>
  <action>
Create `autopilot/dashboard/src/hooks/useNotificationSound.ts`:
- Export `useNotificationSound()` hook
- Purpose: Play a notification sound when a question-pending SSE event fires AND the dashboard tab is open (per research: browsers don't support custom notification sounds in push, so this is the workaround)
- Implementation:
  - Create an Audio instance lazily: `const audioRef = useRef<HTMLAudioElement | null>(null)`
  - On mount, create: `audioRef.current = new Audio('/notification-sound.mp3')`
  - Export a `playQuestionSound()` function that:
    - Guards: only play if document is visible (`document.visibilityState === 'visible'` or even when hidden -- the point is the tab exists)
    - Resets currentTime to 0 and plays: `audio.currentTime = 0; audio.play().catch(() => {})` (catch because browsers may block autoplay)
  - Return `{ playQuestionSound }`

Update `autopilot/dashboard/src/hooks/useSSE.ts`:
- This is NOT where notification sound is wired -- the sound is wired at the Layout level.
- However, we need to make the SSE events accessible for the notification sound to trigger.
- The simplest approach: add a callback mechanism. But actually the cleanest approach is to wire the sound directly in Layout.tsx where we already have access to the SSE events.

Actually, better approach: The useSSE hook already listens to 'question-pending' events and calls store actions. Add a hook in Layout.tsx that watches the store for question count changes and plays sound when count increases.

Revised approach for `useNotificationSound.ts`:
- Hook takes no arguments
- Uses `useDashboardStore(s => s.questions)` to watch question count
- Maintains a `prevCountRef = useRef(questions.length)`
- `useEffect` on questions change: if `questions.length > prevCountRef.current`, play sound. Update prevCountRef.
- Also import `loadNotificationPreferences` and only play if `prefs.questions === true`
- Audio element created once via useRef

Update `autopilot/dashboard/src/components/Layout.tsx` (referenced file, small change):
- Import and call `useNotificationSound()` alongside `useBadgeCount()` at the component top level (both are effect-only hooks)
- That's all -- the hook handles the rest internally
  </action>
  <verify>
Run `cd autopilot/dashboard && npx tsc --noEmit` -- should compile. Run `cd autopilot/dashboard && npx vite build` -- should build. Run `cd autopilot && npx tsc --noEmit` -- full server build should pass.
  </verify>
  <done>
When a new question arrives via SSE while the dashboard tab is open, a notification sound plays (if the user has question notifications enabled). The foreground sound compensates for browsers not supporting custom push notification sounds. The full end-to-end flow works: SSE event -> server push to Service Worker -> browser notification, AND SSE event -> dashboard sound.
  </done>
</task>

</tasks>

<verification>
1. `cd autopilot && npx tsc --noEmit` compiles without errors
2. `cd autopilot/dashboard && npx vite build` succeeds
3. Push routes mounted at /api/push with subscribe, unsubscribe, and vapid-public-key endpoints
4. SSE events for question-pending, error, phase-completed, build-complete trigger push notifications
5. Question notifications are debounced (500ms) and grouped when multiple arrive simultaneously
6. Foreground notification sound plays on question arrival when tab is open
7. Build-complete notifications include summary stats
8. Error notifications include error message body
</verification>

<success_criteria>
- End-to-end push notification flow works: server event -> SSE -> push dispatch -> Service Worker -> browser notification
- Question grouping: single notification for multiple simultaneous questions
- Sound plays for question notifications when dashboard is open (workaround for browser limitation)
- All four trigger events (questions, errors, phase-completed, build-complete) fire appropriate push notifications
- Title prefix "GSD Autopilot: " on all notifications
- Click actions navigate to correct pages (questions -> /questions, errors -> /phases, completion -> /)
- requireInteraction=true for questions and errors, false for informational
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-add-browser-notifications-to-alert-users-when-needed/06.1-04-SUMMARY.md`
</output>
