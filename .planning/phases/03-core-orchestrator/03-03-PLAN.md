---
phase: 03-core-orchestrator
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - autopilot/src/orchestrator/index.ts
  - autopilot/src/orchestrator/__tests__/orchestrator.test.ts
  - autopilot/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Orchestrator sequences through phases calling discuss > plan > execute > verify for each"
    - "Orchestrator skips already-completed phases and steps on resume"
    - "Orchestrator persists state via StateStore before every ClaudeService call"
    - "Orchestrator retries a failed command once, then escalates with retry/skip/abort"
    - "Orchestrator runs gap detection after verify and re-plans/re-executes gaps up to 3 times"
    - "Orchestrator skips discuss when config.skipDiscuss is true and writes CONTEXT.md directly"
    - "Orchestrator skips verify when config.skipVerify is true"
    - "Orchestrator emits phase:started, phase:completed, step:started, step:completed events"
    - "Orchestrator stops starting new phases when shutdown is requested and persists state before stopping"
    - "Orchestrator logs all steps via AutopilotLogger with phase and step metadata"
  artifacts:
    - path: "autopilot/src/orchestrator/index.ts"
      provides: "Orchestrator class extending EventEmitter"
      exports: ["Orchestrator"]
      min_lines: 150
    - path: "autopilot/src/orchestrator/__tests__/orchestrator.test.ts"
      provides: "Unit tests for Orchestrator with mocked dependencies"
      min_lines: 150
  key_links:
    - from: "autopilot/src/orchestrator/index.ts"
      to: "autopilot/src/claude/index.ts"
      via: "calls ClaudeService.runGsdCommand() for each step"
      pattern: "claudeService\\.runGsdCommand"
    - from: "autopilot/src/orchestrator/index.ts"
      to: "autopilot/src/state/index.ts"
      via: "persists state before and after each step"
      pattern: "stateStore\\.setState"
    - from: "autopilot/src/orchestrator/index.ts"
      to: "autopilot/src/logger/index.ts"
      via: "logs all steps with phase/step metadata"
      pattern: "logger\\.log"
    - from: "autopilot/src/orchestrator/index.ts"
      to: "autopilot/src/orchestrator/discuss-handler.ts"
      via: "calls writeSkipDiscussContext when discuss is skipped"
      pattern: "writeSkipDiscussContext"
    - from: "autopilot/src/orchestrator/index.ts"
      to: "autopilot/src/orchestrator/gap-detector.ts"
      via: "calls checkForGaps after verify step"
      pattern: "checkForGaps"
    - from: "autopilot/src/orchestrator/index.ts"
      to: "autopilot/src/orchestrator/yolo-config.ts"
      via: "calls writeYoloConfig at initialization"
      pattern: "writeYoloConfig"
    - from: "autopilot/src/index.ts"
      to: "autopilot/src/orchestrator/index.ts"
      via: "re-exports Orchestrator class"
      pattern: "export.*Orchestrator.*from.*orchestrator"
---

<objective>
Build the Orchestrator class -- the heart of gsd-autopilot that ties together all Phase 1 and Phase 2 components plus the Plan 01/02 utilities into an autonomous workflow engine.

Purpose: This is the core integration that makes the product work. The Orchestrator sequences GSD slash commands through the full lifecycle (init > discuss > plan > execute > verify per phase), persists state for resume, retries failures, runs gap detection loops, and emits events for progress tracking. It is a custom async loop extending EventEmitter (per architecture decision rejecting XState). Requirements covered: ORCH-01 through ORCH-10, DISC-04 (skip-discuss writes CONTEXT.md directly), CLI-10 (resume), CLI-07 (skip-discuss), CLI-08 (skip-verify). Note: DISC-01-03 (gray area analysis, question batching, response collection) are implemented by the existing GSD `/gsd:discuss-phase` command -- the orchestrator delegates to it via `claudeService.runGsdCommand()`.

Output: Working Orchestrator class, fully tested with mocked dependencies, re-exported from package entry point.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-core-orchestrator/03-RESEARCH.md
@.planning/phases/03-core-orchestrator/03-01-SUMMARY.md
@.planning/phases/03-core-orchestrator/03-02-SUMMARY.md
@autopilot/src/types/state.ts
@autopilot/src/types/config.ts
@autopilot/src/types/notification.ts
@autopilot/src/claude/index.ts
@autopilot/src/claude/types.ts
@autopilot/src/state/index.ts
@autopilot/src/logger/index.ts
@autopilot/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Orchestrator class with phase lifecycle loop</name>
  <files>
    autopilot/src/orchestrator/index.ts
    autopilot/src/index.ts
  </files>
  <action>
Create `src/orchestrator/index.ts` with the Orchestrator class that extends EventEmitter.

**IMPLEMENTATION ORDER:** Build in two passes within this single file to manage complexity:
- **Pass 1 (skeleton):** Constructor, `run()` with phase loop, `runPhase()` with step sequence, `runStep()` with state persistence, `extractPhases()` helper. Get the basic loop compiling first.
- **Pass 2 (behaviors):** `executeWithRetry()` with retry/escalate, `runVerifyWithGapLoop()` with bounded loop, `runDiscuss()`/`runPlan()`/`runExecute()` step implementations, `requestShutdown()` with abort, event emissions. Layer in the behaviors once the skeleton compiles.

**Constructor dependencies (dependency injection via options object):**
```typescript
export interface OrchestratorOptions {
  stateStore: StateStore;
  claudeService: ClaudeService;
  logger: AutopilotLogger;
  config: AutopilotConfig;
  projectDir: string;
}
```

All dependencies are injected -- no instantiation inside the Orchestrator. This makes testing possible with mocks.

**Public API:**

`async run(prdPath: string, phaseRange?: { start: number; end: number }): Promise<void>`:
1. Log start: `logger.log('info', 'orchestrator', 'Starting autopilot run', { prdPath })`
2. Write YOLO config: `await writeYoloConfig(this.projectDir, this.config)` (ORCH-08)
3. Initialize state if fresh (currentPhase === 0):
   - Read ROADMAP.md to extract phase list using extractPhases helper
   - Read the PRD file content from prdPath
   - Run init command: `await this.executeWithRetry('/gsd:new-project --auto', { phase: 0, step: 'init' })`
   - Re-read ROADMAP.md after init to get populated phases
   - Persist phases to state: `stateStore.setState({ phases, status: 'running', currentPhase: phases[0].number })`
4. Phase loop: For each phase in `state.phases`:
   - Skip if `phase.status === 'completed' || phase.status === 'skipped'`
   - Skip if phase.number is outside phaseRange (if specified)
   - Check `this.shutdownRequested` -- if true, break
   - Call `await this.runPhase(phase)`
5. If all phases complete without shutdown: emit 'build:complete', log completion, update state to 'complete' (ORCH-10)

`requestShutdown(): void`:
- Sets `this.shutdownRequested = true` (checked between phases and steps)
- Calls `claudeService.abortCurrent()` to stop any in-progress command
- IMPORTANT: The ShutdownManager's `install(onShutdownRequested)` callback is synchronous, so `requestShutdown()` sets the flag and fires abort but does NOT await it. The abort signal propagates to the running `runGsdCommand()` which rejects, causing `runStep` to catch the error and check `shutdownRequested`. When `shutdownRequested` is true after a failed step, `runStep` persists state and returns cleanly instead of escalating the error. This ensures the orchestrator completes its current step's state persistence before `ShutdownManager` runs its own cleanup handlers (logger flush, state persist).

**Private methods:**

`async runPhase(phase: PhaseState): Promise<void>`:
1. Emit 'phase:started' event with phase info (ORCH-09)
2. Update state: `{ currentPhase: phase.number, status: 'running' }`
3. Step sequence with resume support -- check each step individually (Pitfall 2 from research):
   - If `phase.steps.discuss !== 'done'`: run discuss step
   - If `phase.steps.plan !== 'done'`: run plan step
   - If `phase.steps.execute !== 'done'`: run execute step
   - If `phase.steps.verify !== 'done' && !config.skipVerify`: run verify with gap loop
4. Mark phase complete: update phase.status to 'completed', phase.completedAt, persist state
5. Emit 'phase:completed' event (ORCH-09)

`async runStep(phase: PhaseState, stepName: string, fn: () => Promise<void>): Promise<void>`:
1. Check `this.shutdownRequested` -- if true, persist current state before returning (`await stateStore.setState({ status: 'idle' })`) so resume can pick up cleanly, then return
2. Emit 'step:started' event
3. Update state: `currentStep` to stepName, update `phase.steps[stepName]` to stepName (in-progress)
4. Persist state BEFORE calling fn (Pitfall 1 from research -- always persist before awaited operation)
5. Call `await fn()`
6. If `this.shutdownRequested` after fn completes (shutdown was requested during step execution): persist state with current progress (`await stateStore.setState({ status: 'idle' })`), then return without continuing to next step
7. Update `phase.steps[stepName]` to 'done', persist state
8. Emit 'step:completed' event
9. Log via `logger.log('info', 'orchestrator', `Step ${stepName} completed for phase ${phase.number}`)`

`async runDiscuss(phase: PhaseState): Promise<void>`:
- If `config.skipDiscuss`: call `writeSkipDiscussContext(projectDir, { number: phase.number, name: phase.name })` (DISC-04)
- Otherwise: call `executeWithRetry('/gsd:discuss-phase ${phase.number}', ...)` -- DISC-01 (gray area analysis), DISC-02 (question batching), and DISC-03 (response collection via web UI) are implemented by the GSD `/gsd:discuss-phase` command itself. The orchestrator's responsibility is to invoke the command and pass through the phase number; the GSD command handles all discuss logic internally. This is an integration contract: the command is expected to exist in the user's GSD installation and produce a `{padded}-CONTEXT.md` file in the phase directory.

`async runPlan(phase: PhaseState): Promise<void>`:
- Call `executeWithRetry('/gsd:plan-phase ${phase.number}', ...)`

`async runExecute(phase: PhaseState): Promise<void>`:
- Call `executeWithRetry('/gsd:execute-phase ${phase.number}', ...)`

`async runVerifyWithGapLoop(phase: PhaseState): Promise<void>` (ORCH-05):
- Bounded loop: `for (let iteration = 0; iteration < 3; iteration++)`
- Run verify: `executeWithRetry('/gsd:verify-work ${phase.number}', ...)`
- Check for gaps: `await checkForGaps(this.projectDir, phase.number)`
- If no gaps: return (passed)
- If gaps found: re-plan with `--gaps` flag, re-execute with `--gaps-only`, update `phase.gapIterations`, persist
- After 3 iterations: log warning, emit 'gap:escalated' event, continue (don't block entire build)

`async executeWithRetry(prompt: string, meta: { phase: number; step: string }): Promise<CommandResult>` (ORCH-03, ORCH-04):
1. Log the command being run (ORCH-07)
2. First attempt: `await claudeService.runGsdCommand(prompt, { cwd: projectDir, phase: meta.phase, step: meta.step })`
3. If success: return result
4. If `this.shutdownRequested`: do NOT retry -- throw a `ShutdownError` (or return a failure result) so `runStep` can detect shutdown and persist state cleanly
5. Log retry: `logger.log('warn', 'orchestrator', 'Command failed, retrying once', ...)`
6. Second attempt: same call
7. If success: return result
8. If `this.shutdownRequested`: do NOT escalate -- throw `ShutdownError` so `runStep` can persist state
9. Escalate: emit 'error:escalation' event with error details and retry/skip/abort options (ORCH-04)
10. For Phase 3 (no web UI yet): log the escalation to console and default to 'abort' behavior (throw error). The web UI response mechanism is Phase 4. For now, the orchestrator emits the event and throws -- callers can listen and decide.
11. Record error in state.errorHistory (ORCH-06)

**Helper: extractPhases(projectDir):**
- Read ROADMAP.md from `join(projectDir, '.planning', 'ROADMAP.md')`
- Parse phase entries with regex: `/^- \[([ x])\] \*\*Phase (\d+): (.+?)\*\*/gm`
- Return array of `{ number, name, completed }` objects
- Convert to PhaseState objects with default step states

**Update `src/index.ts`:**
- Add `export { Orchestrator } from './orchestrator/index.js';`
- Add `export { ShutdownManager } from './orchestrator/shutdown.js';`
- Add `export { writeYoloConfig } from './orchestrator/yolo-config.js';`
- Add `export { generateSkipDiscussContext, writeSkipDiscussContext } from './orchestrator/discuss-handler.js';`
- Add `export { checkForGaps, parsePhaseRange } from './orchestrator/gap-detector.js';`

CRITICAL: Always `await stateStore.setState(...)` BEFORE any `await claudeService.runGsdCommand(...)` call (Pitfall 1).
CRITICAL: Check individual `phase.steps.*` values, not just `phase.status`, for resume correctness (Pitfall 2).
CRITICAL: Use template literals for GSD command prompts (e.g., `/gsd:plan-phase ${phase.number}`).
CRITICAL: All imports use .js extensions for ESM.
  </action>
  <verify>
Run `cd autopilot && npm run typecheck` -- must pass with zero errors.
Run `cd autopilot && npm run build` -- must compile successfully.
  </verify>
  <done>
Orchestrator class compiles, integrates StateStore + ClaudeService + AutopilotLogger + utility modules, exposes run() as the main entry point, and is re-exported from the package entry point.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Orchestrator unit tests with mocked dependencies</name>
  <files>
    autopilot/src/orchestrator/__tests__/orchestrator.test.ts
  </files>
  <action>
Create `src/orchestrator/__tests__/orchestrator.test.ts` that tests the Orchestrator with fully mocked dependencies. No real ClaudeService calls, no real state files, no real filesystem (except for ROADMAP.md parsing tests which can use temp dirs).

**Mock strategy:**
- Mock StateStore: create a minimal object with `getState()` returning test state, `setState()` recording calls
- Mock ClaudeService: create a mock with `runGsdCommand()` returning configurable CommandResults
- Mock AutopilotLogger: create a mock with `log()` recording calls, `createPhaseLogger()` returning a no-op logger, `flush()` resolving immediately
- Mock writeYoloConfig: vi.mock the module
- Mock writeSkipDiscussContext: vi.mock the module
- Mock checkForGaps: vi.mock the module

**Test setup:**
```typescript
function createMockDeps(overrides?: Partial<OrchestratorOptions>): OrchestratorOptions {
  return {
    stateStore: { getState: vi.fn(), setState: vi.fn().mockResolvedValue(undefined) },
    claudeService: { runGsdCommand: vi.fn().mockResolvedValue({ success: true, ... }), ... },
    logger: { log: vi.fn(), createPhaseLogger: vi.fn(), flush: vi.fn() },
    config: { skipDiscuss: false, skipVerify: false, depth: 'standard', model: 'balanced', ... },
    projectDir: '/test/project',
    ...overrides,
  };
}
```

**Test cases:**

1. **Orchestrator sequences through all steps for a single phase:**
   - State with one phase (steps all idle)
   - Mock runGsdCommand to return success for all calls
   - Mock ROADMAP.md reading (if needed for init)
   - Assert runGsdCommand called with: discuss, plan, execute, verify commands in order
   - Assert state updated after each step

2. **Orchestrator skips completed steps on resume:**
   - State with one phase where discuss='done' and plan='done'
   - Assert runGsdCommand NOT called for discuss or plan
   - Assert runGsdCommand called for execute and verify

3. **Orchestrator skips completed phases:**
   - State with two phases: first completed, second pending
   - Assert only second phase steps are executed

4. **Orchestrator persists state before each ClaudeService call:**
   - Track setState call order relative to runGsdCommand calls
   - Assert setState called BEFORE each runGsdCommand

5. **Orchestrator retries once on failure, then escalates:**
   - Mock runGsdCommand to return { success: false } twice
   - Assert runGsdCommand called exactly 2 times for that step
   - Assert error event emitted or error thrown
   - Assert error recorded in state.errorHistory

6. **Orchestrator retries once and succeeds on second attempt:**
   - Mock runGsdCommand to fail first, succeed second
   - Assert orchestrator continues to next step

7. **Orchestrator skips discuss when config.skipDiscuss is true:**
   - Set config.skipDiscuss = true
   - Assert writeSkipDiscussContext called
   - Assert runGsdCommand NOT called for discuss step

8. **Orchestrator skips verify when config.skipVerify is true:**
   - Set config.skipVerify = true
   - Assert runGsdCommand NOT called for verify step

9. **Orchestrator runs gap detection loop after verify:**
   - Mock checkForGaps to return true once, then false
   - Assert re-plan and re-execute commands called
   - Assert gap iteration count incremented in state

10. **Orchestrator caps gap detection at 3 iterations:**
    - Mock checkForGaps to always return true
    - Assert exactly 3 verify iterations
    - Assert gap:escalated event emitted

11. **Orchestrator stops on shutdown request and persists state:**
    - Start orchestrator, call requestShutdown() after first phase
    - Assert second phase NOT started
    - Assert stateStore.setState called with `{ status: 'idle' }` before stopping (state persisted for clean resume)

12. **Orchestrator emits phase:started and phase:completed events:**
    - Listen for events, run single phase
    - Assert both events emitted with correct phase info

13. **Orchestrator writes YOLO config at startup:**
    - Assert writeYoloConfig called with projectDir and config

14. **Orchestrator respects phaseRange filter:**
    - State with phases 1-5, phaseRange { start: 2, end: 3 }
    - Assert only phases 2 and 3 are executed

15. **Orchestrator does not retry on shutdown-aborted command:**
    - Mock runGsdCommand to reject (simulating abort), set shutdownRequested = true
    - Assert runGsdCommand called only once (no retry)
    - Assert state persisted before returning

Use `vi.fn()` for all mocks. Use `beforeEach` to create fresh mocks and Orchestrator. Use `afterEach` to clear mocks.

IMPORTANT: The test file will need to mock the filesystem modules used by extractPhases (ROADMAP.md reading). Either mock `node:fs/promises` readFile, or make extractPhases accept a roadmap content string parameter for testability. Prefer the latter -- make extractPhases a pure function that takes content string, export it, and test it directly.
  </action>
  <verify>
Run `cd autopilot && npx vitest run src/orchestrator/__tests__/orchestrator.test.ts` -- all tests must pass.
Run `cd autopilot && npm test` -- full suite must pass (no regressions).
  </verify>
  <done>
Orchestrator is fully tested with 15 test cases covering: step sequencing, resume, state persistence ordering, retry/escalate, skip-discuss, skip-verify, gap detection, gap cap, shutdown with state persistence, shutdown abort (no retry), events, YOLO config, and phase range filtering. All tests pass alongside the full suite.
  </done>
</task>

</tasks>

<verification>
- `npm run typecheck` passes in autopilot/ directory
- `npm run build` succeeds in autopilot/ directory
- `npm test` runs all tests (existing + orchestrator tests) with zero failures
- Orchestrator is importable from `@gsd/autopilot` package entry point
- State is persisted before every ClaudeService call (test confirms ordering)
- Resume correctly skips completed steps (test confirms)
- Gap detection is bounded to 3 iterations (test confirms)
</verification>

<success_criteria>
- Orchestrator.run() sequences phases through discuss > plan > execute > verify
- Resume skips completed phases AND completed steps within in-progress phases
- Retry-once-then-escalate pattern works for failed ClaudeService calls
- Gap detection loop runs up to 3 iterations before escalating
- Skip-discuss writes CONTEXT.md directly without ClaudeService
- Skip-verify omits the verify step entirely
- Shutdown flag prevents new phases/steps from starting, persists state before stopping, and skips retry on aborted commands
- All 15 tests pass
- Full test suite passes with no regressions
- Orchestrator exported from package entry point
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-orchestrator/03-03-SUMMARY.md`
</output>
