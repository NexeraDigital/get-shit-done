---
phase: 03-core-orchestrator
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - autopilot/src/orchestrator/shutdown.ts
  - autopilot/src/orchestrator/yolo-config.ts
  - autopilot/src/orchestrator/__tests__/shutdown.test.ts
  - autopilot/src/orchestrator/__tests__/yolo-config.test.ts
autonomous: true

must_haves:
  truths:
    - "ShutdownManager traps SIGINT and calls registered cleanup handlers in reverse registration order"
    - "ShutdownManager prevents double-shutdown via a boolean guard"
    - "ShutdownManager signals the orchestrator to stop via callback before running cleanup"
    - "writeYoloConfig produces a valid .planning/config.json with mode, depth, model_profile, and workflow gates"
    - "writeYoloConfig preserves existing user settings (branching_strategy, git preferences) when merging"
    - "writeYoloConfig respects skipVerify flag by setting workflow.verifier to false"
  artifacts:
    - path: "autopilot/src/orchestrator/shutdown.ts"
      provides: "ShutdownManager class for graceful Ctrl+C handling"
      exports: ["ShutdownManager"]
      min_lines: 30
    - path: "autopilot/src/orchestrator/yolo-config.ts"
      provides: "writeYoloConfig function for autonomous GSD execution config"
      exports: ["writeYoloConfig"]
      min_lines: 25
    - path: "autopilot/src/orchestrator/__tests__/shutdown.test.ts"
      provides: "TDD tests for ShutdownManager"
      min_lines: 40
    - path: "autopilot/src/orchestrator/__tests__/yolo-config.test.ts"
      provides: "TDD tests for writeYoloConfig"
      min_lines: 50
  key_links:
    - from: "autopilot/src/orchestrator/shutdown.ts"
      to: "node:process"
      via: "SIGINT/SIGTERM signal handlers"
      pattern: "process\\.on\\('SIG"
    - from: "autopilot/src/orchestrator/yolo-config.ts"
      to: "node:fs/promises"
      via: "reads existing config, writes merged config"
      pattern: "import.*from.*node:fs/promises"
---

<objective>
Build the ShutdownManager and YOLO config writer using TDD -- two standalone utilities the orchestrator needs.

Purpose: ShutdownManager enables CLI-14 (graceful Ctrl+C shutdown with state persistence). The YOLO config writer enables ORCH-08 (generating .planning/config.json so GSD commands run non-interactively). Both are pure utility modules with no dependency on the Orchestrator class, so they can be built and tested independently in Wave 1.

Output: Two fully tested utility modules ready for integration into the Orchestrator in Plan 03.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-core-orchestrator/03-RESEARCH.md
@autopilot/src/types/config.ts
</context>

<feature>
  <name>Feature 1: ShutdownManager</name>
  <files>autopilot/src/orchestrator/shutdown.ts, autopilot/src/orchestrator/__tests__/shutdown.test.ts</files>
  <behavior>
    ShutdownManager coordinates graceful process shutdown by trapping signals, invoking a stop callback, and running registered cleanup handlers in LIFO order.

    Test cases (input -> expected output):

    1. register(handler) adds handler to internal list -> calling cleanup runs it
    2. install(onShutdownRequested) sets up SIGINT listener -> emitting SIGINT calls onShutdownRequested callback
    3. Cleanup handlers run in reverse registration order (LIFO) -> handler registered last runs first
    4. Handlers that throw are caught and do not prevent remaining handlers from running (best-effort cleanup)
    5. Double-signal protection: second SIGINT does not re-run cleanup handlers (shuttingDown guard)
    6. isShuttingDown getter returns true after shutdown initiated, false before
    7. uninstall() removes signal listeners (cleanup for tests)

    Note: Tests cannot actually kill the process. Instead, test by:
    - Capturing signal listeners registered with process.on and invoking them directly
    - Or using a testable abstraction that accepts a signal emitter
  </behavior>
  <implementation>
    Create `src/orchestrator/shutdown.ts`:

    ```typescript
    export class ShutdownManager {
      private handlers: Array<() => Promise<void>> = [];
      private _shuttingDown = false;
      private signalHandler: (() => void) | null = null;

      register(handler: () => Promise<void>): void
      install(onShutdownRequested: () => void): void
      uninstall(): void
      get isShuttingDown(): boolean
    }
    ```

    - `register()` pushes handler to `this.handlers` array
    - `install()` creates a bound signal handler that:
      1. Checks `this._shuttingDown` -- if already true, returns immediately (double-shutdown guard)
      2. Sets `this._shuttingDown = true`
      3. Calls `onShutdownRequested()` to signal orchestrator to stop after current step
      4. Runs handlers in reverse order with try/catch for each (best-effort)
      5. Calls `process.exit(0)` after all handlers complete
    - Registers the signal handler for both 'SIGINT' and 'SIGTERM' via `process.on()`
    - `uninstall()` removes the listeners (for test cleanup)

    CRITICAL: Do NOT use `process.exit()` in tests. The signal handler function should be extractable/mockable for testing. Consider making the exit function injectable (default: process.exit) or test by verifying handler execution rather than exit.
  </implementation>
</feature>

<feature>
  <name>Feature 2: YOLO Config Writer</name>
  <files>autopilot/src/orchestrator/yolo-config.ts, autopilot/src/orchestrator/__tests__/yolo-config.test.ts</files>
  <behavior>
    writeYoloConfig reads existing .planning/config.json (if any), merges YOLO-specific settings while preserving user settings, and writes back atomically.

    Test cases (input -> expected output):

    1. writeYoloConfig with no existing config -> writes config with model_profile, commit_docs, research, plan_checker, verifier, parallelization
    2. writeYoloConfig with skipVerify=true -> workflow.verifier is false in output
    3. writeYoloConfig with skipVerify=false -> workflow.verifier is true in output
    4. writeYoloConfig with existing config containing branching_strategy -> preserves branching_strategy and git settings in output
    5. writeYoloConfig with existing config containing commit_docs=false -> preserves commit_docs=false (does not override user preference)
    6. writeYoloConfig with depth="comprehensive" and model="quality" -> writes depth and model_profile correctly
    7. Output file is valid JSON with 2-space indentation and trailing newline
    8. Creates .planning/ directory if it does not exist (mkdir recursive)

    The GSD config.json format (from `gsd-tools.js state load` output):
    ```json
    {
      "model_profile": "balanced",
      "commit_docs": true,
      "search_gitignored": false,
      "branching_strategy": "none",
      "phase_branch_template": "gsd/phase-{phase}-{slug}",
      "milestone_branch_template": "gsd/{milestone}-{slug}",
      "research": true,
      "plan_checker": true,
      "verifier": true,
      "parallelization": true
    }
    ```
  </behavior>
  <implementation>
    Create `src/orchestrator/yolo-config.ts`:

    ```typescript
    import { readFile, writeFile, mkdir } from 'node:fs/promises';
    import { join, dirname } from 'node:path';
    import type { AutopilotConfig } from '../types/index.js';

    export async function writeYoloConfig(
      projectDir: string,
      config: Pick<AutopilotConfig, 'depth' | 'model' | 'skipVerify'>,
    ): Promise<void>
    ```

    Implementation:
    1. Build configPath = `join(projectDir, '.planning', 'config.json')`
    2. Ensure directory exists: `await mkdir(dirname(configPath), { recursive: true })`
    3. Try to read existing config: `readFile(configPath, 'utf-8')` + `JSON.parse()`. On ENOENT, use empty object `{}`. On invalid JSON, use empty object (don't crash -- the autopilot config takes priority).
    4. Build YOLO overrides object:
       ```typescript
       const yoloSettings = {
         model_profile: config.model,
         research: true,
         plan_checker: true,
         verifier: !config.skipVerify,
         parallelization: true,
       };
       ```
    5. Merge: `const merged = { ...existing, ...yoloSettings }` -- existing user settings like `branching_strategy`, `commit_docs`, `search_gitignored` are preserved because they are in `existing` and NOT in `yoloSettings`.
    6. Write: `await writeFile(configPath, JSON.stringify(merged, null, 2) + '\n')`

    CRITICAL: Do NOT override `commit_docs`, `branching_strategy`, or git template settings -- these are user preferences that must be preserved (Pitfall 4 from research).
    CRITICAL: Use `node:fs/promises` writeFile (not write-file-atomic) since this is a one-time write at startup, not crash-critical mid-operation state.
  </implementation>
</feature>

<verification>
1. `cd autopilot && npx vitest run src/orchestrator/__tests__/shutdown.test.ts` -- all tests pass
2. `cd autopilot && npx vitest run src/orchestrator/__tests__/yolo-config.test.ts` -- all tests pass
3. `npm run build` -- compiles without errors
4. `npm run typecheck` -- no type errors
5. Verify ShutdownManager has LIFO handler ordering
6. Verify writeYoloConfig preserves existing config keys not in YOLO overrides
</verification>

<success_criteria>
- ShutdownManager traps SIGINT, runs cleanup LIFO, prevents double-shutdown
- writeYoloConfig merges YOLO settings while preserving user branching_strategy/commit_docs
- All TDD tests pass (7+ shutdown tests, 8+ yolo-config tests)
- npm run build succeeds
- Both modules are pure utilities with no Orchestrator dependency
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-orchestrator/03-01-SUMMARY.md`
</output>
