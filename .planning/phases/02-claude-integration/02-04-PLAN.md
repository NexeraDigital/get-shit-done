---
phase: 02-claude-integration
plan: 04
type: execute
wave: 3
depends_on: ["02-01", "02-02", "02-03"]
files_modified:
  - autopilot/src/claude/index.ts
  - autopilot/src/claude/__tests__/claude-service.test.ts
  - autopilot/src/index.ts
autonomous: true

must_haves:
  truths:
    - "ClaudeService.runGsdCommand(prompt) calls the Agent SDK query() with correct options and returns a CommandResult"
    - "The canUseTool callback routes AskUserQuestion to the QuestionHandler and allows all other tools"
    - "Command execution aborts after the configured timeout and returns a CommandResult with success=false"
    - "ClaudeService prevents concurrent command execution with a guard"
    - "ClaudeService.submitAnswer delegates to QuestionHandler and resolves the blocked query"
    - "ClaudeService exposes question lifecycle events from QuestionHandler"
    - "ClaudeService is importable from the package entry point"
  artifacts:
    - path: "autopilot/src/claude/index.ts"
      provides: "ClaudeService facade class"
      exports: ["ClaudeService"]
      min_lines: 80
    - path: "autopilot/src/claude/__tests__/claude-service.test.ts"
      provides: "Unit tests for ClaudeService with mocked SDK"
      min_lines: 80
  key_links:
    - from: "autopilot/src/claude/index.ts"
      to: "@anthropic-ai/claude-agent-sdk"
      via: "imports query function"
      pattern: "import.*query.*from.*claude-agent-sdk"
    - from: "autopilot/src/claude/index.ts"
      to: "autopilot/src/claude/question-handler.ts"
      via: "creates QuestionHandler instance, delegates submitAnswer"
      pattern: "QuestionHandler"
    - from: "autopilot/src/claude/index.ts"
      to: "autopilot/src/claude/result-parser.ts"
      via: "calls parseResult on SDK result messages"
      pattern: "parseResult"
    - from: "autopilot/src/claude/index.ts"
      to: "autopilot/src/claude/timeout.ts"
      via: "calls createTimeout for AbortController"
      pattern: "createTimeout"
    - from: "autopilot/src/index.ts"
      to: "autopilot/src/claude/index.ts"
      via: "re-exports ClaudeService"
      pattern: "export.*ClaudeService.*from.*claude"
---

<objective>
Build the ClaudeService facade that wires together the timeout utility, question handler, and result parser to provide the clean `runGsdCommand(prompt): Promise<CommandResult>` interface the orchestrator will call.

Purpose: This is the single public API for all Claude interaction. The orchestrator calls `runGsdCommand()` without knowing about the Agent SDK, message streams, tool callbacks, or abort controllers. ClaudeService encapsulates all SDK complexity behind one method. This plan integrates the three modules built in Plans 01-03 into a cohesive facade with unit tests using a mocked SDK.

Output: Working ClaudeService class, fully tested with mocked SDK, re-exported from package entry point.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-claude-integration/02-RESEARCH.md
@.planning/phases/02-claude-integration/02-01-SUMMARY.md
@.planning/phases/02-claude-integration/02-02-SUMMARY.md
@.planning/phases/02-claude-integration/02-03-SUMMARY.md
@autopilot/src/claude/types.ts
@autopilot/src/claude/timeout.ts
@autopilot/src/claude/result-parser.ts
@autopilot/src/claude/question-handler.ts
@autopilot/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ClaudeService facade class</name>
  <files>
    autopilot/src/claude/index.ts
    autopilot/src/index.ts
  </files>
  <action>
1. Create `src/claude/index.ts` with the ClaudeService class:

   ```typescript
   import './polyfills.js';
   import { EventEmitter } from 'node:events';
   import { query } from '@anthropic-ai/claude-agent-sdk';
   import type { CanUseTool } from '@anthropic-ai/claude-agent-sdk';
   import { createTimeout } from './timeout.js';
   import { parseResult } from './result-parser.js';
   import { QuestionHandler } from './question-handler.js';
   import type { CommandResult, RunCommandOptions } from './types.js';
   ```

   Class structure:
   - Extends `EventEmitter`
   - Constructor takes `options?: { defaultTimeoutMs?: number; defaultCwd?: string }`
   - Private fields: `questionHandler: QuestionHandler`, `running: boolean`, `currentAbort: AbortController | null`
   - Forward QuestionHandler events: In constructor, listen to questionHandler's 'question:pending' and 'question:answered' events and re-emit them on ClaudeService.

   **`runGsdCommand(prompt: string, options?: RunCommandOptions): Promise<CommandResult>`**:
   - Guard: If `this.running` is true, throw Error('A command is already running. ClaudeService does not support concurrent execution.')
   - Set `this.running = true`
   - Create timeout via `createTimeout(options?.timeoutMs ?? this.defaultTimeoutMs)`
   - Store `this.currentAbort = controller`
   - Record `startTimeMs = Date.now()`
   - Track `sessionId = ''`
   - In try block: iterate over `query()` async generator with these options:
     ```typescript
     {
       prompt,
       options: {
         cwd: options?.cwd ?? this.defaultCwd ?? process.cwd(),
         systemPrompt: { type: 'preset', preset: 'claude_code' },
         settingSources: ['project'],
         permissionMode: 'bypassPermissions',
         allowDangerouslySkipPermissions: true,
         allowedTools: [
           'Read', 'Write', 'Edit', 'Bash', 'Glob', 'Grep',
           'WebFetch', 'WebSearch', 'Task', 'AskUserQuestion',
         ],
         abortController: controller,
         canUseTool: this.createCanUseTool(),
       },
     }
     ```
   - For each message:
     - If `message.type === 'system' && message.subtype === 'init'`: capture `sessionId = message.session_id`
     - If `message.type === 'result'`: return `parseResult(message, sessionId, startTimeMs)`
   - In catch block: Check for AbortError (`err instanceof Error && err.name === 'AbortError'`). Return timeout CommandResult: `{ success: false, error: 'Command timed out after ${timeoutMs}ms', sessionId, durationMs: Date.now() - startTimeMs, costUsd: 0, numTurns: 0 }`
   - In finally block: Call `cleanup()`, set `this.running = false`, set `this.currentAbort = null`
   - If the for-await completes without a 'result' message, return an error CommandResult: `{ success: false, error: 'No result message received from SDK', sessionId, durationMs: Date.now() - startTimeMs, costUsd: 0, numTurns: 0 }`

   **`createCanUseTool(): CanUseTool`** (private):
   - Returns an async function that checks `toolName === 'AskUserQuestion'`
   - If yes: delegates to `this.questionHandler.handleQuestion(input)`
   - Otherwise: returns `{ behavior: 'allow', updatedInput: input }`

   **`submitAnswer(questionId: string, answers: Record<string, string>): boolean`**:
   - Delegates to `this.questionHandler.submitAnswer(questionId, answers)`

   **`getPendingQuestions()`**: Delegates to `this.questionHandler.getPending()`

   **`abortCurrent(): void`**:
   - If `this.currentAbort`: calls `this.currentAbort.abort()`
   - Also calls `this.questionHandler.rejectAll(new Error('Command aborted'))`

   **`get isRunning(): boolean`**: Returns `this.running`

2. Update `src/index.ts` to add:
   ```typescript
   export { ClaudeService } from './claude/index.js';
   ```
   Add this alongside the existing exports. Also re-export QuestionHandler if useful:
   ```typescript
   export { QuestionHandler } from './claude/question-handler.js';
   ```
  </action>
  <verify>
Run `cd autopilot && npm run typecheck` -- must pass with zero errors.
Run `cd autopilot && npm run build` -- must compile successfully.
  </verify>
  <done>
ClaudeService class compiles, wires together timeout + question handler + result parser, exposes runGsdCommand as the single public API, and is re-exported from the package entry point.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ClaudeService unit tests with mocked SDK</name>
  <files>
    autopilot/src/claude/__tests__/claude-service.test.ts
  </files>
  <action>
Create `src/claude/__tests__/claude-service.test.ts` that tests ClaudeService with a mocked `query` function. The SDK's `query()` must be mocked because it spawns real Claude Code processes.

**Mocking strategy:** Use `vi.mock('@anthropic-ai/claude-agent-sdk')` to replace the SDK module. Create a `mockQuery` that returns an async generator yielding configurable message sequences.

Helper to create mock async generator:
```typescript
async function* mockMessageStream(messages: unknown[]) {
  for (const msg of messages) {
    yield msg;
  }
}
```

**Test cases:**

1. **`runGsdCommand returns success CommandResult for successful query`**:
   - Mock query to yield: system init message (session_id: 'test-session'), then result message (subtype: 'success', is_error: false, result: 'Done')
   - Call `service.runGsdCommand('/gsd:plan-phase 2')`
   - Assert result: `{ success: true, result: 'Done', sessionId: 'test-session', ... }`

2. **`runGsdCommand returns failure CommandResult for error result`**:
   - Mock query to yield: system init, then result message (subtype: 'error_max_turns', errors: ['Too many turns'])
   - Assert result: `{ success: false, error: expect.stringContaining('Too many turns'), ... }`

3. **`runGsdCommand passes correct options to query`**:
   - Mock query, capture the options object passed to it
   - Call `service.runGsdCommand('/gsd:test', { cwd: '/test', timeoutMs: 5000 })`
   - Assert options include: systemPrompt preset 'claude_code', settingSources ['project'], permissionMode 'bypassPermissions', cwd '/test', abortController is AbortController instance, canUseTool is function

4. **`runGsdCommand handles timeout via AbortError`**:
   - Mock query to yield an async generator that hangs (never yields a result -- use a promise that never resolves or yields init then waits)
   - Call `service.runGsdCommand('/gsd:slow', { timeoutMs: 50 })`
   - Assert result: `{ success: false, error: expect.stringContaining('timed out'), ... }`
   - Use a reasonable timeout for the test assertion too (e.g., vitest timeout 5000ms)

5. **`runGsdCommand prevents concurrent execution`**:
   - Mock query to return a generator that hangs (yields init then blocks)
   - Start first command (don't await)
   - Immediately call second command
   - Assert second command rejects with 'already running'
   - Clean up by aborting first command

6. **`canUseTool routes AskUserQuestion to question handler`**:
   - Mock query to capture the canUseTool callback from options
   - Set up a listener on service for 'question:pending'
   - Invoke the captured canUseTool callback with ('AskUserQuestion', mockInput)
   - In parallel, wait for 'question:pending' event, then call service.submitAnswer with the received ID
   - Assert canUseTool resolved with { behavior: 'allow', updatedInput: { questions, answers } }

7. **`canUseTool allows non-AskUserQuestion tools`**:
   - Capture canUseTool callback from mocked query options
   - Call it with ('Read', { path: '/test' })
   - Assert result: { behavior: 'allow', updatedInput: { path: '/test' } }

8. **`submitAnswer returns false for unknown question ID`**:
   - Call `service.submitAnswer('nonexistent', {})`
   - Assert returns false

9. **`abortCurrent aborts running command and rejects pending questions`**:
   - Mock query that hangs after init
   - Start command (don't await)
   - Add listener for 'question:pending'
   - Trigger a question via canUseTool
   - Call `service.abortCurrent()`
   - Assert the running command completes with abort error
   - Assert pending question was rejected

10. **`runGsdCommand returns error when no result message received`**:
    - Mock query to yield only system init (no result)
    - Assert result: `{ success: false, error: expect.stringContaining('No result message'), ... }`

Use `vi.mock()` at the top of the test file. Use `beforeEach` to create a fresh ClaudeService instance and reset mocks. Use `afterEach` to restore mocks.

Important: Some tests (timeout, concurrent) involve async timing. Use `vi.useFakeTimers()` only if needed; otherwise use small real timeouts (50-100ms) to keep tests fast.
  </action>
  <verify>
Run `cd autopilot && npx vitest run src/claude/__tests__/claude-service.test.ts` -- all tests must pass.
Run `cd autopilot && npm test` -- full suite must pass (no regressions).
  </verify>
  <done>
ClaudeService is fully tested with 10 test cases covering: success/failure results, query options wiring, timeout handling, concurrent execution guard, AskUserQuestion routing, tool allow-through, unknown answer ID, abort, and missing result message. All tests pass alongside the full suite.
  </done>
</task>

</tasks>

<verification>
- `npm run typecheck` passes in autopilot/ directory
- `npm run build` succeeds in autopilot/ directory
- `npm test` runs all tests (existing + all new Claude tests) with zero failures
- ClaudeService is importable from `@gsd/autopilot` package entry point
- runGsdCommand passes correct SDK options (systemPrompt, settingSources, permissionMode, canUseTool, abortController)
- Question lifecycle events propagate from QuestionHandler through ClaudeService
</verification>

<success_criteria>
- ClaudeService.runGsdCommand() wraps SDK query() with correct configuration
- canUseTool callback intercepts AskUserQuestion and delegates to QuestionHandler
- Timeout wrapper aborts after configured duration and returns clean error
- Concurrent execution guard prevents overlapping commands
- All 10 ClaudeService tests pass
- Full test suite passes with no regressions
- ClaudeService exported from package entry point
</success_criteria>

<output>
After completion, create `.planning/phases/02-claude-integration/02-04-SUMMARY.md`
</output>
