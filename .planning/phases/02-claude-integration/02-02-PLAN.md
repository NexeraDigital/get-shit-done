---
phase: 02-claude-integration
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - autopilot/src/claude/result-parser.ts
  - autopilot/src/claude/__tests__/result-parser.test.ts
autonomous: true

must_haves:
  truths:
    - "A successful SDKResultMessage is parsed into a CommandResult with success=true and the result text"
    - "An error SDKResultMessage is parsed into a CommandResult with success=false and a descriptive error string"
    - "A result with is_error=true is parsed as failure even when subtype is 'success'"
    - "Cost, duration, session ID, and turn count are captured from the SDK message"
  artifacts:
    - path: "autopilot/src/claude/result-parser.ts"
      provides: "parseResult function converting SDKResultMessage to CommandResult"
      exports: ["parseResult"]
    - path: "autopilot/src/claude/__tests__/result-parser.test.ts"
      provides: "TDD tests for result parsing"
      min_lines: 60
  key_links:
    - from: "autopilot/src/claude/result-parser.ts"
      to: "autopilot/src/claude/types.ts"
      via: "imports CommandResult type"
      pattern: "import.*CommandResult.*from.*types"
---

<objective>
TDD-build a result parser that converts Claude Agent SDK result messages into structured CommandResult objects.

Purpose: The result parser is the critical translation layer between raw SDK output and the clean interface the orchestrator consumes. TDD ensures every SDK result subtype (success, error_max_turns, error_during_execution, error_max_budget_usd) is handled correctly with no gaps. Getting this wrong means the orchestrator cannot distinguish success from failure.

Output: Working, tested parseResult function with full coverage of SDK result subtypes.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-claude-integration/02-RESEARCH.md
@autopilot/src/claude/types.ts
</context>

<feature>
  <name>Result Parser</name>
  <files>autopilot/src/claude/result-parser.ts, autopilot/src/claude/__tests__/result-parser.test.ts</files>
  <behavior>
    parseResult converts an SDK result message + session ID + start time into a CommandResult.

    Cases:
    - Success result (subtype: 'success', is_error: false) -> { success: true, result: message.result, sessionId, durationMs, costUsd, numTurns }
    - Success subtype but is_error: true -> { success: false, result: message.result, sessionId, durationMs, costUsd, numTurns }
    - Error result (subtype: 'error_max_turns') -> { success: false, error: "Command failed: error_max_turns", sessionId, durationMs, costUsd, numTurns }
    - Error result (subtype: 'error_during_execution') with errors array -> { success: false, error: joined errors string, sessionId, durationMs, costUsd, numTurns }
    - Error result (subtype: 'error_max_budget_usd') -> { success: false, error: "Command failed: error_max_budget_usd", ... }
    - Error result with empty/missing errors array -> { success: false, error: "Command failed: {subtype}", ... }
    - durationMs is calculated from startTime to now (performance.now() or Date.now())
    - costUsd defaults to 0 if total_cost_usd is undefined
    - numTurns defaults to 0 if num_turns is undefined

    Function signature:
    ```typescript
    export function parseResult(
      message: SDKResultMessage,
      sessionId: string,
      startTimeMs: number,
    ): CommandResult
    ```

    Note: SDKResultMessage type comes from the Agent SDK. For testing, create a factory helper that builds minimal mock objects matching the SDK shape (don't import the actual SDK in tests -- it spawns processes).
  </behavior>
  <implementation>
    Create `src/claude/result-parser.ts` that:
    1. Checks if `message.subtype === 'success' && !message.is_error` for success case
    2. For errors, joins `message.errors` array with '; ' or falls back to `Command failed: ${message.subtype}`
    3. Calculates durationMs as `Date.now() - startTimeMs`
    4. Extracts costUsd from `message.total_cost_usd ?? 0`
    5. Extracts numTurns from `message.num_turns ?? 0`
    6. Returns a CommandResult object

    Use a locally-defined interface for the SDK message shape (duck-typing) rather than importing from the SDK package directly. This avoids the SDK's runtime side effects in tests and keeps the module lightweight.

    ```typescript
    // Local interface matching SDK's SDKResultMessage shape
    export interface SDKResultLike {
      type: 'result';
      subtype: string;
      is_error?: boolean;
      result?: string;
      errors?: string[];
      total_cost_usd?: number;
      num_turns?: number;
      duration_ms?: number;
      session_id?: string;
    }
    ```
  </implementation>
</feature>
