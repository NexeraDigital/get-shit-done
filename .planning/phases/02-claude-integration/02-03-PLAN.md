---
phase: 02-claude-integration
plan: 03
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - autopilot/src/claude/question-handler.ts
  - autopilot/src/claude/__tests__/question-handler.test.ts
autonomous: true

must_haves:
  truths:
    - "When an AskUserQuestion tool call arrives, a deferred Promise is created and the handler blocks until it resolves"
    - "submitAnswer resolves the deferred promise with the provided answers and returns true"
    - "submitAnswer returns false for unknown question IDs"
    - "The handler emits question:pending and question:answered events with QuestionEvent data"
    - "Pending questions can be listed and individual questions can be retrieved by ID"
  artifacts:
    - path: "autopilot/src/claude/question-handler.ts"
      provides: "QuestionHandler class with handleQuestion, submitAnswer, getPending"
      exports: ["QuestionHandler"]
    - path: "autopilot/src/claude/__tests__/question-handler.test.ts"
      provides: "TDD tests for question interception and deferred Promise pattern"
      min_lines: 80
  key_links:
    - from: "autopilot/src/claude/question-handler.ts"
      to: "autopilot/src/claude/polyfills.ts"
      via: "imports polyfill at top for Promise.withResolvers"
      pattern: "import.*polyfills"
    - from: "autopilot/src/claude/question-handler.ts"
      to: "autopilot/src/claude/types.ts"
      via: "imports QuestionEvent type"
      pattern: "import.*QuestionEvent.*from.*types"
    - from: "autopilot/src/claude/question-handler.ts"
      to: "EventEmitter"
      via: "extends EventEmitter for question lifecycle events"
      pattern: "extends EventEmitter"
---

<objective>
TDD-build the question handler that intercepts AskUserQuestion tool calls from the Claude Agent SDK, creates deferred Promises to block execution, and resolves them when human answers arrive.

Purpose: This is the core human-in-the-loop mechanism. When Claude asks a question during a GSD command, the question handler blocks SDK execution (via the canUseTool callback) until the orchestrator provides an answer. The deferred Promise pattern using Promise.withResolvers cleanly separates promise creation (in canUseTool) from resolution (in submitAnswer, called by the web API). TDD ensures the blocking/unblocking lifecycle is correct -- getting this wrong means either the build hangs forever or questions are silently dropped.

Output: Working, tested QuestionHandler class with full lifecycle coverage.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-claude-integration/02-RESEARCH.md
@autopilot/src/claude/types.ts
@autopilot/src/claude/polyfills.ts
</context>

<feature>
  <name>Question Handler</name>
  <files>autopilot/src/claude/question-handler.ts, autopilot/src/claude/__tests__/question-handler.test.ts</files>
  <behavior>
    QuestionHandler extends EventEmitter and manages the deferred-promise lifecycle for AskUserQuestion interception.

    Cases:
    - handleQuestion(input) creates a deferred promise, stores it keyed by generated UUID, emits 'question:pending' event, and returns a Promise that resolves to a PermissionResult-shaped object
    - submitAnswer(questionId, answers) resolves the deferred promise, emits 'question:answered', deletes from pending map, returns true
    - submitAnswer with unknown ID returns false and does not emit
    - getPending() returns array of all pending QuestionEvent objects
    - getPendingById(id) returns a specific pending question or undefined
    - After submitAnswer, the handleQuestion promise resolves with { behavior: 'allow', updatedInput: { questions: originalQuestions, answers } }
    - Multiple concurrent questions can be pending simultaneously (different question IDs)
    - rejectAll(reason) rejects all pending promises (for cleanup on abort/timeout)

    Event signatures:
    - 'question:pending' -> QuestionEvent
    - 'question:answered' -> { id: string, answers: Record<string, string> }

    The PermissionResult return format (from SDK docs):
    ```typescript
    {
      behavior: 'allow',
      updatedInput: {
        questions: input.questions,  // original questions array
        answers: answersRecord,      // Record<string, string> mapping question text to label
      }
    }
    ```

    Note: For testing, do NOT import from the Agent SDK. Use locally-defined interfaces matching the SDK shapes. The polyfill import (`import './polyfills.js'`) must be at the top of question-handler.ts.
  </behavior>
  <implementation>
    Create `src/claude/question-handler.ts` that:
    1. Imports polyfills at the top (`import '../claude/polyfills.js'` or relative path)
    2. Extends EventEmitter from 'node:events'
    3. Has a private `pendingQuestions` Map keyed by question ID storing { resolve, reject, event: QuestionEvent, questions: original input.questions }
    4. `handleQuestion(input)` method:
       - Generates UUID via `crypto.randomUUID()`
       - Creates deferred promise via `Promise.withResolvers<Record<string, string>>()`
       - Stores in pendingQuestions map
       - Constructs QuestionEvent from input + metadata
       - Emits 'question:pending' with the QuestionEvent
       - Awaits the deferred promise
       - Returns PermissionResult-shaped object with { behavior: 'allow', updatedInput: { questions: input.questions, answers } }
    5. `submitAnswer(questionId, answers)` method:
       - Looks up pending question by ID
       - If not found, returns false
       - Calls resolve(answers)
       - Deletes from map
       - Emits 'question:answered' with { id, answers }
       - Returns true
    6. `getPending()` returns Array of QuestionEvent from pending map values
    7. `getPendingById(id)` returns QuestionEvent or undefined
    8. `rejectAll(reason)` iterates pending map, calls reject(reason) on each, clears map

    Use locally-defined input interface:
    ```typescript
    export interface AskUserQuestionInput {
      questions: Array<{
        question: string;
        header: string;
        options: Array<{ label: string; description: string }>;
        multiSelect: boolean;
      }>;
    }

    export interface PermissionResultAllow {
      behavior: 'allow';
      updatedInput: {
        questions: AskUserQuestionInput['questions'];
        answers: Record<string, string>;
      };
    }
    ```
  </implementation>
</feature>
