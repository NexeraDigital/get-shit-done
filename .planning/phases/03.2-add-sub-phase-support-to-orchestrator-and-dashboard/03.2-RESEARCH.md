# Phase 03.2: Fix Phase Extraction and Dashboard Sub-Phase Visibility - Research

**Researched:** 2026-02-23
**Domain:** TypeScript pure function design, markdown parsing, numeric sorting, React Router
**Confidence:** HIGH

## Summary

Phase 03.2 fixes a critical bug in `extractPhasesFromContent` where heading-only phases (03.1, 06.1, 8) are invisible to the orchestrator and dashboard. The root cause is line 55 in `index.ts`: the heading parser runs only `if (phases.length === 0)`, making it a fallback instead of a supplement. The fix requires merging both checklist and heading sources, sorting numerically (1 < 3 < 3.1 < 3.2 < 4), and extending the `RoadmapPhase` type to expose `inserted: boolean` and `dependsOn: string | null` fields extracted from heading sections.

The implementation domain is well-understood: TypeScript interface extension (optional fields with `?`), array sorting with numeric comparators (`(a, b) => a.number - b.number`), regex-based markdown parsing (existing patterns already work), and Vitest testing for pure functions (existing test infrastructure is comprehensive). The dashboard already handles decimal phase display via `padPhaseDisplay()` and React Router accepts decimal path parameters without modification.

**Primary recommendation:** Merge checklist and heading extraction unconditionally, sort by phase number numerically, extend RoadmapPhase with optional fields, and update tests to cover decimal phases and merge behavior.

---

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Constraint:** No changes to core GSD code (`gsd-tools.js`, workflows, or anything in `~/.claude/get-shit-done/`). All changes stay in the autopilot codebase.

**Extraction strategy:**
- Merge both checklist and heading sources — checklist first, then add any heading-only phases (currently the heading parser is gated behind `if (phases.length === 0)` and never runs)
- Always sort extracted phases numerically after merge: 1 < 2 < 3 < 3.1 < 3.2 < 4 < 6 < 6.1 < 7 < 8
- Also extract the `Depends on` field from heading sections — useful for future dependency-aware sequencing
- Detect `(INSERTED)` marker and expose as `inserted: boolean` field on RoadmapPhase
- Silent merge — no warnings when heading-only phases are found. The extraction is the safety net for ROADMAP inconsistency

**Execution ordering:**
- Decimal phases run immediately after their parent: 3 → 3.1 → 3.2 → 4 (not queued to end)
- Inserted phases always run regardless of parent completion status — they are urgent insertions with their own lifecycle

### Claude's Discretion

- Merge priority: checklist is authoritative for completion status where it exists, heading-only phases default to not completed
- Implicit parent dependency (whether 3.1 requires 3 to be complete)
- Sibling decimals (3.1, 3.2) run sequentially by default; parallel execution allowed if marked in roadmap
- Grouping approach (nested under parent vs flat list with visual distinction)
- URL format for phase detail pages (/phases/3.1 vs /phases/3-1)
- Whether to check the Progress table for heading-only phase status, or just default to not completed

### Deferred Ideas (OUT OF SCOPE)

None — discussion stayed within phase scope

</user_constraints>

---

## Standard Stack

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| TypeScript | 5.x | Type system with interface extension | Industry standard for Node.js projects; already in use project-wide |
| Vitest | Latest | Pure function testing framework | Project standard (per existing test files); faster than Jest, native ESM support |
| Node.js | >= 20 | Runtime environment | Per ROADMAP decision from research; Node 18 is EOL |

### Supporting

N/A — No additional libraries needed. Implementation uses only built-in JavaScript array methods and existing TypeScript type system.

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| In-place interface extension | New type with composition | Extension is cleaner for additive changes; composition better for wholesale replacement |
| Array.sort() | Manual sorting algorithm | Built-in sort with numeric comparator is standard, tested, and performant for small arrays |

**Installation:**

No new dependencies required.

---

## Architecture Patterns

### Recommended Project Structure

```
autopilot/src/
├── orchestrator/
│   ├── index.ts              # extractPhasesFromContent lives here
│   └── __tests__/
│       └── orchestrator.test.ts  # Add tests for decimal phase extraction
├── types/
│   └── state.ts              # Extend RoadmapPhase interface
└── dashboard/
    ├── src/
    │   ├── types/index.ts    # Mirror RoadmapPhase changes (dashboard types are duplicated)
    │   └── components/
    │       └── PhaseCard.tsx # Update to show inserted badge if needed
```

### Pattern 1: Pure Function with Multiple Data Sources

**What:** Extract data from two independent sources (checklist regex, heading regex), merge results, then sort.

**When to use:** Whenever parsing unstructured data with multiple representation formats.

**Example:**

```typescript
// Source: Existing codebase pattern (autopilot/src/orchestrator/index.ts)
export function extractPhasesFromContent(content: string): RoadmapPhase[] {
  const phases: RoadmapPhase[] = [];

  // Source 1: Checklist format (authoritative for completion status)
  const checklistPattern = /^- \[([ x])\] \*\*Phase (\d+(?:\.\d+)?): (.+?)\*\*/gm;
  let match;
  while ((match = checklistPattern.exec(content)) !== null) {
    phases.push({
      number: parseFloat(match[2]!),
      name: match[3]!,
      completed: match[1] === 'x',
      inserted: false, // Will be updated if found in heading
      dependsOn: null,  // Will be updated if found in heading
    });
  }

  // Source 2: Heading format (supplements checklist, provides metadata)
  const headingPattern = /^#{1,3} Phase (\d+(?:\.\d+)?): (.+?)(\s+\(INSERTED\))?$/gm;
  while ((match = headingPattern.exec(content)) !== null) {
    const phaseNum = parseFloat(match[1]!);
    const existing = phases.find(p => p.number === phaseNum);

    if (existing) {
      // Merge metadata into existing checklist entry
      if (match[3]) existing.inserted = true;
      // Extract dependsOn from heading content block (next section)
    } else {
      // Heading-only phase (not in checklist)
      phases.push({
        number: phaseNum,
        name: match[2]!.trim(),
        completed: false, // Heading-only phases default to not completed
        inserted: !!match[3],
        dependsOn: null,
      });
    }
  }

  // Sort numerically (critical for decimal phases)
  return phases.sort((a, b) => a.number - b.number);
}
```

### Pattern 2: Optional Interface Fields

**What:** Extend existing interface with new optional fields using `?` syntax.

**When to use:** When adding metadata that isn't always present in all data sources.

**Example:**

```typescript
// Source: TypeScript Handbook - Interfaces
// https://www.typescriptlang.org/docs/handbook/interfaces.html

interface RoadmapPhase {
  number: number;
  name: string;
  completed: boolean;
  inserted?: boolean;      // Optional: only present in heading format
  dependsOn?: string | null; // Optional: extracted from "Depends on:" line
}
```

### Pattern 3: Numeric Sorting for Decimal Numbers

**What:** Use comparison function with subtraction to sort decimal phase numbers correctly.

**When to use:** Whenever sorting numeric values (including decimals) in JavaScript arrays.

**Example:**

```typescript
// Source: MDN Array.prototype.sort()
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort

const phases = [
  { number: 3, name: 'Core' },
  { number: 3.2, name: 'Sub 2' },
  { number: 3.1, name: 'Sub 1' },
  { number: 4, name: 'Next' },
];

// Correct: numeric comparison
phases.sort((a, b) => a.number - b.number);
// Result: 3, 3.1, 3.2, 4

// WRONG: string comparison (default sort behavior)
phases.sort();
// Would give: 3, 3.1, 3.2, 4 (accidentally correct) but fails for 10, 10.1, 2
```

### Pattern 4: Vitest Pure Function Testing

**What:** Test pure functions by calling them with specific inputs and asserting outputs.

**When to use:** For all pure functions (no side effects, deterministic output).

**Example:**

```typescript
// Source: Existing test pattern from autopilot/src/orchestrator/__tests__/gap-detector.test.ts
import { describe, it, expect } from 'vitest';
import { extractPhasesFromContent } from '../index.js';

describe('extractPhasesFromContent', () => {
  it('merges checklist and heading-only phases', () => {
    const content = `
- [x] **Phase 1: Foundation**
- [ ] **Phase 3: Core**

### Phase 2: Missing from Checklist
### Phase 3.1: Sub-phase (INSERTED)
**Depends on:** Phase 3
    `;

    const result = extractPhasesFromContent(content);

    expect(result).toHaveLength(4);
    expect(result.map(p => p.number)).toEqual([1, 2, 3, 3.1]);
    expect(result[1]).toMatchObject({ number: 2, completed: false });
    expect(result[3]).toMatchObject({ number: 3.1, inserted: true, dependsOn: 'Phase 3' });
  });
});
```

### Anti-Patterns to Avoid

- **Mutating input strings:** Regex operations on strings are immutable. Use `exec()` with reset or `/g` flag.
- **String-based sorting for numbers:** Default `sort()` converts to strings ("10" < "2" in Unicode). Always use numeric comparator.
- **Shared regex state:** Global regexes (`/pattern/g`) maintain state via `lastIndex`. Reset between calls or recreate.
- **Optional field access without guards:** Always check `if (phase.inserted)` or use optional chaining `phase.inserted?.` before accessing.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Markdown parsing | Full AST parser with grammar rules | Regex patterns for specific structures | ROADMAP.md has predictable format; regex is sufficient and already proven in codebase |
| Numeric sorting | Custom quicksort/mergesort | `Array.sort((a, b) => a - b)` | Built-in sort is optimized (Timsort in V8), well-tested, and standard |
| Dependency graph resolution | Topological sort algorithm | Simple sequential execution with parent checks | Scope only requires "run 3.1 after 3" logic; full DAG traversal is overkill |

**Key insight:** The phase extraction problem has narrow scope (parse known markdown format, sort numbers). Standard library methods and simple regex patterns handle this cleanly without custom parsing infrastructure.

---

## Common Pitfalls

### Pitfall 1: Regex Global Flag State Pollution

**What goes wrong:** Global regexes (`/pattern/g`) maintain internal `lastIndex` state. Reusing the same regex instance across multiple strings can cause matches to skip or fail unexpectedly.

**Why it happens:** The `/g` flag makes `exec()` remember position between calls for iteration within a single string. If you reuse the regex on a different string, `lastIndex` doesn't reset automatically.

**How to avoid:**
- Create new regex instances for each `extractPhasesFromContent` call (declare inside function), OR
- Explicitly reset `regex.lastIndex = 0` between strings, OR
- Use regex literals (not variables) which are recreated each time

**Warning signs:** Tests pass individually but fail when run together; inconsistent extraction results for identical input.

### Pitfall 2: Assuming Heading Format Completeness

**What goes wrong:** Some phases exist only as headings (03.1, 06.1, 8), some only in checklist, some in both. Code that assumes one source has all phases will miss data.

**Why it happens:** ROADMAP.md allows inserted phases to be documented in headings before being added to the checklist. This is intentional flexibility, not an error.

**How to avoid:**
- Always merge both sources unconditionally (remove `if (phases.length === 0)` gate)
- Make checklist authoritative for `completed` status where present
- Default heading-only phases to `completed: false`

**Warning signs:** Dashboard shows fewer phases than ROADMAP.md contains; decimal phases never appear in orchestrator phase list.

### Pitfall 3: String Sorting for Numeric Phase Numbers

**What goes wrong:** Using default `sort()` on phase numbers treats them as strings: "10" sorts before "2" because "1" < "2" in Unicode.

**Why it happens:** JavaScript arrays convert elements to strings for default sort comparison.

**How to avoid:** Always provide numeric comparator: `phases.sort((a, b) => a.number - b.number)`

**Warning signs:** Phases execute out of order; phase list shows "3, 3.1, 3.2, 4, 10, 10.1, 2" instead of "2, 3, 3.1, 3.2, 4, 10, 10.1".

### Pitfall 4: Dashboard Type Drift

**What goes wrong:** Dashboard types are intentionally duplicated (separate Vite project). Adding fields to `autopilot/src/types/state.ts` without mirroring in `autopilot/dashboard/src/types/index.ts` causes runtime errors or missing data in UI.

**Why it happens:** TypeScript cannot share types across independently-built projects. The dashboard duplicates types to avoid build dependency.

**How to avoid:**
- Update both type files when extending RoadmapPhase
- Add test that compares interface structure (future task)
- Document this requirement in implementation plan

**Warning signs:** Dashboard shows `undefined` for new fields; TypeScript errors in dashboard build but not server build.

### Pitfall 5: React Router Decimal Path Parameters

**What goes wrong:** Developers assume decimal phase numbers (3.1) require special URL encoding or custom routing logic.

**Why it happens:** Decimal points look like file extensions, suggesting routing ambiguity.

**How to avoid:**
- React Router path parameters accept any string, including decimals
- URL `/phases/3.1` works as-is; `useParams()` returns `"3.1"`; `Number("3.1")` parses correctly
- No encoding needed (period is a valid unreserved character per RFC 3986)

**Warning signs:** Overly complex routing logic; attempts to replace `.` with `-` or encode decimals.

---

## Code Examples

Verified patterns from official sources:

### Extracting "Depends on:" from Heading Block

```typescript
// Parse heading block to extract dependsOn metadata
function extractDependsOn(content: string, phaseNumber: number): string | null {
  // Find the heading for this phase
  const headingPattern = new RegExp(
    `^#{1,3} Phase ${phaseNumber}(?:\\.\\d+)?: .+$`,
    'gm'
  );
  const headingMatch = headingPattern.exec(content);
  if (!headingMatch) return null;

  // Extract content block after heading (up to next heading or end)
  const startIndex = headingMatch.index + headingMatch[0].length;
  const nextHeadingPattern = /^#{1,3} Phase \d+/gm;
  nextHeadingPattern.lastIndex = startIndex;
  const nextHeading = nextHeadingPattern.exec(content);
  const endIndex = nextHeading ? nextHeading.index : content.length;
  const block = content.slice(startIndex, endIndex);

  // Look for "**Depends on:** ..." line
  const dependsPattern = /\*\*Depends on:\*\* (.+)/;
  const dependsMatch = block.match(dependsPattern);
  return dependsMatch ? dependsMatch[1].trim() : null;
}
```

### Dashboard Optional Field Rendering

```typescript
// Source: Existing PhaseCard.tsx pattern + optional field access
function PhaseRow({ phase, isCurrent }: { phase: PhaseState; isCurrent: boolean }) {
  return (
    <div>
      <span>{phase.name}</span>
      {phase.inserted && (
        <span className="badge badge-inserted">INSERTED</span>
      )}
    </div>
  );
}
```

### Testing Decimal Phase Sorting

```typescript
// Source: Vitest testing pattern
it('sorts decimal phases numerically', () => {
  const content = `
- [ ] **Phase 4: Server**
- [ ] **Phase 3: Core**
- [ ] **Phase 3.2: Sub Two**
- [ ] **Phase 3.1: Sub One**
  `;

  const result = extractPhasesFromContent(content);

  expect(result.map(p => p.number)).toEqual([3, 3.1, 3.2, 4]);
});
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Heading-only fallback | Merge checklist + headings | Phase 03.2 | All phases visible to orchestrator |
| No metadata extraction | Extract `inserted` and `dependsOn` | Phase 03.2 | Dashboard can show inserted badge; future dependency tracking enabled |
| String-based matching | Regex with decimal support | Already present | Decimal phase numbers work in existing code |

**Deprecated/outdated:**

- N/A — No deprecated patterns. This is a bug fix, not a feature evolution.

---

## Open Questions

1. **Should heading-only phases check Progress table for completion status?**
   - What we know: ROADMAP.md has a Progress table that tracks phase completion manually
   - What's unclear: Whether to parse this table as third source of truth for completion status
   - Recommendation: Start with `completed: false` default for heading-only phases. Progress table parsing is a future enhancement (avoid scope creep).

2. **Should 3.1 implicitly require Phase 3 completion?**
   - What we know: User marked as Claude's discretion
   - What's unclear: Impact on orchestrator execution logic
   - Recommendation: Document as implementation decision in PLAN.md. Suggest `dependsOn` field makes dependencies explicit rather than implicit.

3. **Nested vs flat dashboard display for decimal phases?**
   - What we know: User marked as Claude's discretion
   - What's unclear: UX preference
   - Recommendation: Start with flat list (simpler implementation). Nested grouping is a future enhancement based on user feedback.

---

## Sources

### Primary (HIGH confidence)

- **TypeScript Handbook - Interfaces:** [https://www.typescriptlang.org/docs/handbook/interfaces.html](https://www.typescriptlang.org/docs/handbook/interfaces.html) - Optional field syntax and best practices
- **MDN Array.prototype.sort():** [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) - Numeric comparison function for decimal sorting
- **Vitest Documentation:** [https://vitest.dev/guide/](https://vitest.dev/guide/) - Testing pure functions in TypeScript
- **Existing codebase patterns:** `autopilot/src/orchestrator/index.ts` (extractPhasesFromContent structure), `autopilot/src/orchestrator/__tests__/gap-detector.test.ts` (Vitest patterns), `autopilot/dashboard/src/components/PhaseCard.tsx` (padPhaseDisplay function)

### Secondary (MEDIUM confidence)

- **Mastering TypeScript Optional Property (2026):** [https://stackinterface.com/typescript-optional-property/](https://stackinterface.com/typescript-optional-property/) - Modern best practices for optional fields
- **Using JavaScript's sort Method for Sorting Arrays of Numbers:** [https://www.digitalocean.com/community/tutorials/js-array-sort-numbers](https://www.digitalocean.com/community/tutorials/js-array-sort-numbers) - Numeric sorting patterns

### Tertiary (LOW confidence)

- N/A — All findings verified with official documentation or existing codebase.

---

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH - No new dependencies; using existing project tooling
- Architecture: HIGH - Pure function refactoring with existing test infrastructure
- Pitfalls: HIGH - All pitfalls derived from actual codebase bugs and TypeScript/JavaScript quirks

**Research date:** 2026-02-23
**Valid until:** 60 days (stable domain: TypeScript type system, JavaScript array methods, Vitest testing)
