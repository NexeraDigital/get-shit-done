---
phase: 10-add-gsd-milestone-support-to-autopilot-and-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - autopilot/src/server/routes/api.ts
  - autopilot/src/server/index.ts
  - autopilot/src/server/standalone.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/milestones returns milestone data with current and shipped fields"
    - "When no milestone data exists, endpoint returns { current: null, shipped: [] }"
    - "MilestoneProvider follows established provider injection pattern"
    - "Server wires milestone provider into API routes"
  artifacts:
    - path: "autopilot/src/server/routes/api.ts"
      provides: "MilestoneProvider interface and /api/milestones route"
      contains: "milestoneProvider"
    - path: "autopilot/src/server/index.ts"
      provides: "Milestone provider wiring in ResponseServer constructor"
      contains: "milestoneProvider"
  key_links:
    - from: "autopilot/src/server/routes/api.ts"
      to: "autopilot/src/milestone/parser.ts"
      via: "MilestoneProvider implementation"
      pattern: "parseMilestoneData"
    - from: "autopilot/src/server/index.ts"
      to: "autopilot/src/server/routes/api.ts"
      via: "milestoneProvider option injection"
      pattern: "milestoneProvider"
---

<objective>
Add the `/api/milestones` REST endpoint to the Express server, following the established provider injection pattern used by stateProvider, questionProvider, and activityProvider.

Purpose: The API endpoint is the bridge between the server-side milestone parser and the dashboard. It exposes milestone data as JSON for the React frontend to consume.

Output: Updated `api.ts` with MilestoneProvider interface and milestones route, updated `index.ts` and `standalone.ts` with milestone provider wiring.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-add-gsd-milestone-support-to-autopilot-and-dashboard/10-01-SUMMARY.md
@autopilot/src/server/routes/api.ts
@autopilot/src/server/index.ts
@autopilot/src/server/standalone.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: MilestoneProvider interface and /api/milestones route</name>
  <files>
    autopilot/src/server/routes/api.ts
  </files>
  <action>
**Add MilestoneProvider interface** (after existing ActivityProvider interface):

```typescript
import type { MilestoneResponse } from '../../milestone/types.js';

/** Provides milestone lifecycle data parsed from planning files */
export interface MilestoneProvider {
  getMilestones(): MilestoneResponse;
}
```

**Update ApiRouteDeps** to include optional milestone provider:

```typescript
export interface ApiRouteDeps {
  stateProvider: StateProvider;
  questionProvider: QuestionProvider;
  livenessProvider?: LivenessProvider;
  activityProvider?: ActivityProvider;
  milestoneProvider?: MilestoneProvider;  // NEW
}
```

**Add milestones route** in `createApiRoutes()` (after the activities endpoint, before shutdown):

```typescript
// Destructure milestoneProvider from deps alongside existing providers
const { stateProvider, questionProvider, livenessProvider, activityProvider, milestoneProvider } = deps;

// Milestones endpoint
router.get('/milestones', (_req: Request, res: Response) => {
  if (!milestoneProvider) {
    res.json({ current: null, shipped: [] });
    return;
  }
  const milestones = milestoneProvider.getMilestones();
  res.json(milestones);
});
```

Note: The response shape matches `MilestoneResponse` directly (no wrapping in a `{ milestones: ... }` envelope). This makes the type simpler and the API cleaner — the response IS the MilestoneResponse object with `current` and `shipped` fields.
  </action>
  <verify>
Run `cd autopilot && npx tsc --noEmit` — no type errors.
Verify the route handler is present: grep for `router.get('/milestones'` in api.ts.
  </verify>
  <done>
MilestoneProvider interface defined, /api/milestones route returns milestone data or empty response when no provider is configured.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire milestone provider into ResponseServer</name>
  <files>
    autopilot/src/server/index.ts
    autopilot/src/server/standalone.ts
  </files>
  <action>
**Update ResponseServer (index.ts):**

1. Import `MilestoneProvider` from routes/api.ts (add to existing import):
   ```typescript
   import type { StateProvider, QuestionProvider, LivenessProvider, MilestoneProvider } from './routes/api.js';
   ```

2. Add `milestoneProvider` to `ResponseServerOptions` interface:
   ```typescript
   export interface ResponseServerOptions {
     // ... existing fields ...
     /** Optional milestone data provider */
     milestoneProvider?: MilestoneProvider;
   }
   ```

3. In the constructor, add milestone provider handling alongside activityProvider:
   - Declare `milestoneProvider` variable in the local block
   - In the non-legacy branch: `milestoneProvider = opts.milestoneProvider;`
   - In the legacy branch: leave it undefined (legacy mode doesn't need milestones)
   - Pass `milestoneProvider` to `createApiRoutes()`:
     ```typescript
     const apiRouter = createApiRoutes({ stateProvider, questionProvider, livenessProvider, activityProvider, milestoneProvider });
     ```

**Update standalone server (standalone.ts):**

1. Import `parseMilestoneData` from the milestone parser:
   ```typescript
   import { parseMilestoneData } from '../milestone/parser.js';
   ```

2. Create a MilestoneProvider implementation that calls the parser. Since milestone data changes infrequently (only when `/gsd:complete-milestone` or `/gsd:new-milestone` runs), the parser re-reads files on each request — this is fine for small markdown files and avoids stale data issues:
   ```typescript
   const milestoneProvider = {
     getMilestones() {
       return parseMilestoneData(planningDir);  // planningDir is already available in standalone.ts
     },
   };
   ```

3. Pass `milestoneProvider` to the ResponseServer constructor options alongside existing providers.

Note: The `planningDir` variable should already be available in standalone.ts (it constructs the path to `.planning/`). If it uses `process.cwd()` directly, construct `planningDir` as `join(process.cwd(), '.planning')` and pass it to parseMilestoneData.
  </action>
  <verify>
Run `cd autopilot && npx tsc --noEmit` — no type errors.
Verify standalone.ts imports parser: grep for `parseMilestoneData` in standalone.ts.
  </verify>
  <done>
ResponseServer accepts optional milestoneProvider and passes it to API routes. Standalone server creates a milestone provider using the parser and injects it into the server.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` compiles without errors
- MilestoneProvider interface is exported from api.ts
- /api/milestones route exists in createApiRoutes
- ResponseServer constructor accepts milestoneProvider option
- Standalone server creates and injects milestone provider
</verification>

<success_criteria>
- GET /api/milestones endpoint returns MilestoneResponse JSON
- When no milestoneProvider is configured, returns { current: null, shipped: [] }
- Provider pattern matches existing ActivityProvider/LivenessProvider patterns
- Server wiring complete in both ResponseServer and standalone server
</success_criteria>

<output>
After completion, create `.planning/phases/10-add-gsd-milestone-support-to-autopilot-and-dashboard/10-02-SUMMARY.md`
</output>
