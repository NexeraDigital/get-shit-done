---
phase: 10-add-gsd-milestone-support-to-autopilot-and-dashboard
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - autopilot/dashboard/src/types/index.ts
  - autopilot/dashboard/src/api/client.ts
  - autopilot/dashboard/src/store/index.ts
  - autopilot/dashboard/src/hooks/useSSE.ts
  - autopilot/dashboard/src/components/PhaseCard.tsx
autonomous: true

must_haves:
  truths:
    - "Dashboard has MilestoneInfo and MilestoneResponse types mirrored from server"
    - "fetchMilestones() API client function exists and returns milestone data"
    - "Zustand store has currentMilestone and milestones state with setMilestones action"
    - "PhaseCard header shows 'v1.0 MVP — Phases' format when active milestone exists"
    - "PhaseCard falls back to 'Phases' header when no milestone is active"
    - "Milestone progress indicator shows phase completion count within the milestone"
    - "Milestones are fetched on mount and refreshed via polling"
  artifacts:
    - path: "autopilot/dashboard/src/types/index.ts"
      provides: "MilestoneStatus, MilestoneInfo, MilestoneResponse dashboard types"
      contains: "MilestoneInfo"
    - path: "autopilot/dashboard/src/api/client.ts"
      provides: "fetchMilestones API function"
      exports: ["fetchMilestones"]
    - path: "autopilot/dashboard/src/store/index.ts"
      provides: "Milestone state slice in Zustand store"
      contains: "currentMilestone"
    - path: "autopilot/dashboard/src/components/PhaseCard.tsx"
      provides: "Milestone-aware header with progress indicator"
      contains: "Phases"
  key_links:
    - from: "autopilot/dashboard/src/store/index.ts"
      to: "autopilot/dashboard/src/types/index.ts"
      via: "import MilestoneInfo type"
      pattern: "import.*MilestoneInfo"
    - from: "autopilot/dashboard/src/hooks/useSSE.ts"
      to: "autopilot/dashboard/src/api/client.ts"
      via: "fetchMilestones call in rehydrate and poll"
      pattern: "fetchMilestones"
    - from: "autopilot/dashboard/src/components/PhaseCard.tsx"
      to: "autopilot/dashboard/src/store/index.ts"
      via: "useDashboardStore selector for currentMilestone"
      pattern: "useDashboardStore.*currentMilestone"
---

<objective>
Add milestone awareness to the dashboard: mirror server types, add API client and store support, update PhaseCard to show milestone-scoped header and progress, and wire milestone fetching into SSE rehydration and polling.

Purpose: This is the dashboard data layer and the most user-visible change — the PhaseCard header transforms from "Phases" to "v1.0 MVP — Phases" when a milestone is active, with a milestone progress indicator. Per user decision, milestone identity is scoped to the Phases card only (not header bar or project description card).

Output: Updated dashboard types, API client, Zustand store, SSE hook, and PhaseCard component.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-add-gsd-milestone-support-to-autopilot-and-dashboard/10-01-SUMMARY.md
@autopilot/dashboard/src/types/index.ts
@autopilot/dashboard/src/api/client.ts
@autopilot/dashboard/src/store/index.ts
@autopilot/dashboard/src/hooks/useSSE.ts
@autopilot/dashboard/src/components/PhaseCard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dashboard types, API client, and store milestone slice</name>
  <files>
    autopilot/dashboard/src/types/index.ts
    autopilot/dashboard/src/api/client.ts
    autopilot/dashboard/src/store/index.ts
  </files>
  <action>
**Dashboard types (types/index.ts):**

Add milestone types at the end of the file, after the `ActivityItem` type. These are intentionally duplicated from the server (dashboard is a separate Vite project and must NOT import from server codebase):

```typescript
// Milestone types (mirrored from autopilot/src/milestone/types.ts)

export type MilestoneStatus = 'active' | 'shipped';

export type MilestoneInfo = {
  version: string;
  name: string;
  status: MilestoneStatus;
  shippedDate?: string;
  phaseCount: number;
  planCount: number;
  phasesCompleted: number;
  accomplishments: string[];
};

export type MilestoneResponse = {
  current: MilestoneInfo | null;
  shipped: MilestoneInfo[];
};
```

**API client (api/client.ts):**

1. Add `MilestoneResponse` to the import from types:
   ```typescript
   import type { ..., MilestoneResponse } from '../types/index.js';
   ```

2. Add `fetchMilestones` function (after fetchActivities, before push notification endpoints):
   ```typescript
   export async function fetchMilestones(): Promise<MilestoneResponse> {
     const res = await fetch('/api/milestones');
     if (!res.ok) {
       throw new Error(`fetchMilestones failed: ${String(res.status)}`);
     }
     return res.json() as Promise<MilestoneResponse>;
   }
   ```

**Zustand store (store/index.ts):**

1. Add `MilestoneInfo` to the import from types:
   ```typescript
   import type { ..., MilestoneInfo } from '../types/index.js';
   ```

2. Add milestone state fields to `DashboardState` interface:
   ```typescript
   // Milestone state
   currentMilestone: MilestoneInfo | null;
   milestones: MilestoneInfo[];

   // Milestone actions
   setMilestones: (current: MilestoneInfo | null, shipped: MilestoneInfo[]) => void;
   ```

3. Add initial state values in the create() call:
   ```typescript
   currentMilestone: null,
   milestones: [],
   ```

4. Add the `setMilestones` action:
   ```typescript
   setMilestones: (current, shipped) => set({ currentMilestone: current, milestones: shipped }),
   ```

Note: The action takes `current` and `shipped` separately (matching the API response shape) rather than a combined array. This avoids the need for a `.find(m => m.status === 'active')` lookup in the store — the server already determines which milestone is active.
  </action>
  <verify>
Run `cd autopilot/dashboard && npx tsc --noEmit` — no type errors.
Verify MilestoneInfo is in types: grep for `MilestoneInfo` in types/index.ts.
Verify fetchMilestones exists: grep for `fetchMilestones` in api/client.ts.
Verify store has milestone state: grep for `currentMilestone` in store/index.ts.
  </verify>
  <done>
Dashboard types mirror server milestone types, API client can fetch milestone data, and Zustand store has milestone state slice with current/shipped separation.
  </done>
</task>

<task type="auto">
  <name>Task 2: SSE milestone fetching and PhaseCard milestone header</name>
  <files>
    autopilot/dashboard/src/hooks/useSSE.ts
    autopilot/dashboard/src/components/PhaseCard.tsx
  </files>
  <action>
**SSE hook (hooks/useSSE.ts):**

1. Add `fetchMilestones` to the import from client:
   ```typescript
   import { fetchStatus, fetchPhases, fetchQuestions, fetchActivities, fetchMilestones } from '../api/client.js';
   ```

2. In the `rehydrate()` function, add milestones to the Promise.all:
   ```typescript
   const [statusRes, phasesRes, questionsRes, activitiesRes, milestonesRes] = await Promise.all([
     fetchStatus(),
     fetchPhases(),
     fetchQuestions(),
     fetchActivities(),
     fetchMilestones().catch(() => ({ current: null, shipped: [] })),
   ]);
   ```
   Note: `.catch()` on fetchMilestones ensures a missing /api/milestones endpoint (older server) doesn't break rehydration.

3. After existing rehydration calls, add:
   ```typescript
   store.setMilestones(milestonesRes.current, milestonesRes.shipped);
   ```

4. In the 3-second poll timer, add milestones to the Promise.all:
   ```typescript
   const pollTimer = setInterval(() => {
     void Promise.all([
       fetchStatus(), fetchPhases(), fetchQuestions(), fetchActivities(),
       fetchMilestones().catch(() => ({ current: null, shipped: [] })),
     ]).then(([s, p, q, a, m]) => {
       // ... existing state updates ...
       st.setMilestones(m.current, m.shipped);
     }).catch(() => { /* ignore poll failures */ });
   }, 3000);
   ```

5. In the `build-complete` SSE event handler, also refetch milestones (build complete may follow a milestone ship):
   ```typescript
   es.addEventListener('build-complete', () => {
     void Promise.all([
       fetchStatus(), fetchActivities(),
       fetchMilestones().catch(() => ({ current: null, shipped: [] })),
     ]).then(([s, a, m]) => {
       const st = useDashboardStore.getState();
       st.setStatus({ ... });
       st.setAutopilotAlive(s.alive);
       st.setActivities(a.activities);
       st.setMilestones(m.current, m.shipped);
     });
   });
   ```

**PhaseCard component (components/PhaseCard.tsx):**

1. Import `useDashboardStore` from store:
   ```typescript
   import { useDashboardStore } from '../store/index.js';
   ```

2. In the `PhaseCard` component function, read milestone state:
   ```typescript
   const currentMilestone = useDashboardStore((s) => s.currentMilestone);
   ```

3. Replace the static "Phases" header section with milestone-aware rendering. The header area (inside the `<div className="flex items-center justify-between mb-4">`) should:

   **When `currentMilestone` exists (active milestone):**
   - Replace `<h3>Phases</h3>` with:
     ```tsx
     <div>
       <h3 className="text-sm font-semibold text-gray-700">
         {currentMilestone.version} {currentMilestone.name} — Phases
       </h3>
       <p className="text-xs text-gray-400 mt-0.5">
         Milestone {currentMilestone.phasesCompleted} of {currentMilestone.phaseCount} phases complete
       </p>
     </div>
     ```
   - Keep the existing completion count on the right side (`{completedCount}/{totalCount} complete`)

   **When `currentMilestone` is null (no active milestone):**
   - Keep current behavior: `<h3 className="text-sm font-semibold text-gray-700">Phases</h3>`

   This follows the user decision: "Replace the 'Phases' section header with 'v1.0 MVP — Phases' format when a milestone is active" and "When no milestone exists, fall back to just 'Phases' (current behavior)".

   Also per user decision: "Show both phase count AND milestone progress indicator" — the subtitle line shows milestone-scoped progress while the right-side count shows phase-level progress from the autopilot state.
  </action>
  <verify>
Run `cd autopilot/dashboard && npx tsc --noEmit` — no type errors.
Verify PhaseCard imports store: grep for `useDashboardStore` in PhaseCard.tsx.
Verify milestone header rendering: grep for `currentMilestone.version` in PhaseCard.tsx.
Verify useSSE fetches milestones: grep for `fetchMilestones` in useSSE.ts.
  </verify>
  <done>
SSE hook fetches milestones on mount, reconnect, and polling. PhaseCard displays "v1.0 MVP — Phases" header with milestone progress indicator when a milestone is active, falls back to plain "Phases" when no milestone exists.
  </done>
</task>

</tasks>

<verification>
- `cd autopilot/dashboard && npx tsc --noEmit` compiles without errors
- `cd autopilot && npx tsc --noEmit` compiles without errors (if full build needed)
- PhaseCard shows milestone-aware header when currentMilestone is set
- PhaseCard falls back to "Phases" when currentMilestone is null
- Milestones are fetched during rehydration and polling
- fetchMilestones failure doesn't break other data fetching
</verification>

<success_criteria>
- Dashboard types mirror server MilestoneInfo/MilestoneResponse exactly
- fetchMilestones API client function works
- Zustand store has currentMilestone and milestones state
- PhaseCard header shows "v1.0 MVP — Phases" when milestone active (per user decision)
- PhaseCard shows "Phases" when no milestone (per user decision)
- Milestone progress indicator shows "Milestone X of Y phases complete" (per user decision)
- Polling and SSE rehydration include milestones
</success_criteria>

<output>
After completion, create `.planning/phases/10-add-gsd-milestone-support-to-autopilot-and-dashboard/10-03-SUMMARY.md`
</output>
