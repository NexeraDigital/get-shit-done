---
phase: 05-react-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - autopilot/dashboard/package.json
  - autopilot/dashboard/tsconfig.json
  - autopilot/dashboard/vite.config.ts
  - autopilot/dashboard/index.html
  - autopilot/dashboard/src/main.tsx
  - autopilot/dashboard/src/App.tsx
  - autopilot/dashboard/src/index.css
  - autopilot/dashboard/src/types/index.ts
  - autopilot/dashboard/src/store/index.ts
  - autopilot/dashboard/src/api/client.ts
  - autopilot/dashboard/src/hooks/useSSE.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard Vite project compiles with zero TypeScript errors"
    - "Zustand store holds status, phases, questions, logs, activities, and connected state"
    - "API client can fetch status, phases, questions, and submit answers"
    - "useSSE hook connects to EventSource and dispatches events to the store"
  artifacts:
    - path: "autopilot/dashboard/package.json"
      provides: "Dashboard project with React 19, Vite 7, Zustand 5, Tailwind v4, react-router 7, react-markdown"
      contains: "react"
    - path: "autopilot/dashboard/src/types/index.ts"
      provides: "Mirrored server types (PhaseState, QuestionEvent, LogEntry, etc.)"
      min_lines: 30
    - path: "autopilot/dashboard/src/store/index.ts"
      provides: "Zustand store with all dashboard state and actions"
      exports: ["useDashboardStore"]
    - path: "autopilot/dashboard/src/api/client.ts"
      provides: "Typed fetch wrappers for all REST endpoints"
      exports: ["fetchStatus", "fetchPhases", "fetchQuestions", "submitAnswer"]
    - path: "autopilot/dashboard/src/hooks/useSSE.ts"
      provides: "EventSource hook updating Zustand store on SSE events"
      exports: ["useSSE"]
  key_links:
    - from: "autopilot/dashboard/src/hooks/useSSE.ts"
      to: "/api/log/stream"
      via: "new EventSource('/api/log/stream')"
      pattern: "EventSource.*api/log/stream"
    - from: "autopilot/dashboard/src/hooks/useSSE.ts"
      to: "autopilot/dashboard/src/store/index.ts"
      via: "useDashboardStore.getState() calls in event handlers"
      pattern: "useDashboardStore"
    - from: "autopilot/dashboard/src/api/client.ts"
      to: "/api/status"
      via: "fetch('/api/status')"
      pattern: "fetch.*api/status"
---

<objective>
Scaffold the React dashboard Vite project and build the entire data layer: types, Zustand store, API client, and SSE hook.

Purpose: Every page and component in the dashboard depends on this foundation -- types for shape, store for state, API client for REST, and useSSE for real-time updates. Building this first means all subsequent plans can focus purely on UI.
Output: A compilable Vite project in autopilot/dashboard/ with working data layer ready for page components.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-react-dashboard/05-RESEARCH.md

# Server types to mirror in dashboard
@autopilot/src/types/state.ts
@autopilot/src/types/log.ts
@autopilot/src/claude/types.ts

# API contract
@autopilot/src/server/routes/api.ts
@autopilot/src/server/routes/sse.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Vite project with React 19, Tailwind v4, and TypeScript</name>
  <files>
    autopilot/dashboard/package.json
    autopilot/dashboard/tsconfig.json
    autopilot/dashboard/vite.config.ts
    autopilot/dashboard/index.html
    autopilot/dashboard/src/main.tsx
    autopilot/dashboard/src/App.tsx
    autopilot/dashboard/src/index.css
  </files>
  <action>
Create the dashboard project manually (do NOT use `npm create vite` -- write files directly for full control).

1. **package.json** -- Use the exact structure from research:
   - name: "@gsd/autopilot-dashboard", private: true, type: "module"
   - dependencies: react ^19.2.4, react-dom ^19.2.4, react-router ^7.13.0, zustand ^5.0.11, react-markdown ^10.1.0
   - devDependencies: vite ^7.3.1, @vitejs/plugin-react ^5.1.4, tailwindcss ^4.1.18, @tailwindcss/vite ^4.1.18, typescript ~5.9.0, @types/react ^19.0.0, @types/react-dom ^19.0.0
   - scripts: dev ("vite"), build ("tsc --noEmit && vite build"), preview ("vite preview")

2. **tsconfig.json** -- Target ES2022, module ESNext, moduleResolution bundler, lib ES2024+DOM+DOM.Iterable, jsx react-jsx, strict true, noUncheckedIndexedAccess true, verbatimModuleSyntax true, noEmit true, include ["src"]

3. **vite.config.ts** -- Import defineConfig, react plugin, tailwindcss plugin. Plugins: [react(), tailwindcss()]. Server proxy: '/api' -> 'http://localhost:3847' with changeOrigin true. Build: outDir 'dist', emptyOutDir true.

4. **index.html** -- Standard Vite HTML entry with div#root and script src="/src/main.tsx" type="module". Title: "GSD Autopilot Dashboard".

5. **src/index.css** -- Single line: `@import "tailwindcss";` (Tailwind v4 zero-config setup, NO tailwind.config.js)

6. **src/main.tsx** -- StrictMode wrapping App, createRoot on document.getElementById('root')!, import './index.css'.

7. **src/App.tsx** -- Placeholder that imports BrowserRouter, Routes, Route from 'react-router'. Set up route structure with placeholder divs for: index ("/"), questions ("questions/:questionId"), phases ("phases/:phaseNumber"), logs ("logs"). Each route renders a simple div with the page name for now. This proves routing works.

Run `cd autopilot/dashboard && npm install` to install all dependencies.
  </action>
  <verify>
Run `cd autopilot/dashboard && npx tsc --noEmit` -- zero TypeScript errors.
Run `cd autopilot/dashboard && npx vite build` -- produces dist/ with index.html.
  </verify>
  <done>Dashboard Vite project exists at autopilot/dashboard/, compiles cleanly, and produces a production build with Tailwind CSS and React Router routing.</done>
</task>

<task type="auto">
  <name>Task 2: Create dashboard types mirroring server types</name>
  <files>
    autopilot/dashboard/src/types/index.ts
  </files>
  <action>
Create `autopilot/dashboard/src/types/index.ts` with duplicated types from the server codebase. Do NOT import from the server -- the dashboard is a separate Vite project (Pitfall 5 from research).

Mirror these types exactly from the server source files:

From `autopilot/src/types/state.ts`:
- `AutopilotStatus` type union: 'idle' | 'running' | 'waiting_for_human' | 'error' | 'complete'
- `PhaseStep` type union: 'idle' | 'discuss' | 'plan' | 'execute' | 'verify' | 'done'
- `PhaseStatus` type union: 'pending' | 'in_progress' | 'completed' | 'failed' | 'skipped'
- `PhaseState` interface with number, name, status, steps ({discuss, plan, execute, verify}), startedAt?, completedAt?, commits, gapIterations

From `autopilot/src/types/log.ts`:
- `LogLevel` type union: 'debug' | 'info' | 'warn' | 'error' | 'fatal'
- `LogEntry` interface with timestamp, level, component, message, phase?, step?, meta?

From `autopilot/src/claude/types.ts`:
- `QuestionOption` with label, description
- `QuestionItem` with question, header, options, multiSelect
- `QuestionEvent` with id, phase?, step?, questions, createdAt

Add a dashboard-specific type:
- `ActivityItem` with type ('phase-started' | 'phase-completed' | 'question-pending' | 'question-answered' | 'error' | 'build-complete'), message (string), timestamp (string)

Use `export type` for all type exports (consistent with project convention of verbatimModuleSyntax).
  </action>
  <verify>Run `cd autopilot/dashboard && npx tsc --noEmit` -- zero errors.</verify>
  <done>All dashboard types exist in a single file, mirroring server types exactly, with no cross-project imports.</done>
</task>

<task type="auto">
  <name>Task 3: Build Zustand store, API client, and useSSE hook</name>
  <files>
    autopilot/dashboard/src/store/index.ts
    autopilot/dashboard/src/api/client.ts
    autopilot/dashboard/src/hooks/useSSE.ts
  </files>
  <action>
**1. Zustand store** (`src/store/index.ts`):

Create the store using Zustand 5's `create<T>()()` curried pattern (required for TypeScript in v5):

```typescript
import { create } from 'zustand';
```

State shape (DashboardState interface):
- status: AutopilotStatus (default 'idle')
- currentPhase: number (default 0)
- currentStep: string (default 'idle')
- progress: number (default 0)
- phases: PhaseState[] (default [])
- questions: QuestionEvent[] (default [])
- logs: LogEntry[] (default [])
- activities: ActivityItem[] (default [])
- connected: boolean (default false)

Actions:
- setStatus(patch: Partial of status/currentPhase/currentStep/progress) -- shallow merge
- setPhases(phases) -- replace
- setQuestions(questions) -- replace
- addLog(entry) -- append, cap at 500 entries (slice -499 then push)
- addActivity(item) -- prepend, cap at 50 entries
- setConnected(connected) -- set
- updatePhase(phaseNumber, patch) -- map over phases, patch matching number

Export: `useDashboardStore`

**2. API client** (`src/api/client.ts`):

Thin typed fetch wrappers. Base URL is empty string (same origin in production, Vite proxy in dev).

Functions:
- `fetchStatus()` -- GET /api/status, returns `{ status, currentPhase, currentStep, progress, startedAt, lastUpdatedAt }`
- `fetchPhases()` -- GET /api/phases, returns `{ phases: PhaseState[] }`
- `fetchQuestions()` -- GET /api/questions, returns `{ questions: QuestionEvent[] }`
- `fetchQuestion(id: string)` -- GET /api/questions/:id, returns QuestionEvent
- `submitAnswer(questionId: string, answers: Record<string, string>)` -- POST /api/questions/:id with JSON body { answers }, returns `{ ok: boolean }`

Each function checks `res.ok` and throws Error with status code on failure. Use `as Promise<T>` return type assertion on `res.json()`.

**3. useSSE hook** (`src/hooks/useSSE.ts`):

Follow Pattern 2 from research exactly. Key details:
- Create EventSource at '/api/log/stream' in useEffect
- onopen: setConnected(true), then fetch full state from REST (status, phases, questions) to rehydrate on reconnection (Pitfall 3)
- onerror: setConnected(false), do NOT close the EventSource (let it auto-reconnect)
- addEventListener for each event type:
  - 'log-entry': parse JSON, call addLog
  - 'phase-started': parse JSON, addActivity with type/message/timestamp, then fetch /api/status and /api/phases to refresh
  - 'phase-completed': same pattern as phase-started
  - 'question-pending': addActivity, then fetch /api/questions to refresh
  - 'question-answered': fetch /api/questions to refresh
  - 'error': parse JSON, addActivity with error type
  - 'build-complete': addActivity, fetch /api/status to refresh
- Cleanup: close EventSource on unmount
- Use useRef for EventSource instance, access store via `useDashboardStore` (the store itself, not the hook -- use `.getState()` for non-reactive access in event handlers)
- Empty dependency array `[]` -- connect once at mount

Import types from '../types/index.js' (not server types).
  </action>
  <verify>
Run `cd autopilot/dashboard && npx tsc --noEmit` -- zero TypeScript errors.
Run `cd autopilot/dashboard && npx vite build` -- successful build.
  </verify>
  <done>Zustand store holds all dashboard state with capped log/activity arrays. API client provides typed fetch wrappers for all 5 REST endpoints. useSSE hook connects to EventSource and dispatches all 7 SSE event types to the store with reconnection rehydration.</done>
</task>

</tasks>

<verification>
- `cd autopilot/dashboard && npx tsc --noEmit` passes with zero errors
- `cd autopilot/dashboard && npx vite build` produces dist/index.html + JS/CSS assets
- Types in dashboard/src/types/index.ts match server types exactly
- Store has all required state fields and actions
- API client covers all 5 REST endpoints
- useSSE hook handles all 7 SSE event types
</verification>

<success_criteria>
Dashboard project compiles, builds, and contains a complete data layer (types, store, API client, SSE hook) ready for UI components in subsequent plans.
</success_criteria>

<output>
After completion, create `.planning/phases/05-react-dashboard/05-01-SUMMARY.md`
</output>
