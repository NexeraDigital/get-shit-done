---
phase: 11-use-microsoft-dev-tunnels-to-create-public-urls-for-remote-dashboard-access
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - autopilot/package.json
  - autopilot/src/server/tunnel/manager.ts
  - autopilot/src/server/tunnel/index.ts
autonomous: true

must_haves:
  truths:
    - "TunnelManager can create a dev-tunnel with anonymous access and return a public URL"
    - "TunnelManager reconnects automatically on connection drop with exponential backoff"
    - "TunnelManager.stop() disposes the host and deletes the tunnel cleanly"
    - "Dev-tunnels SDK packages are installed as npm dependencies"
  artifacts:
    - path: "autopilot/src/server/tunnel/manager.ts"
      provides: "TunnelManager class with start/stop/reconnect lifecycle"
      min_lines: 80
    - path: "autopilot/src/server/tunnel/index.ts"
      provides: "Barrel export for TunnelManager"
      exports: ["TunnelManager"]
    - path: "autopilot/package.json"
      provides: "Dev-tunnels SDK dependencies"
      contains: "@microsoft/dev-tunnels-management"
  key_links:
    - from: "autopilot/src/server/tunnel/manager.ts"
      to: "@microsoft/dev-tunnels-management"
      via: "TunnelManagementHttpClient for tunnel CRUD"
      pattern: "TunnelManagementHttpClient"
    - from: "autopilot/src/server/tunnel/manager.ts"
      to: "@microsoft/dev-tunnels-connections"
      via: "TunnelRelayTunnelHost for hosting"
      pattern: "TunnelRelayTunnelHost"
---

<objective>
Install the Microsoft dev-tunnels SDK and create the TunnelManager class that handles the full tunnel lifecycle: create tunnel with anonymous access, host it, handle reconnection with exponential backoff, and clean up on stop.

Purpose: This is the core integration layer between the autopilot server and the dev-tunnels service. All other tunnel features (CLI flags, notifications, dashboard UI) depend on this class.

Output: TunnelManager class ready for integration into server startup/shutdown and CLI wiring.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-use-microsoft-dev-tunnels-to-create-public-urls-for-remote-dashboard-access/11-RESEARCH.md
@autopilot/package.json
@autopilot/src/orchestrator/shutdown.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dev-tunnels SDK packages and create TunnelManager class</name>
  <files>
    autopilot/package.json
    autopilot/src/server/tunnel/manager.ts
    autopilot/src/server/tunnel/index.ts
  </files>
  <action>
1. Install the three dev-tunnels packages:
   ```
   cd autopilot && npm install @microsoft/dev-tunnels-management @microsoft/dev-tunnels-contracts @microsoft/dev-tunnels-connections
   ```

2. Create `autopilot/src/server/tunnel/manager.ts` with a `TunnelManager` class:

   **Constructor** accepts options:
   - `logger?: { info(msg: string): void; warn(msg: string): void; error(msg: string): void }` -- optional logging interface
   - `onReconnect?: (newUrl: string) => void` -- callback when tunnel reconnects with potentially new URL
   - `onDisconnect?: () => void` -- callback when tunnel connection drops

   **`async start(port: number): Promise<string>`**
   - Get Azure AD token from `process.env.DEVTUNNEL_TOKEN` (or `AAD_TOKEN` as fallback). If no token is available, throw a clear error: "Dev-tunnel token not found. Set DEVTUNNEL_TOKEN environment variable. Get one with: az account get-access-token --resource https://tunnels.api.visualstudio.com"
   - Create `TunnelManagementHttpClient` with user-agent `ProductHeaderValue('gsd-autopilot', '1.0.0')` and token callback.
   - Build tunnel object with:
     - `ports: [{ portNumber: port, protocol: 'https' }]`
     - `accessControl.entries: [{ type: TunnelAccessControlEntryType.Anonymous, subjects: [], scopes: [TunnelAccessScopes.Connect] }]`
   - Call `managementClient.createTunnel(tunnel, { tokenScopes: [TunnelAccessScopes.Host] })` to create the tunnel.
   - Create `TunnelRelayTunnelHost(managementClient)`.
   - Set up reconnection event handlers on the host (see reconnection logic below).
   - Call `host.connect(tunnel)`.
   - Extract public URL from `tunnel.endpoints` -- iterate tunnel ports to find the port URI.
   - Store `tunnel`, `host`, `managementClient`, and `port` as private instance fields.
   - Return the public URL string.

   **Reconnection logic:**
   - Wire `host.connectionStatusChanged` or equivalent event.
   - On disconnect: log warning, call `onDisconnect` callback.
   - Implement retry with exponential backoff: delays of 1s, 2s, 4s, 8s, 16s, 30s (capped at 30s), max 10 retries.
   - On successful reconnect: extract new URL from tunnel endpoints, call `onReconnect(newUrl)` callback.
   - If max retries exceeded: log error but do NOT crash -- tunnel is simply unavailable, local dashboard still works.
   - Use `setTimeout` with `.unref()` for retry timers to avoid blocking Node.js exit.

   **`async stop(): Promise<void>`**
   - If host exists: await `host.dispose()`, set to null.
   - If tunnel and managementClient exist: await `managementClient.deleteTunnel(tunnel)`, set to null.
   - Wrap both in try/catch -- log errors but don't throw (shutdown should continue).
   - Cancel any pending reconnection timer.

   **`get url(): string | null`** -- returns current tunnel URL or null if not started/failed.

   **`get isConnected(): boolean`** -- returns whether tunnel host is currently connected.

   Important notes:
   - The SDK types may differ slightly from the research document. Inspect the actual SDK exports at build time and adapt. The research patterns are guides, not exact API contracts.
   - Use `import type` for type-only imports from the SDK to maintain the project's verbatimModuleSyntax convention.
   - All methods should be async-safe -- no unhandled promise rejections.

3. Create `autopilot/src/server/tunnel/index.ts` as barrel export:
   ```typescript
   export { TunnelManager } from './manager.js';
   ```
  </action>
  <verify>
    - `cd autopilot && npx tsc --noEmit` compiles without errors
    - `autopilot/package.json` contains all three `@microsoft/dev-tunnels-*` packages in dependencies
    - `autopilot/src/server/tunnel/manager.ts` exports TunnelManager class with start(), stop(), url getter, isConnected getter
  </verify>
  <done>
    TunnelManager class exists with full lifecycle (create, host, reconnect, stop), dev-tunnels SDK installed as npm dependencies, and barrel export set up. The class is ready for integration into CLI and server startup.
  </done>
</task>

</tasks>

<verification>
- TypeScript compiles: `cd autopilot && npx tsc --noEmit`
- Package has dev-tunnels dependencies: grep for `@microsoft/dev-tunnels` in package.json
- TunnelManager exports are accessible: barrel export in tunnel/index.ts
</verification>

<success_criteria>
TunnelManager class is created with start/stop/reconnect methods, dev-tunnels SDK packages are installed, and the code compiles cleanly. The class follows the project's existing patterns (async lifecycle, logger injection, error handling without crashing).
</success_criteria>

<output>
After completion, create `.planning/phases/11-use-microsoft-dev-tunnels-to-create-public-urls-for-remote-dashboard-access/11-01-SUMMARY.md`
</output>
