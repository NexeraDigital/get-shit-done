---
phase: 11-use-microsoft-dev-tunnels-to-create-public-urls-for-remote-dashboard-access
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - autopilot/src/state/index.ts
  - autopilot/src/types/index.ts
  - autopilot/src/cli/index.ts
  - autopilot/src/server/standalone.ts
autonomous: true

must_haves:
  truths:
    - "Tunnel URL persists in autopilot-state.json across server restarts"
    - "CLI starts tunnel automatically by default, respects --no-tunnel flag"
    - "Tunnel tears down gracefully via ShutdownManager on Ctrl+C"
    - "If tunnel fails, server starts locally with warning (graceful degradation)"
    - "Tunnel URL is accessible from state file for status commands"
  artifacts:
    - path: "autopilot/src/state/index.ts"
      provides: "tunnelUrl field in AutopilotState"
      contains: "tunnelUrl"
    - path: "autopilot/src/types/index.ts"
      provides: "tunnelUrl field in AutopilotState type"
      contains: "tunnelUrl"
    - path: "autopilot/src/cli/index.ts"
      provides: "Tunnel lifecycle in CLI bootstrap"
      contains: "TunnelManager"
    - path: "autopilot/src/server/standalone.ts"
      provides: "Tunnel support in standalone dashboard mode"
      contains: "TunnelManager"
  key_links:
    - from: "autopilot/src/cli/index.ts"
      to: "autopilot/src/server/tunnel/manager.ts"
      via: "TunnelManager instantiation and lifecycle"
      pattern: "new TunnelManager"
    - from: "autopilot/src/cli/index.ts"
      to: "autopilot/src/orchestrator/shutdown.ts"
      via: "ShutdownManager registration for tunnel cleanup"
      pattern: "shutdownManager.register.*tunnel"
    - from: "autopilot/src/state/index.ts"
      to: "tunnelUrl field"
      via: "State persistence for cross-tool access"
      pattern: "tunnelUrl.*string"

user_setup:
  - service: Microsoft dev-tunnels
    why: "Required for tunnel creation and hosting"
    env_vars:
      - name: DEVTUNNEL_TOKEN
        source: "Run: az account get-access-token --resource https://tunnels.api.visualstudio.com --query accessToken -o tsv"
        optional: false
---

<objective>
Wire TunnelManager into server lifecycle: persist tunnel URL in state file, integrate with CLI and standalone server, add --no-tunnel flag, register cleanup with ShutdownManager, and implement graceful degradation on tunnel failure.

Purpose: Complete the tunnel infrastructure so tunnels start automatically with the server, clean up properly, persist URLs for cross-tool access, and fail gracefully without blocking local dashboard access.

Output: Fully integrated tunnel lifecycle with state persistence, CLI control, and graceful error handling.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-use-microsoft-dev-tunnels-to-create-public-urls-for-remote-dashboard-access/11-RESEARCH.md
@.planning/phases/11-use-microsoft-dev-tunnels-to-create-public-urls-for-remote-dashboard-access/11-CONTEXT.md
@.planning/phases/11-use-microsoft-dev-tunnels-to-create-public-urls-for-remote-dashboard-access/11-01-SUMMARY.md
@autopilot/src/state/index.ts
@autopilot/src/types/index.ts
@autopilot/src/cli/index.ts
@autopilot/src/server/standalone.ts
@autopilot/src/orchestrator/shutdown.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tunnelUrl field to AutopilotState types and StateStore</name>
  <files>
    autopilot/src/types/index.ts
    autopilot/src/state/index.ts
  </files>
  <action>
1. In `autopilot/src/types/index.ts`, add `tunnelUrl` field to `AutopilotState` interface:
   ```typescript
   export interface AutopilotState {
     // ... existing fields ...
     tunnelUrl?: string; // Public dev-tunnel URL for remote dashboard access
   }
   ```

2. In `autopilot/src/state/index.ts`, update the Zod schema `AutopilotStateSchema` to include the new field:
   ```typescript
   const AutopilotStateSchema = z.object({
     // ... existing fields ...
     tunnelUrl: z.string().optional(),
   }).passthrough();
   ```

No other changes needed -- StateStore.setState() already accepts partial patches, so callers can update tunnelUrl independently.
  </action>
  <verify>
    - `cd autopilot && npx tsc --noEmit` compiles without errors
    - Grep for `tunnelUrl` in both files: `grep -n tunnelUrl autopilot/src/types/index.ts autopilot/src/state/index.ts`
  </verify>
  <done>
    AutopilotState type and schema include tunnelUrl field, enabling persistence of tunnel URL to state.json for cross-tool access.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate TunnelManager into CLI with --no-tunnel flag and ShutdownManager cleanup</name>
  <files>
    autopilot/src/cli/index.ts
  </files>
  <action>
1. Import TunnelManager from `../server/tunnel/index.js` at top of file.

2. Add `--no-tunnel` CLI flag to Commander options:
   ```typescript
   .option('--no-tunnel', 'Disable public tunnel (local-only dashboard)')
   ```

3. In the CLI action handler, after `ResponseServer.start()` succeeds and before `orchestrator.run()`:

   **Tunnel lifecycle logic:**

   a. Check if tunnel should be enabled:
      ```typescript
      const enableTunnel = options.tunnel !== false; // --no-tunnel sets this to false
      ```

   b. If `enableTunnel` is true:
      - Create TunnelManager instance: `const tunnelManager = new TunnelManager({ logger, onReconnect: (url) => { logger.info('Tunnel reconnected: ' + url); }, onDisconnect: () => { logger.warn('Tunnel connection dropped, reconnecting...'); } });`
      - Try to start tunnel with `await tunnelManager.start(port)` wrapped in try-catch:
        - **On success**:
          - Save tunnel URL to state: `await stateStore.setState({ tunnelUrl: url });`
          - Log success: `logger.info('Dashboard available at: ' + url);`
          - Register cleanup: `shutdownManager.register(async () => { await tunnelManager.stop(); });` (before responseServer cleanup for LIFO)
        - **On failure** (catch block):
          - Log warning with error message: `logger.warn('Tunnel creation failed: ' + err.message);`
          - Log fallback: `logger.info('Dashboard available at: http://localhost:' + port);`
          - Set state tunnelUrl to null: `await stateStore.setState({ tunnelUrl: null });`
      - If `enableTunnel` is false:
        - Log: `logger.info('Dashboard available at: http://localhost:' + port);`
        - Set state tunnelUrl to null: `await stateStore.setState({ tunnelUrl: null });`

4. Ensure ShutdownManager registration order: tunnel cleanup should run BEFORE server.close() (LIFO = last registered runs first). Register tunnel cleanup after server cleanup in the code, so it executes before server shutdown.

Key decisions from research:
- Token comes from DEVTUNNEL_TOKEN or AAD_TOKEN env var (TunnelManager handles this internally per Plan 01)
- Graceful degradation: tunnel failure is non-fatal, dashboard works locally
- Always-on by default, explicit opt-out with --no-tunnel
  </action>
  <verify>
    - `cd autopilot && npx tsc --noEmit` compiles without errors
    - Grep for TunnelManager: `grep -n TunnelManager autopilot/src/cli/index.ts`
    - Grep for --no-tunnel flag: `grep -n "no-tunnel" autopilot/src/cli/index.ts`
    - Grep for shutdownManager.register with tunnel: `grep -A2 "tunnel" autopilot/src/cli/index.ts | grep register`
  </verify>
  <done>
    CLI starts TunnelManager by default, respects --no-tunnel flag, saves tunnel URL to state, registers cleanup with ShutdownManager in LIFO order, and gracefully degrades on tunnel failure without blocking local dashboard.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tunnel support to standalone dashboard server</name>
  <files>
    autopilot/src/server/standalone.ts
  </files>
  <action>
1. Import TunnelManager from `./tunnel/index.js` at top of file.

2. After the standalone server starts (after `await server.start(port)`), add tunnel logic similar to CLI but adapted for standalone mode:

   a. Check if `DEVTUNNEL_TOKEN` or `AAD_TOKEN` environment variable is set:
      ```typescript
      const hasToken = process.env.DEVTUNNEL_TOKEN || process.env.AAD_TOKEN;
      const enableTunnel = hasToken && process.env.NO_TUNNEL !== 'true';
      ```

   b. If `enableTunnel`:
      - Create TunnelManager: `const tunnelManager = new TunnelManager({ logger: { info: console.log, warn: console.warn, error: console.error }, onReconnect: (url) => console.log('Tunnel reconnected:', url) });`
      - Try to start tunnel wrapped in try-catch:
        - **On success**: log tunnel URL: `console.log('Dashboard available at:', url);`
        - **On failure**: log warning and fallback: `console.warn('Tunnel creation failed:', err.message); console.log('Dashboard available at: http://localhost:' + port);`
      - Register cleanup: add to process exit handlers
        ```typescript
        process.on('SIGINT', async () => {
          await tunnelManager?.stop();
          await server.close();
          process.exit(0);
        });
        ```

   c. If not enabling tunnel: just log localhost URL as before.

Note: Standalone mode doesn't have StateStore, so no state persistence here -- that's only for CLI mode with orchestrator.
  </action>
  <verify>
    - `cd autopilot && npx tsc --noEmit` compiles without errors
    - Grep for TunnelManager in standalone: `grep -n TunnelManager autopilot/src/server/standalone.ts`
    - Standalone server still compiles and runs (manual test deferred to verification phase)
  </verify>
  <done>
    Standalone dashboard server supports tunnel creation when DEVTUNNEL_TOKEN is set, logs tunnel URL on success, gracefully degrades on failure, and cleans up tunnel on SIGINT.
  </done>
</task>

</tasks>

<verification>
- TypeScript compiles: `cd autopilot && npx tsc --noEmit`
- tunnelUrl field present in types and schema
- CLI imports TunnelManager and wires lifecycle
- Standalone server imports TunnelManager
- --no-tunnel flag exists in Commander options
</verification>

<success_criteria>
Tunnel URL persists in state file, CLI respects --no-tunnel flag, tunnel cleans up via ShutdownManager, graceful degradation on tunnel failure, and standalone server supports tunnel when token is available. Code compiles cleanly and follows existing patterns (DI, error handling, shutdown ordering).
</success_criteria>

<output>
After completion, create `.planning/phases/11-use-microsoft-dev-tunnels-to-create-public-urls-for-remote-dashboard-access/11-02-SUMMARY.md`
</output>
