---
phase: 03.1-display-claude-console-output
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - autopilot/src/output/verbosity.ts
  - autopilot/src/output/colors.ts
  - autopilot/src/output/banner.ts
  - autopilot/src/output/stream-logger.ts
  - autopilot/src/output/stream-renderer.ts
  - autopilot/src/output/index.ts
  - autopilot/src/output/__tests__/verbosity.test.ts
  - autopilot/src/output/__tests__/banner.test.ts
  - autopilot/src/output/__tests__/stream-renderer.test.ts
  - autopilot/src/output/__tests__/stream-logger.test.ts
autonomous: true

must_haves:
  truths:
    - "StreamRenderer routes each SDK message type to a type-specific formatter"
    - "StreamRenderer respects verbosity: quiet shows errors only, default shows everything, verbose adds system messages"
    - "StreamLogger writes raw SDK messages as JSON lines to sdk-output.log"
    - "StreamLogger always captures everything regardless of verbosity"
    - "Phase/step banners render with box-drawing characters and timestamp"
    - "Sub-agent messages get color-coded prefix based on agent type"
    - "Spinner starts when command begins and stops on first content"
  artifacts:
    - path: "autopilot/src/output/stream-renderer.ts"
      provides: "Terminal formatter routing SDKMessage to formatted console output"
      min_lines: 100
    - path: "autopilot/src/output/stream-logger.ts"
      provides: "Raw JSON line writer to sdk-output.log via pino"
      min_lines: 30
    - path: "autopilot/src/output/verbosity.ts"
      provides: "Verbosity level type and message filter function"
      min_lines: 20
    - path: "autopilot/src/output/colors.ts"
      provides: "Color palette constants and agent prefix color map"
      min_lines: 20
    - path: "autopilot/src/output/banner.ts"
      provides: "Phase/step banner rendering with box-drawing"
      min_lines: 20
    - path: "autopilot/src/output/index.ts"
      provides: "Barrel export for output module"
  key_links:
    - from: "autopilot/src/output/stream-renderer.ts"
      to: "autopilot/src/output/verbosity.ts"
      via: "import VerbosityLevel and shouldDisplay filter"
      pattern: "import.*verbosity"
    - from: "autopilot/src/output/stream-renderer.ts"
      to: "autopilot/src/output/colors.ts"
      via: "import color palette and agent prefix map"
      pattern: "import.*colors"
    - from: "autopilot/src/output/stream-renderer.ts"
      to: "autopilot/src/output/banner.ts"
      via: "import renderBanner for phase/step transitions"
      pattern: "import.*banner"
---

<objective>
Build the output infrastructure module that formats SDK messages for terminal display and persists raw messages to a log file.

Purpose: This is the rendering/logging layer that will be wired into ClaudeService in plan 02. It must handle all SDK message types, apply verbosity filtering, format sub-agent output with color prefixes, show phase/step banners, and manage spinner lifecycle -- while simultaneously writing raw unformatted JSON to a separate log file.

Output: A complete `src/output/` module with StreamRenderer, StreamLogger, verbosity filter, color palette, banner helpers, and barrel export. All files are new (no existing file modifications).
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-display-claude-console-output-to-parent-node-process-so-users-can-see-whats-happening/03.1-RESEARCH.md
@autopilot/src/logger/index.ts
@autopilot/src/types/config.ts
@autopilot/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create output module foundation (verbosity, colors, banner)</name>
  <files>
    autopilot/package.json
    autopilot/src/output/verbosity.ts
    autopilot/src/output/colors.ts
    autopilot/src/output/banner.ts
    autopilot/src/output/__tests__/verbosity.test.ts
    autopilot/src/output/__tests__/banner.test.ts
  </files>
  <action>
    1. Install dependencies: `cd autopilot && npm install ansis ora`

    2. Create `src/output/verbosity.ts`:
       - Export `type VerbosityLevel = 'default' | 'quiet' | 'verbose'`
       - Export `type MessageCategory = 'content' | 'tool' | 'system' | 'error' | 'result' | 'status'`
       - Export `function shouldDisplay(verbosity: VerbosityLevel, category: MessageCategory): boolean`
         - `quiet`: only 'error' returns true (per user decision: errors and escalations always visible)
         - `default`: everything except 'system' returns true
         - `verbose`: everything returns true
       - Export `function categorizeMessage(messageType: string, subtype?: string): MessageCategory`
         - 'stream_event' -> 'content'
         - 'assistant' -> 'content'
         - 'tool_progress' -> 'tool'
         - 'tool_use_summary' -> 'tool'
         - 'system' with subtype 'init' -> 'system'
         - 'system' with subtype 'status' -> 'status'
         - 'system' with subtype 'task_notification' -> 'tool'
         - 'result' -> 'result'
         - 'auth_status' -> 'system'
         - default -> 'content'

    3. Create `src/output/colors.ts`:
       - Import ansis
       - Export color constants object:
         ```
         export const palette = {
           text: ansis.white,
           tool: ansis.cyan,
           toolName: ansis.bold.cyan,
           system: ansis.dim,
           error: ansis.bold.red,
           warning: ansis.yellow,
           success: ansis.green,
           result: ansis.bold.green,
           dim: ansis.dim,
           banner: ansis.bold.cyan,
         } as const;
         ```
       - Export agent color map for sub-agent prefixes:
         ```
         export const agentColors: Record<string, typeof ansis.cyan> = {
           researcher: ansis.magenta,
           planner: ansis.blue,
           executor: ansis.green,
           checker: ansis.yellow,
           default: ansis.dim,
         };
         ```
       - Export `function getAgentPrefix(agentName: string | null): string` that returns e.g. `ansis.magenta('[researcher] ')` or empty string if null
       - Use `ansis.strip()` -- document that it's available for log output stripping

    4. Create `src/output/banner.ts`:
       - Import ansis
       - Import `palette` from `./colors.js`
       - Export `function renderBanner(title: string, subtitle?: string): string`
         - Uses Unicode box-drawing: top-left U+250C, horizontal U+2500, top-right U+2510, vertical U+2502, bottom-left U+2514, bottom-right U+2518
         - Width = max(title.length, subtitle?.length ?? 0) + 4
         - Format: boxed title with optional subtitle line, colored with palette.banner
         - Check `process.env.WT_SESSION` or use `is-unicode-supported` (ora dep) for Windows fallback to ASCII (+, -, |)
       - Export `function renderPhaseBanner(phase: number | string, step: string): string`
         - Calls renderBanner with title = `Phase ${phase}: ${step}` and subtitle = timestamp (ISO string, date+time only, no ms)

    5. Create tests:
       - `__tests__/verbosity.test.ts`: Test shouldDisplay for all verbosity x category combinations, test categorizeMessage for each message type
       - `__tests__/banner.test.ts`: Test renderBanner produces box-drawn output, test renderPhaseBanner includes phase and step
  </action>
  <verify>
    Run `cd autopilot && npx vitest run src/output/__tests__/verbosity.test.ts src/output/__tests__/banner.test.ts` -- all tests pass.
    Run `cd autopilot && npx tsc --noEmit` -- no type errors.
    Confirm `ansis` and `ora` are in package.json dependencies.
  </verify>
  <done>
    verbosity.ts exports VerbosityLevel, shouldDisplay, categorizeMessage with correct filtering logic.
    colors.ts exports palette object and getAgentPrefix function.
    banner.ts exports renderBanner and renderPhaseBanner with box-drawing characters.
    All tests pass. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create StreamRenderer and StreamLogger</name>
  <files>
    autopilot/src/output/stream-renderer.ts
    autopilot/src/output/stream-logger.ts
    autopilot/src/output/index.ts
    autopilot/src/output/__tests__/stream-renderer.test.ts
    autopilot/src/output/__tests__/stream-logger.test.ts
  </files>
  <action>
    1. Create `src/output/stream-renderer.ts`:
       - Import ora (dynamic import since it's ESM-only: `const { default: ora } = await import('ora')` in constructor or use top-level await)
         NOTE: ora 9.x is ESM-native. Since this project is ESM (`"type": "module"`), use normal `import ora from 'ora'` at top level.
       - Import ansis, palette from colors.js, shouldDisplay/categorizeMessage from verbosity.js, renderPhaseBanner from banner.js, getAgentPrefix from colors.js
       - Export class `StreamRenderer`:
         - Constructor accepts `verbosity: VerbosityLevel` and optional `output: NodeJS.WriteStream` (default: process.stdout) for testability
         - Private fields: `spinner: ReturnType<typeof ora> | null`, `agentMap: Map<string, { name: string }>`, `verbosity`, `output`
         - Public `render(message: unknown): void` -- main dispatch method
           - Extract `type` from message (duck-type: `(message as { type?: string }).type`)
           - Call `categorizeMessage(type, subtype)` to get category
           - If `!shouldDisplay(this.verbosity, category)` AND category is not 'error', return early
           - Switch on type:
             - `'stream_event'`: call `this.renderStreamEvent(message)`
             - `'assistant'`: call `this.renderAssistantMessage(message)`
             - `'system'`: call `this.renderSystemMessage(message)`
             - `'tool_progress'`: call `this.renderToolProgress(message)`
             - `'tool_use_summary'`: call `this.renderToolUseSummary(message)`
             - `'result'`: call `this.renderResult(message)`
             - `'user'`: skip (not displayed)
             - default: skip
         - Private `renderStreamEvent(message: unknown)`:
           - Duck-type: `event = (message as { event?: unknown }).event`
           - If `event.type === 'content_block_start'`:
             - If `event.content_block.type === 'tool_use'`: stop spinner, write `palette.toolName('\n[' + event.content_block.name + '] ')`
             - If `event.content_block.type === 'text'`: stop spinner (text deltas coming)
             - If `event.content_block.name === 'Task'`: track tool_use_id in agentMap, start accumulating input JSON
           - If `event.type === 'content_block_delta'`:
             - If `event.delta.type === 'text_delta'`: stop spinner, determine agent prefix from `message.parent_tool_use_id`, write `prefix + event.delta.text`
             - If `event.delta.type === 'input_json_delta'`: accumulate for Task tool agent identification
           - If `event.type === 'content_block_stop'`: (no-op, cleanup)
           - If `event.type === 'message_start'` or `'message_stop'`: no-op
         - Private `renderAssistantMessage(message: unknown)`:
           - Duck-type: `msg = (message as { message?: { content?: unknown[] } }).message`
           - Iterate content blocks: if block.type === 'text', write text; if 'tool_use', write tool name
           - Prepend agent prefix if `message.parent_tool_use_id` is in agentMap
         - Private `renderSystemMessage(message: unknown)`:
           - Only shown in verbose mode (already filtered by shouldDisplay)
           - Duck-type subtype: if 'init', write dim session info; if 'task_notification', write task status; if 'status', write status
         - Private `renderToolProgress(message: unknown)`:
           - Duck-type: `content = (message as { content?: string }).content`
           - Update spinner text if spinner is active, otherwise write content
         - Private `renderToolUseSummary(message: unknown)`:
           - Duck-type: tool_name, parameters summary
           - Write dim one-liner: `[toolName] params...`
         - Private `renderResult(message: unknown)`:
           - Duck-type for result fields: duration_ms, num_turns, total_cost_usd, usage
           - Stop spinner
           - Display token usage summary per user decision (tokens in/out, cache hits, turns, duration)
           - Use `palette.result` for success, `palette.error` for error results
         - Public `startSpinner(text: string): void` -- starts ora spinner with given text
         - Public `stopSpinner(): void` -- stops spinner if spinning (ALWAYS stop before writing to stdout per Pitfall 1)
         - Public `showBanner(phase: number | string, step: string): void` -- calls renderPhaseBanner and writes to output
         - Private helper: `write(text: string)` wraps `this.output.write(text)`, always stops spinner first
       - All duck-typing uses type guards checking `.type` fields, never importing from `@anthropic-ai/sdk` (per project pattern: SDKResultLike approach)
       - Add comment warning: "When maxThinkingTokens or thinking is set, stream_event messages are not emitted. StreamRenderer gracefully degrades to showing complete assistant messages only."

    2. Create `src/output/stream-logger.ts`:
       - Import pino, join from node:path, ansis
       - Export class `StreamLogger`:
         - Constructor accepts `logDir: string`
         - Creates pino destination to `join(logDir, 'sdk-output.log')` with `{ sync: false }` via `pino.destination()`
         - Creates pino logger at level 'trace' with isoTime timestamps
         - Public `write(message: unknown): void`:
           - For stream_event messages with content_block_delta + text_delta: SKIP (Pitfall 3: accumulate, don't log every delta)
           - For all other messages: `logger.info({ sdkMessage: message }, 'sdk-message')`
           - Always writes regardless of verbosity (per user decision: log file always captures full raw output)
         - Public `async flush(): Promise<void>`:
           - Uses same ready-then-flushSync pattern from AutopilotLogger
         - Private `isTextDelta(message: unknown): boolean`:
           - Duck-type check: message.type === 'stream_event' && message.event?.type === 'content_block_delta' && message.event?.delta?.type === 'text_delta'

    3. Create `src/output/index.ts`:
       - Barrel export:
         ```
         export { StreamRenderer } from './stream-renderer.js';
         export { StreamLogger } from './stream-logger.js';
         export type { VerbosityLevel, MessageCategory } from './verbosity.js';
         export { shouldDisplay, categorizeMessage } from './verbosity.js';
         export { palette, agentColors, getAgentPrefix } from './colors.js';
         export { renderBanner, renderPhaseBanner } from './banner.js';
         ```

    4. Create tests:
       - `__tests__/stream-renderer.test.ts`:
         - Create a mock writable stream (array-backed: captures written strings)
         - Test: render stream_event with text_delta writes text to output
         - Test: render stream_event with content_block_start for tool_use writes tool name
         - Test: quiet mode suppresses non-error content
         - Test: quiet mode still shows error results
         - Test: verbose mode shows system init messages
         - Test: showBanner writes phase/step banner
         - Test: spinner stops before text output (verify no interleaving)
         - Test: result message shows token usage summary
         - Test: sub-agent messages get agent prefix when parent_tool_use_id tracked
       - `__tests__/stream-logger.test.ts`:
         - Use a temp directory for log output
         - Test: write() persists message to sdk-output.log as JSON
         - Test: text_delta messages are NOT logged individually (Pitfall 3 prevention)
         - Test: non-delta messages ARE logged
         - Test: flush() completes without error
         - Clean up temp dir after tests
  </action>
  <verify>
    Run `cd autopilot && npx vitest run src/output/` -- all output module tests pass.
    Run `cd autopilot && npx tsc --noEmit` -- no type errors.
    Run `cd autopilot && npx vitest run` -- all 334+ existing tests still pass plus new output tests.
  </verify>
  <done>
    StreamRenderer accepts SDKMessage objects and renders formatted output to a writable stream, respecting verbosity levels.
    StreamLogger writes raw JSON messages to sdk-output.log, skipping individual text deltas to prevent log bloat.
    Barrel export makes all output module components available.
    All tests pass. No regressions in existing test suite.
  </done>
</task>

</tasks>

<verification>
- `cd autopilot && npx vitest run src/output/` passes all new tests
- `cd autopilot && npx tsc --noEmit` compiles without errors
- `cd autopilot && npx vitest run` shows 334+ existing tests still passing plus all new output tests
- `ls autopilot/src/output/` shows: verbosity.ts, colors.ts, banner.ts, stream-renderer.ts, stream-logger.ts, index.ts
- `ansis` and `ora` present in autopilot/package.json dependencies
</verification>

<success_criteria>
- Output module (`src/output/`) exists with all 6 source files and 4 test files
- StreamRenderer dispatches all SDKMessage types through type-specific handlers
- StreamRenderer verbosity filtering: quiet = errors only, default = all content, verbose = includes system
- StreamLogger writes raw JSON to sdk-output.log, skips text_delta messages
- All tests pass including existing 334+ tests (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-display-claude-console-output-to-parent-node-process-so-users-can-see-whats-happening/03.1-01-SUMMARY.md`
</output>
