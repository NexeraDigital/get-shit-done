---
phase: 03.1-display-claude-console-output
plan: 02
type: execute
wave: 2
depends_on: ["03.1-01"]
files_modified:
  - autopilot/src/claude/index.ts
  - autopilot/src/cli/index.ts
  - autopilot/src/index.ts
  - autopilot/src/claude/__tests__/claude-service.test.ts
autonomous: true

must_haves:
  truths:
    - "ClaudeService emits 'message' event for every SDK message in the for-await loop"
    - "ClaudeService passes includePartialMessages: true to SDK query options"
    - "CLI wires StreamRenderer and StreamLogger to ClaudeService message events"
    - "CLI passes verbosity level from config to StreamRenderer"
    - "StreamLogger always receives messages regardless of verbosity"
    - "Package entry point exports StreamRenderer, StreamLogger, and VerbosityLevel"
  artifacts:
    - path: "autopilot/src/claude/index.ts"
      provides: "ClaudeService with message event emission and includePartialMessages"
      contains: "includePartialMessages"
    - path: "autopilot/src/cli/index.ts"
      provides: "CLI bootstrap wiring StreamRenderer and StreamLogger to ClaudeService"
      contains: "StreamRenderer"
    - path: "autopilot/src/index.ts"
      provides: "Package entry point with output module exports"
      contains: "StreamRenderer"
  key_links:
    - from: "autopilot/src/claude/index.ts"
      to: "autopilot/src/output/stream-renderer.ts"
      via: "EventEmitter 'message' event consumed in CLI"
      pattern: "this\\.emit\\('message'"
    - from: "autopilot/src/cli/index.ts"
      to: "autopilot/src/output/index.ts"
      via: "import StreamRenderer, StreamLogger"
      pattern: "import.*output"
    - from: "autopilot/src/cli/index.ts"
      to: "autopilot/src/claude/index.ts"
      via: "claudeService.on('message', ...)"
      pattern: "claudeService\\.on\\('message'"
---

<objective>
Wire the output module into ClaudeService and the CLI, enabling real-time SDK message streaming to terminal and log file.

Purpose: Plan 01 built the rendering/logging infrastructure. This plan connects it to the actual SDK message stream by modifying ClaudeService to emit messages and updating the CLI to listen and route messages to StreamRenderer (terminal) and StreamLogger (log file). This completes the phase -- after this plan, users see real-time output when running the autopilot.

Output: Modified ClaudeService emitting all SDK messages, CLI bootstrap wiring renderer+logger, updated package exports.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-display-claude-console-output-to-parent-node-process-so-users-can-see-whats-happening/03.1-RESEARCH.md
@.planning/phases/03.1-display-claude-console-output-to-parent-node-process-so-users-can-see-whats-happening/03.1-01-SUMMARY.md
@autopilot/src/claude/index.ts
@autopilot/src/cli/index.ts
@autopilot/src/index.ts
@autopilot/src/output/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add message emission and includePartialMessages to ClaudeService</name>
  <files>
    autopilot/src/claude/index.ts
    autopilot/src/claude/__tests__/claude-service.test.ts
  </files>
  <action>
    1. Modify `src/claude/index.ts` -- ClaudeService.runGsdCommand():
       - In the `query()` call options, add `includePartialMessages: true` alongside existing options
       - Add a code comment above it: `// Enable streaming partial messages for real-time terminal output. WARNING: If thinking/maxThinkingTokens is set, stream_event messages are NOT emitted (SDK limitation).`
       - Inside the for-await loop, BEFORE the existing `if (message.type === 'system')` check, add: `this.emit('message', message);`
       - This emits EVERY message including system, assistant, stream_event, tool_progress, result, etc.
       - Do NOT modify ANY existing logic -- the session_id capture and result parsing remain unchanged
       - The `'message'` event is the integration point: external consumers (StreamRenderer, StreamLogger) listen on this event

    2. Add JSDoc to the class events list:
       ```
       * Events:
       * - 'message' -> SDKMessage (every message from the SDK stream -- for StreamRenderer/StreamLogger)
       * - 'question:pending' -> QuestionEvent (forwarded from QuestionHandler)
       * - 'question:answered' -> { id: string, answers: Record<string, string> }
       ```

    3. Update existing tests in `__tests__/claude-service.test.ts`:
       - Add test: "runGsdCommand emits 'message' event for each SDK message"
         - Set up a message listener: `const messages: unknown[] = []; service.on('message', (m) => messages.push(m));`
         - Mock query to yield init + result messages
         - After runGsdCommand completes, verify `messages.length === 2` (init + result)
         - Verify `messages[0]` has type 'system' and `messages[1]` has type 'result'
       - Add test: "runGsdCommand passes includePartialMessages: true to query options"
         - After calling runGsdCommand, inspect `mockQueryFn.mock.calls[0][0].options.includePartialMessages`
         - Expect it to be `true`
       - Update existing test 3 ("passes correct options to query") to also check `callArgs.options.includePartialMessages === true`
       - All existing tests should continue passing unchanged (the emit is additive)
  </action>
  <verify>
    Run `cd autopilot && npx vitest run src/claude/__tests__/claude-service.test.ts` -- all tests pass (existing + 2 new).
    Run `cd autopilot && npx tsc --noEmit` -- no type errors.
  </verify>
  <done>
    ClaudeService emits 'message' for every SDK message in the for-await loop.
    includePartialMessages: true is passed to SDK query options.
    All existing ClaudeService tests pass. Two new tests verify message emission and includePartialMessages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire StreamRenderer and StreamLogger into CLI bootstrap and update package exports</name>
  <files>
    autopilot/src/cli/index.ts
    autopilot/src/index.ts
  </files>
  <action>
    1. Modify `src/cli/index.ts`:
       - Add imports at top:
         ```typescript
         import { StreamRenderer } from '../output/index.js';
         import { StreamLogger } from '../output/index.js';
         import type { VerbosityLevel } from '../output/index.js';
         ```
         (Or combine into one import from '../output/index.js')

       - After the `const logger = new AutopilotLogger(...)` line (section d), add:
         ```typescript
         // e. Determine verbosity level from config
         const verbosity: VerbosityLevel = config.quiet ? 'quiet' : config.verbose ? 'verbose' : 'default';

         // f. Create output streaming components
         const streamRenderer = new StreamRenderer(verbosity);
         const streamLogger = new StreamLogger(join(projectDir, '.planning', 'autopilot-log'));
         ```

       - After `const claudeService = new ClaudeService(...)` line, add wiring:
         ```typescript
         // Wire SDK message stream to terminal renderer and log file (dual output per user decision)
         claudeService.on('message', (message: unknown) => {
           streamRenderer.render(message);
           streamLogger.write(message);
         });
         ```

       - In the orchestrator event listeners section, wire phase/step banners.
         After creating the orchestrator, before the shutdown manager:
         ```typescript
         // Wire phase/step banners to StreamRenderer
         orchestrator.on('phase:started', ({ phase, name }: { phase: number; name: string }) => {
           streamRenderer.showBanner(phase, `Starting: ${name}`);
         });
         orchestrator.on('step:started', ({ phase, step }: { phase: number; step: string }) => {
           streamRenderer.startSpinner(`Phase ${phase}: ${step}...`);
         });
         orchestrator.on('step:completed', () => {
           streamRenderer.stopSpinner();
         });
         orchestrator.on('build:complete', () => {
           streamRenderer.stopSpinner();
         });
         ```

       - In the shutdown manager section, register streamLogger flush:
         ```typescript
         shutdown.register(async () => {
           await streamLogger.flush();
         });
         ```
         (Add this BEFORE the existing logger flush registration so SDK logs flush first)

       - Update the catch block: when an error occurs and !options.quiet, also call `streamRenderer.stopSpinner()` before console.error to avoid garbled output

       - Re-letter the comment sections (// e, // f, // g...) to account for the new steps inserted

    2. Modify `src/index.ts` -- add output module exports:
       - Add after the existing orchestrator exports:
         ```typescript
         export { StreamRenderer } from './output/index.js';
         export { StreamLogger } from './output/index.js';
         export type { VerbosityLevel, MessageCategory } from './output/index.js';
         export { renderBanner, renderPhaseBanner } from './output/index.js';
         ```
       (Use `export type` for type-only exports per verbatimModuleSyntax convention)
  </action>
  <verify>
    Run `cd autopilot && npx tsc --noEmit` -- no type errors (confirms wiring is correct).
    Run `cd autopilot && npx vitest run` -- ALL tests pass (existing 334+ plus all new output tests plus updated ClaudeService tests).
    Run `cd autopilot && node -e "import('@gsd/autopilot').then(m => { console.log(typeof m.StreamRenderer); console.log(typeof m.StreamLogger); })"` from the dist directory (after build) to verify exports work. Alternatively, just confirm `tsc --noEmit` passes which validates the import chain.
  </verify>
  <done>
    CLI creates StreamRenderer with correct verbosity from config (quiet/verbose/default).
    CLI creates StreamLogger writing to .planning/autopilot-log/sdk-output.log.
    ClaudeService 'message' events are routed to both StreamRenderer and StreamLogger.
    Phase/step events from Orchestrator trigger banner display and spinner lifecycle.
    StreamLogger flush is registered in ShutdownManager.
    Package entry point exports StreamRenderer, StreamLogger, VerbosityLevel.
    All tests pass with no regressions.
  </done>
</task>

</tasks>

<verification>
- `cd autopilot && npx vitest run` -- all tests pass (existing + new)
- `cd autopilot && npx tsc --noEmit` -- clean compile
- ClaudeService.runGsdCommand for-await loop contains `this.emit('message', message)` BEFORE existing session/result handling
- ClaudeService query options contain `includePartialMessages: true`
- CLI imports and instantiates StreamRenderer and StreamLogger
- CLI wires `claudeService.on('message', ...)` to both renderer and logger
- CLI wires orchestrator phase/step events to banner display and spinner
- Package index.ts exports StreamRenderer, StreamLogger, VerbosityLevel
</verification>

<success_criteria>
- ClaudeService emits every SDK message via 'message' event
- CLI routes messages to terminal (formatted via StreamRenderer) and log file (raw via StreamLogger)
- Verbosity from --quiet/--verbose config flags controls terminal output filtering
- Phase/step transitions show banner headers in terminal
- Spinner shows during command execution, stops on content arrival
- StreamLogger flush registered in shutdown manager for graceful cleanup
- All tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-display-claude-console-output-to-parent-node-process-so-users-can-see-whats-happening/03.1-02-SUMMARY.md`
</output>
