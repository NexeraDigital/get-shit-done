# Phase 03.1: Display Claude Console Output to Parent Process - Research

**Researched:** 2026-02-16
**Domain:** SDK message streaming, terminal formatting, dual-output (terminal + log file)
**Confidence:** HIGH

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- Default: show everything -- full Claude conversation including assistant text, tool calls, and tool results
- Sub-agent output (researchers, planner, executor spawned via Task): stream nested output with visible agent identification
- Full content for large file reads/writes -- no truncation, user scrolls if needed
- Two verbosity tiers: --quiet = errors/escalations only, default = full output
- Rich formatting: spinners for active operations, boxed banner headers for phase/step transitions, color-coded message types
- Sub-agent nesting: color-coded prefix per agent type (e.g., [researcher], [planner]) -- no indentation, color differentiation only
- Phase/step transitions: banner-style separators with phase name, step, and timestamp
- Live spinner with context while waiting for SDK responses (e.g., "Executing: /gsd:plan-phase 2" or "Claude is thinking...")
- SDK system messages (init, session ID, metadata): hidden by default, shown only with --verbose
- Retry attempts: visually distinct with yellow/warning styling showing retry count
- Quota usage: show remaining quota (not cost -- subscription model). Display after each command completes
- Errors and escalations always visible regardless of verbosity tier
- Dual output: stream to both terminal (formatted) and log file (raw)
- Log file: raw SDK messages without ANSI colors -- machine-readable JSON/text for debugging
- Separate log file (e.g., sdk-output.log) alongside autopilot.log -- keeps orchestrator logs clean
- --quiet suppresses terminal streaming to errors only; log file always captures full raw output

### Claude's Discretion
- Exact spinner implementation and animation style
- Color palette for message types and agent prefixes
- Banner header box-drawing characters and layout
- How to surface remaining quota from SDK response metadata

### Deferred Ideas (OUT OF SCOPE)
None -- discussion stayed within phase scope
</user_constraints>

## Summary

This phase adds real-time streaming of Claude Agent SDK output to the terminal, transforming the autopilot from a silent runner into a transparent tool where users can see exactly what Claude is doing. The core technical challenge is threefold: (1) enabling `includePartialMessages` on the SDK `query()` call to receive `stream_event` messages alongside the existing `system`, `assistant`, `tool_progress`, `task_notification`, and `result` message types; (2) building a formatter that routes each message type to appropriate terminal output with rich formatting (colors, spinners, banners); and (3) simultaneously writing raw unformatted messages to a separate log file for debugging.

The existing `ClaudeService.runGsdCommand()` iterates the `query()` async generator but only handles `system.init` and `result` messages. All other messages are silently dropped. This phase needs to process every message type in the `SDKMessage` union while keeping the existing result-parsing logic intact. The SDK's `includePartialMessages: true` option adds `SDKPartialAssistantMessage` (type `stream_event`) events containing raw Anthropic API streaming events (`content_block_start`, `content_block_delta`, `content_block_stop`, `message_start`, `message_delta`, `message_stop`), enabling real-time text streaming and tool call tracking.

A critical limitation: when `maxThinkingTokens` or `thinking` is explicitly set, `StreamEvent` messages are NOT emitted -- the SDK falls back to complete messages only. The current codebase does NOT set these options, so streaming works by default. This must be documented and guarded against future changes.

**Primary recommendation:** Enable `includePartialMessages: true` on the SDK query, build a `StreamRenderer` class that accepts an `SDKMessage` and routes it to the appropriate terminal formatter, and create a parallel `StreamLogger` that writes raw JSON to `sdk-output.log`. Inject both into `ClaudeService` via a message callback/event pattern.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `@anthropic-ai/claude-agent-sdk` | ^0.2.42 | SDK message stream source | Already in project; provides the `SDKMessage` union and `includePartialMessages` option |
| `ansis` | ^4.2.0 | Terminal colors and ANSI strip | ESM+CJS dual, zero deps, smallest/fastest color lib; has built-in `strip()` for log file output |
| `ora` | ^9.3.0 | Terminal spinner | ESM-native, Node >= 20, widely used; handles cursor hiding, TTY detection, animation |
| `pino` | ^10.3.0 | Raw SDK log persistence | Already in project for structured logging; use separate destination for sdk-output.log |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `cli-spinners` | ^3.2.0 | Spinner animation styles | Bundled with ora; use `dots` or `dots2` for the default spinner style |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| ansis | chalk 5.6.2 | chalk is ESM-only, larger, and ora already depends on chalk -- but ansis is lighter and has built-in `strip()`. Recommendation: use ansis for our code; ora brings its own chalk internally |
| ora | Custom setInterval spinner | ora handles TTY detection, Windows Terminal compatibility, cursor management -- hand-rolling is error-prone |
| pino (for sdk-output.log) | fs.createWriteStream | pino already handles async buffered writes with SonicBoom; reuse existing pattern |

**Installation:**
```bash
npm install ansis ora
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── claude/
│   ├── index.ts              # ClaudeService (modify: add includePartialMessages, emit messages)
│   ├── types.ts              # Add StreamMessage event type
│   └── ...
├── output/
│   ├── index.ts              # Barrel export
│   ├── stream-renderer.ts    # Terminal formatter: routes SDKMessage -> formatted console output
│   ├── stream-logger.ts      # Raw log writer: SDKMessage -> JSON lines in sdk-output.log
│   ├── banner.ts             # Phase/step banner box-drawing helpers
│   ├── colors.ts             # Color palette constants and agent prefix colors
│   └── verbosity.ts          # Verbosity filter: decides what passes through per --verbose/--quiet
└── ...
```

### Pattern 1: Message Callback on ClaudeService
**What:** Instead of processing all message types inside ClaudeService's for-await loop, emit each message via an EventEmitter event or a callback. The ClaudeService remains focused on SDK interaction; rendering is external.
**When to use:** Always -- this keeps ClaudeService testable and decoupled from terminal I/O.
**Example:**
```typescript
// Source: Architecture pattern derived from existing EventEmitter pattern in ClaudeService
// ClaudeService already extends EventEmitter for question:pending events

// In ClaudeService.runGsdCommand(), inside the for-await loop:
for await (const message of query({
  prompt,
  options: {
    ...existingOptions,
    includePartialMessages: true,
  },
})) {
  // Emit every message for external consumers (renderer, logger)
  this.emit('message', message);

  // Existing logic for session_id and result
  if (message.type === 'system' && 'subtype' in message && message.subtype === 'init') {
    sessionId = message.session_id;
  }
  if (message.type === 'result') {
    return parseResult(message, sessionId, startTimeMs);
  }
}
```

### Pattern 2: StreamRenderer with Message Type Routing
**What:** A class that receives SDKMessage objects and renders them to stdout with formatting based on message type. Uses a switch/map on `message.type` to dispatch to type-specific formatters.
**When to use:** For all terminal output from SDK messages.
**Example:**
```typescript
// Source: Derived from SDK type definitions in sdk.d.ts

import ansis from 'ansis';
import type { SDKMessage } from './types.js';

type VerbosityLevel = 'default' | 'quiet' | 'verbose';

class StreamRenderer {
  private verbosity: VerbosityLevel;
  private spinner: Ora | null = null;

  constructor(verbosity: VerbosityLevel) {
    this.verbosity = verbosity;
  }

  render(message: SDKMessage): void {
    switch (message.type) {
      case 'stream_event':
        this.renderStreamEvent(message);
        break;
      case 'assistant':
        this.renderAssistantMessage(message);
        break;
      case 'system':
        this.renderSystemMessage(message);
        break;
      case 'tool_progress':
        this.renderToolProgress(message);
        break;
      case 'tool_use_summary':
        this.renderToolUseSummary(message);
        break;
      case 'result':
        this.renderResult(message);
        break;
      // user, user (replay) -- typically not displayed
      default:
        break;
    }
  }
}
```

### Pattern 3: Sub-Agent Identification via parent_tool_use_id
**What:** SDK messages from sub-agents (Task tool) include a non-null `parent_tool_use_id`. Use this to track nesting and apply agent-specific color prefixes.
**When to use:** For all messages where `parent_tool_use_id !== null`.
**Example:**
```typescript
// Source: SDK type SDKAssistantMessage has parent_tool_use_id: string | null
// SDKPartialAssistantMessage also has parent_tool_use_id: string | null
// SDKTaskNotificationMessage provides task_id and summary

// Track active agents by tool_use_id
const agentMap = new Map<string, { name: string; color: typeof ansis.cyan }>();

function getAgentPrefix(parentToolUseId: string | null): string {
  if (!parentToolUseId) return '';
  const agent = agentMap.get(parentToolUseId);
  if (!agent) return ansis.dim(`[agent] `);
  return agent.color(`[${agent.name}] `);
}
```

### Pattern 4: Dual Output via Tee
**What:** Every message goes to both StreamRenderer (formatted, to terminal) and StreamLogger (raw JSON, to file). The StreamLogger strips ANSI before writing using `ansis.strip()`.
**When to use:** Always -- log file always captures everything regardless of verbosity.
**Example:**
```typescript
// In CLI setup or Orchestrator:
claudeService.on('message', (message: SDKMessage) => {
  // Terminal: respects verbosity
  streamRenderer.render(message);
  // Log file: always writes everything, raw JSON
  streamLogger.write(message);
});
```

### Pattern 5: Spinner Lifecycle Management
**What:** Start a spinner when waiting for SDK response, stop it when a content_block_start or text_delta arrives. Spinner text shows current context (e.g., "Executing: /gsd:plan-phase 2").
**When to use:** Between prompt submission and first streaming content.
**Example:**
```typescript
import ora from 'ora';

// Start spinner when command begins
const spinner = ora({
  text: `Executing: ${prompt}`,
  spinner: 'dots',
}).start();

// On first stream_event with content, stop spinner
function onFirstContent() {
  if (spinner.isSpinning) {
    spinner.stop();
  }
}
```

### Anti-Patterns to Avoid
- **Processing messages inside ClaudeService:** Don't add rendering logic to ClaudeService -- it should only handle SDK interaction. Use events/callbacks.
- **Synchronous file writes for log:** Don't use `fs.writeFileSync` for the SDK log -- it blocks the event loop during streaming. Use pino/SonicBoom or async streams.
- **Accumulating all messages in memory:** Don't buffer the entire conversation -- stream through. The log file handles persistence.
- **Ignoring TTY detection:** Don't assume the terminal supports colors/spinners. Ora handles this, but the renderer should also check `process.stdout.isTTY` before writing ANSI.
- **Mixing spinner output with streaming text:** Always stop the spinner before writing streaming content to avoid garbled output. Ora's `stop()` clears the spinner line.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Terminal spinners | Custom setInterval + cursor manipulation | ora 9.3.0 | Handles TTY detection, Windows Terminal, cursor hiding, graceful cleanup on process exit |
| ANSI color codes | Manual `\x1b[31m` escape sequences | ansis 4.2.0 | Auto-detects color support, provides `strip()` for log output, handles 256/truecolor fallback |
| ANSI stripping | Regex to remove escape codes | ansis.strip() | Built into ansis; handles all edge cases including 256-color and truecolor sequences |
| Async file writing | fs.appendFile in a loop | pino.destination() | Already in project; SonicBoom handles buffered async writes without blocking event loop |
| Box-drawing/banners | Complex string padding logic | Simple template with Unicode box chars | Keep it simple -- a few template literal helpers, not a library |

**Key insight:** The terminal formatting libraries handle edge cases (Windows Terminal, non-TTY pipes, color level detection) that are tedious and error-prone to implement manually. The rendering logic itself is custom but the primitives should be library-backed.

## Common Pitfalls

### Pitfall 1: Spinner + Streaming Text Collision
**What goes wrong:** Ora spinner is animating on one line while streaming text writes to stdout, causing garbled overlapping output.
**Why it happens:** Ora uses `process.stderr` by default but can conflict with `process.stdout` writes when both are writing to the same terminal.
**How to avoid:** Always call `spinner.stop()` or `spinner.clear()` before any `process.stdout.write()` call. After streaming text completes (e.g., between tool calls), restart the spinner.
**Warning signs:** Spinner animation characters appearing in the middle of assistant text.

### Pitfall 2: Extended Thinking Disables Streaming
**What goes wrong:** If someone adds `maxThinkingTokens` or `thinking: { type: 'enabled', budgetTokens: N }` to the query options, `stream_event` messages stop being emitted entirely. The code falls back to only receiving complete `assistant` messages.
**Why it happens:** This is a documented SDK limitation -- streaming partial messages and extended thinking are incompatible.
**How to avoid:** Add a code comment and runtime guard. If thinking is enabled, the renderer should gracefully degrade to showing complete assistant messages instead of streaming text character by character.
**Warning signs:** No `stream_event` messages appearing when `includePartialMessages` is true.

### Pitfall 3: Log File Growing Unbounded
**What goes wrong:** SDK-output.log grows to gigabytes during long runs because every message (including streaming deltas) is logged.
**Why it happens:** A single command may produce thousands of `content_block_delta` events.
**How to avoid:** For streaming deltas (`content_block_delta` with `text_delta`), accumulate text and log the complete content block on `content_block_stop` instead of logging every delta. Log the full assistant message from the complete `SDKAssistantMessage` instead of reconstructing from deltas.
**Warning signs:** SDK log file growing much faster than expected; log file larger than the actual output.

### Pitfall 4: Quiet Mode Still Writing to Stdout
**What goes wrong:** `--quiet` flag is set but non-error output still appears because the renderer isn't checking verbosity for all code paths.
**Why it happens:** Forgetting to check verbosity in one of the many message type handlers.
**How to avoid:** Put the verbosity check at the top of the `render()` method with a filter function. Errors and escalations bypass the filter; everything else is gated by verbosity level.
**Warning signs:** Console output appearing when `--quiet` is passed.

### Pitfall 5: parent_tool_use_id Not Tracking Agent Names
**What goes wrong:** Sub-agent output shows generic "[agent]" prefix instead of "[researcher]" or "[planner]" because the agent name wasn't captured from the task creation.
**Why it happens:** The `SDKTaskNotificationMessage` (with `status: 'completed'/'failed'`) arrives after the agent finishes, not when it starts. Agent identification needs to come from the `content_block_start` event for `tool_use` blocks where `name === 'Task'` and from the `SDKToolProgressMessage`.
**How to avoid:** When a `content_block_start` with `tool_use` type and name `Task` is detected, capture the `tool_use_id` and parse the agent type from the accumulated `input_json_delta`. Also use `SDKToolProgressMessage.tool_name` for active tool identification.
**Warning signs:** All sub-agent output showing the same generic color/prefix.

### Pitfall 6: Windows Terminal Unicode Issues
**What goes wrong:** Box-drawing characters for banners render as question marks or boxes on some Windows terminals.
**Why it happens:** Older Windows console (cmd.exe) doesn't support Unicode well; Windows Terminal does.
**How to avoid:** Use `is-unicode-supported` (ora already depends on it) or check `process.env.WT_SESSION` for Windows Terminal. Fall back to ASCII box-drawing characters (`+`, `-`, `|`) if Unicode is not supported.
**Warning signs:** Garbled banner headers on Windows.

## Code Examples

Verified patterns from official sources:

### Enabling Streaming in ClaudeService
```typescript
// Source: https://platform.claude.com/docs/en/agent-sdk/streaming-output
// Modify the existing query() call in ClaudeService.runGsdCommand()

for await (const message of query({
  prompt,
  options: {
    cwd: options?.cwd ?? this.defaultCwd ?? process.cwd(),
    // ... existing options ...
    includePartialMessages: true, // NEW: enables stream_event messages
    abortController: controller,
    canUseTool: this.createCanUseTool(),
  },
})) {
  // NEW: emit every message for external rendering/logging
  this.emit('message', message);

  // Existing session ID capture
  if (message.type === 'system' && 'subtype' in message && message.subtype === 'init') {
    sessionId = message.session_id;
  }

  // Existing result handling
  if (message.type === 'result') {
    return parseResult(message, sessionId, startTimeMs);
  }
}
```

### Streaming Text Deltas
```typescript
// Source: https://platform.claude.com/docs/en/agent-sdk/streaming-output
// TypeScript example from official docs, adapted for our renderer

if (message.type === 'stream_event') {
  const event = message.event;

  if (event.type === 'content_block_start') {
    if (event.content_block.type === 'tool_use') {
      // Tool call starting
      const toolName = event.content_block.name;
      stopSpinner();
      process.stdout.write(ansis.cyan(`\n[${toolName}] `));
    }
  } else if (event.type === 'content_block_delta') {
    if (event.delta.type === 'text_delta') {
      stopSpinner();
      process.stdout.write(event.delta.text);
    }
  } else if (event.type === 'content_block_stop') {
    // Content block finished
  }
}
```

### Complete SDKMessage Type Handler Map
```typescript
// Source: SDK type definitions from sdk.d.ts (locally verified)
// SDKMessage = SDKAssistantMessage | SDKUserMessage | SDKUserMessageReplay
//            | SDKResultMessage | SDKSystemMessage | SDKPartialAssistantMessage
//            | SDKCompactBoundaryMessage | SDKStatusMessage | SDKHookStartedMessage
//            | SDKHookProgressMessage | SDKHookResponseMessage | SDKToolProgressMessage
//            | SDKAuthStatusMessage | SDKTaskNotificationMessage
//            | SDKFilesPersistedEvent | SDKToolUseSummaryMessage

// Full union from sdk.d.ts line 1476:
// Discriminated by message.type field:
//   'assistant'        -> SDKAssistantMessage (complete assistant response with BetaMessage)
//   'user'             -> SDKUserMessage | SDKUserMessageReplay
//   'result'           -> SDKResultMessage (SDKResultSuccess | SDKResultError)
//   'system'           -> SDKSystemMessage (subtype: 'init')
//                       | SDKCompactBoundaryMessage (subtype: 'compact_boundary')
//                       | SDKStatusMessage (subtype: 'status')
//                       | SDKHookStartedMessage (subtype: 'hook_started')
//                       | SDKHookProgressMessage (subtype: 'hook_progress')
//                       | SDKHookResponseMessage (subtype: 'hook_response')
//                       | SDKTaskNotificationMessage (subtype: 'task_notification')
//                       | SDKFilesPersistedEvent (subtype: 'files_persisted')
//   'stream_event'     -> SDKPartialAssistantMessage (only with includePartialMessages)
//   'tool_progress'    -> SDKToolProgressMessage
//   'tool_use_summary' -> SDKToolUseSummaryMessage
//   'auth_status'      -> SDKAuthStatusMessage
```

### Banner Box Helper
```typescript
// Custom helper for phase/step banners

import ansis from 'ansis';

function renderBanner(title: string, subtitle?: string): string {
  const width = Math.max(title.length, subtitle?.length ?? 0) + 4;
  const top = `\u250C${'─'.repeat(width)}\u2510`;
  const mid = `\u2502 ${title.padEnd(width - 2)} \u2502`;
  const sub = subtitle
    ? `\u2502 ${ansis.dim(subtitle.padEnd(width - 2))} \u2502`
    : '';
  const bot = `\u2514${'─'.repeat(width)}\u2518`;

  return ansis.bold.cyan(
    [top, mid, sub, bot].filter(Boolean).join('\n')
  );
}

// Usage:
// renderBanner('Phase 2: Core Orchestrator', 'Step: plan | 2026-02-16 14:30')
```

### Raw Log Writer with ANSI Stripping
```typescript
// Using pino for structured, async log output

import pino from 'pino';
import ansis from 'ansis';
import { join } from 'node:path';

function createSdkLogger(logDir: string) {
  const dest = pino.destination({
    dest: join(logDir, 'sdk-output.log'),
    sync: false,
  });

  const logger = pino({ level: 'trace', timestamp: pino.stdTimeFunctions.isoTime }, dest);

  return {
    write(message: unknown): void {
      // Log raw message as JSON -- pino handles serialization
      logger.info({ sdkMessage: message }, 'sdk-message');
    },
    async flush(): Promise<void> {
      // SonicBoom flush
      dest.flushSync();
    },
  };
}
```

### Quota Display from SDK Result
```typescript
// Source: SDK types SDKResultSuccess.modelUsage and AccountInfo

// SDKResultSuccess has:
//   modelUsage: Record<string, ModelUsage>
//   where ModelUsage = { inputTokens, outputTokens, cacheReadInputTokens,
//                        cacheCreationInputTokens, webSearchRequests, costUSD,
//                        contextWindow, maxOutputTokens }

// AccountInfo (from query.accountInfo()) has:
//   subscriptionType?: string  (e.g., 'max_5', 'pro', 'team')

// For subscription-based quota: the SDK does not directly expose "remaining quota"
// The best available data is:
// 1. total_cost_usd from SDKResultMessage (cumulative cost for the command)
// 2. modelUsage with per-model token breakdown
// 3. AccountInfo.subscriptionType for plan identification

// Display after each command:
function renderQuotaInfo(result: SDKResultSuccess): string {
  const totalTokensIn = result.usage.input_tokens;
  const totalTokensOut = result.usage.output_tokens;
  const cacheRead = result.usage.cache_read_input_tokens ?? 0;
  return ansis.dim(
    `Tokens: ${totalTokensIn} in / ${totalTokensOut} out` +
    (cacheRead > 0 ? ` (${cacheRead} cached)` : '') +
    ` | ${result.num_turns} turns | ${(result.duration_ms / 1000).toFixed(1)}s`
  );
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `chalk` for colors | `ansis` (lighter, built-in strip) | 2024-2025 | Fewer deps, faster, built-in ANSI stripping |
| `chalk` 4.x CJS | `chalk` 5.x ESM-only | Aug 2021 | Must use ESM; ansis avoids this concern with dual export |
| Custom spinner loops | `ora` 9.x | Stable since 2023 | Handles TTY, Windows, cursor management |
| `SDKMessage` without streaming | `includePartialMessages: true` | SDK 0.2.x | Enables real-time text streaming; requires handling `stream_event` type |
| `thinking` option types | `{ type: 'adaptive' }` for Opus 4.6 | SDK 0.2.42 | Adaptive thinking is default for Opus 4.6; setting it explicitly may disable streaming |

**Deprecated/outdated:**
- `maxThinkingTokens` option: deprecated in favor of `thinking: { type: 'adaptive' | 'enabled' | 'disabled' }`. On Opus 4.6, treated as on/off toggle.
- `@types/ora`: not needed since ora 5+ includes TypeScript definitions natively.

## Open Questions

1. **Remaining Quota from SDK**
   - What we know: `AccountInfo` has `subscriptionType` but no `remainingQuota` field. `SDKResultMessage` has `total_cost_usd` and `modelUsage` with token counts. There is no SDK API to query remaining subscription quota directly.
   - What's unclear: Whether Anthropic plans to add a quota endpoint, or if there's an undocumented field we're missing.
   - Recommendation: Display token usage and cumulative cost as a proxy. Show `subscriptionType` once at session start. Log a note that direct quota remaining is not available from the SDK. If a quota API becomes available, it can be added later.

2. **BetaMessage Content Block Types for Assistant Messages**
   - What we know: `SDKAssistantMessage.message` is a `BetaMessage` from `@anthropic-ai/sdk`. Its `content` array contains blocks with types: `text` (with `text` field), `tool_use` (with `id`, `name`, `input` fields), `thinking` (with `thinking` field), and `redacted_thinking`.
   - What's unclear: The exact TypeScript type imports needed since `@anthropic-ai/sdk` is not a direct dependency (it's a transitive dep of the agent SDK).
   - Recommendation: Duck-type the content blocks using type guards checking `block.type === 'text'` etc., similar to the existing `SDKResultLike` pattern in result-parser.ts. Avoid importing from `@anthropic-ai/sdk` directly.

3. **Sub-Agent Name Discovery Timing**
   - What we know: When Claude spawns a sub-agent via the `Task` tool, the task input includes `description` and `subagent_type`. `SDKTaskNotificationMessage` (with task completion info) arrives only at the end.
   - What's unclear: Whether `content_block_start` for a `tool_use` block with `name: 'Task'` provides enough info to identify the agent before it starts producing output. The JSON input streams as `input_json_delta` chunks.
   - Recommendation: Track the `tool_use_id` from `content_block_start` where `content_block.name === 'Task'`. Accumulate the `input_json_delta` to extract `subagent_type` from the input JSON. Use `SDKToolProgressMessage.tool_name` for currently active tool identification. Fall back to generic "[agent]" if parsing fails.

## Sources

### Primary (HIGH confidence)
- Local SDK type definitions: `autopilot/node_modules/@anthropic-ai/claude-agent-sdk/sdk.d.ts` -- all SDKMessage types, Query interface, Options, AccountInfo, ModelUsage
- Official streaming docs: https://platform.claude.com/docs/en/agent-sdk/streaming-output -- includePartialMessages usage, stream_event structure, message flow, known limitations
- Official TypeScript SDK reference: https://platform.claude.com/docs/en/agent-sdk/typescript -- full API reference, all message types, tool types
- Local codebase: `autopilot/src/claude/index.ts` -- existing ClaudeService, for-await loop structure
- Local codebase: `autopilot/src/claude/__tests__/claude-service.test.ts` -- existing test patterns with mock async generators

### Secondary (MEDIUM confidence)
- npm: ora 9.3.0, Node >= 20, ESM-native, chalk dependency -- verified via `npm view`
- npm: ansis 4.2.0, ESM+CJS dual export, built-in `strip()` -- verified via npm + GitHub README
- npm: strip-ansi 7.1.2 -- not needed since ansis includes strip()
- GitHub ansis README: confirms `ansis.strip()` function for removing ANSI escape codes

### Tertiary (LOW confidence)
- Quota remaining: No SDK API found for direct subscription quota query. Based on AccountInfo type having only `subscriptionType` field. May change in future SDK versions.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - libraries verified via npm, SDK types verified from local node_modules
- Architecture: HIGH - patterns derived directly from SDK type definitions and existing codebase patterns
- Pitfalls: HIGH - streaming limitation verified in official docs; spinner/TTY issues well-documented
- Quota display: LOW - SDK does not expose remaining quota; workaround is token/cost proxy

**Research date:** 2026-02-16
**Valid until:** 2026-03-16 (SDK may update; check for new message types or quota APIs)
