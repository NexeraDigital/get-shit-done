---
phase: 01-foundation-and-types
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - autopilot/src/state/index.ts
  - autopilot/src/state/__tests__/state-store.test.ts
autonomous: true

must_haves:
  truths:
    - "State store writes autopilot-state.json and reads it back identically"
    - "State store uses atomic writes -- a simulated crash mid-write does not corrupt the file"
    - "State store restores from an existing file on disk with Zod validation"
    - "State store patches state immutably (original state unchanged, new state merged)"
    - "Error history is stored in state with timestamp, phase, step, and truncated output"
    - "Pending questions are persisted in state and survive a restore cycle"
  artifacts:
    - path: "autopilot/src/state/index.ts"
      provides: "StateStore class with atomic persistence"
      exports: ["StateStore"]
      min_lines: 60
    - path: "autopilot/src/state/__tests__/state-store.test.ts"
      provides: "TDD tests for StateStore"
      min_lines: 80
  key_links:
    - from: "autopilot/src/state/index.ts"
      to: "write-file-atomic"
      via: "atomic file persistence"
      pattern: "import.*write-file-atomic"
    - from: "autopilot/src/state/index.ts"
      to: "autopilot/src/types/state.ts"
      via: "type imports"
      pattern: "import.*type.*from.*types"
    - from: "autopilot/src/state/index.ts"
      to: "zod"
      via: "state validation on restore"
      pattern: "import.*from.*zod"
---

<objective>
Build the StateStore class using TDD -- the persistent state management system for the autopilot.

Purpose: The state store is the backbone of resume capability. If the process crashes, the state file must contain valid, uncorrupted JSON that allows the orchestrator to pick up where it left off. Atomic writes via write-file-atomic prevent corruption. Error history and pending questions in the state file enable debugging and restart resilience.
Output: A fully tested StateStore class with atomic persistence, Zod-validated restore, and error/question tracking.
</objective>

<execution_context>
@C:\Users\russw\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\russw\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-and-types/01-RESEARCH.md
@.planning/phases/01-foundation-and-types/01-01-SUMMARY.md
</context>

<feature>
  <name>StateStore with Atomic Persistence</name>
  <files>autopilot/src/state/index.ts, autopilot/src/state/__tests__/state-store.test.ts</files>
  <behavior>
    StateStore manages an in-memory AutopilotState object with file-backed persistence.

    Test cases (input -> expected output):

    1. createFresh(projectDir) -> creates StateStore with default state (status: idle, currentPhase: 0, currentStep: idle, empty arrays)
    2. getState() -> returns Readonly copy of current state (mutations to returned object do not affect internal state)
    3. setState({ status: 'running' }) -> merges patch into state, updates lastUpdatedAt, persists to disk
    4. setState() writes to disk atomically -> after setState, reading the file produces valid JSON matching the state
    5. restore(filePath) -> reads file, validates with Zod schema, returns populated StateStore
    6. restore(filePath) with invalid JSON -> throws descriptive error (not cryptic ZodError)
    7. restore(filePath) with missing file -> throws descriptive error
    8. setState({ errorHistory: [...existing, newError] }) -> error record contains timestamp, phase, step, message, truncatedOutput
    9. setState({ pendingQuestions: [...existing, newQuestion] }) -> question persists with id, phase, step, questions array, createdAt
    10. Multiple sequential setState calls -> each one persists, final state reflects all patches
    11. File path uses path.join() -- no hardcoded separators (FNDN-03)

    Zod schema for state validation on restore:
    - Use z.object() matching the AutopilotState interface from types/state.ts
    - Use parse() not safeParse() for restore (internal data -- validation failure = bug, should throw)
    - Wrap in try/catch to provide human-readable error message
  </behavior>
  <implementation>
    Create src/state/index.ts following the pattern from 01-RESEARCH.md:

    - Import writeFileAtomic from 'write-file-atomic' for atomic writes (FNDN-02)
    - Import readFile from 'node:fs/promises' for reading state
    - Import join from 'node:path' for path construction (FNDN-03)
    - Import type AutopilotState and related types from '../types/index.js'
    - Import z from 'zod' for validation schema

    Define AutopilotStateSchema as a Zod schema matching AutopilotState interface.

    StateStore class:
    - Private constructor(state, filePath) -- use static factory methods
    - getState(): Readonly<AutopilotState> -- returns frozen/readonly state
    - async setState(patch: Partial<AutopilotState>): Promise<void> -- merges patch, sets lastUpdatedAt, calls persist()
    - private async persist(): Promise<void> -- writeFileAtomic with JSON.stringify + newline
    - static async restore(filePath: string): Promise<StateStore> -- reads, validates with Zod, returns instance
    - static createFresh(projectDir: string): StateStore -- creates with default state, path is join(projectDir, '.planning', 'autopilot-state.json')

    CRITICAL: Use write-file-atomic (not fs.writeFile) for ALL state persistence. This is requirement FNDN-02.
    CRITICAL: Use path.join() for ALL path construction. Never concatenate with / or \. This is requirement FNDN-03.
    CRITICAL: All imports use .js extensions for ESM compatibility.

    Export StateStore from src/state/index.ts.
    Add re-export in src/index.ts: export { StateStore } from './state/index.js'
  </implementation>
</feature>

<verification>
1. `cd autopilot && npm test` -- all state store tests pass
2. `npm run build` -- compiles without errors
3. `npm run typecheck` -- no type errors
4. Verify no fs.writeFile or fs.writeFileSync usage in state/index.ts (must use write-file-atomic)
5. Verify no hardcoded path separators in state/index.ts
</verification>

<success_criteria>
- All TDD test cases pass (10+ tests covering createFresh, getState, setState, restore, error handling)
- StateStore uses write-file-atomic for persistence (grep confirms)
- StateStore uses path.join() for all path construction (grep confirms)
- State file on disk contains valid JSON after each setState call
- Zod validation catches malformed state files with descriptive error
- npm run build succeeds with StateStore exported from package entry point
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-types/01-02-SUMMARY.md`
</output>
