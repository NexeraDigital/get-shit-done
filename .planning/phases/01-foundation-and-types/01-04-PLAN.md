---
phase: 01-foundation-and-types
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - autopilot/src/logger/index.ts
  - autopilot/src/logger/ring-buffer.ts
  - autopilot/src/logger/__tests__/ring-buffer.test.ts
  - autopilot/src/logger/__tests__/logger.test.ts
autonomous: true

must_haves:
  truths:
    - "Logger writes structured JSON to per-phase-step log files in .planning/autopilot-log/"
    - "Logger exposes an in-memory ring buffer containing recent log entries for future SSE consumption"
    - "Ring buffer has fixed capacity and overwrites oldest entries when full"
    - "Logger creates the log directory if it does not exist"
    - "Log file naming follows phase-step convention (e.g., phase-1-plan.log)"
  artifacts:
    - path: "autopilot/src/logger/ring-buffer.ts"
      provides: "Generic RingBuffer<T> class"
      exports: ["RingBuffer"]
      min_lines: 25
    - path: "autopilot/src/logger/index.ts"
      provides: "AutopilotLogger class with pino integration and ring buffer"
      exports: ["AutopilotLogger"]
      min_lines: 50
    - path: "autopilot/src/logger/__tests__/ring-buffer.test.ts"
      provides: "Unit tests for RingBuffer"
      min_lines: 40
    - path: "autopilot/src/logger/__tests__/logger.test.ts"
      provides: "Integration tests for AutopilotLogger"
      min_lines: 40
  key_links:
    - from: "autopilot/src/logger/index.ts"
      to: "pino"
      via: "structured JSON logging"
      pattern: "import.*pino"
    - from: "autopilot/src/logger/index.ts"
      to: "autopilot/src/logger/ring-buffer.ts"
      via: "ring buffer for SSE"
      pattern: "import.*RingBuffer.*from.*ring-buffer"
    - from: "autopilot/src/logger/index.ts"
      to: "autopilot/src/types/log.ts"
      via: "LogEntry type"
      pattern: "import.*type.*LogEntry.*from.*types"
    - from: "autopilot/src/logger/index.ts"
      to: "node:path"
      via: "log file path construction"
      pattern: "import.*join.*from.*node:path"
---

<objective>
Build the structured logger system with pino for JSON file output and an in-memory ring buffer for future SSE streaming.

Purpose: Every component in the autopilot logs through this system. Log files enable post-mortem debugging, while the ring buffer enables the Phase 5 dashboard to stream real-time events via SSE. The logger must create per-phase-step log files (per user decision) and ensure the log directory exists before writing.
Output: A working AutopilotLogger class and generic RingBuffer class, both tested.
</objective>

<execution_context>
@C:\Users\russw\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\russw\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-and-types/01-RESEARCH.md
@.planning/phases/01-foundation-and-types/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RingBuffer class with tests</name>
  <files>autopilot/src/logger/ring-buffer.ts, autopilot/src/logger/__tests__/ring-buffer.test.ts</files>
  <action>
Create a generic RingBuffer<T> class following the pattern from 01-RESEARCH.md. This is intentionally hand-rolled (per research recommendation: ~30 lines, simpler than adding a dependency).

**src/logger/ring-buffer.ts:**
```typescript
export class RingBuffer<T> {
  private buffer: T[];
  private head: number = 0;
  private count: number = 0;

  constructor(private readonly capacity: number) {
    this.buffer = new Array<T>(capacity);
  }

  push(item: T): void { ... }      // Add item, overwrite oldest if full
  toArray(): T[] { ... }            // Return items in insertion order (oldest first)
  get size(): number { return this.count; }
  clear(): void { ... }             // Reset buffer (useful for testing)
}
```

Key behaviors:
- Fixed capacity set at construction
- push() overwrites oldest entry when buffer is full (circular)
- toArray() returns entries in chronological order (oldest to newest)
- size returns current number of entries (0 to capacity)

**Tests (src/logger/__tests__/ring-buffer.test.ts):**
1. Empty buffer: size is 0, toArray returns []
2. Push one item: size is 1, toArray returns [item]
3. Push to capacity: size equals capacity, toArray returns all in order
4. Push beyond capacity (overflow): size stays at capacity, oldest item is gone, newest is present
5. toArray returns items in insertion order after overflow
6. clear(): size becomes 0, toArray returns []
7. Works with different types (string, object)
8. Capacity of 1: always contains only the last pushed item

Run tests: `cd autopilot && npx vitest run src/logger/__tests__/ring-buffer.test.ts`
  </action>
  <verify>
- `cd autopilot && npx vitest run src/logger/__tests__/ring-buffer.test.ts` -- all tests pass
- `npm run typecheck` -- no type errors
  </verify>
  <done>
RingBuffer class exists with push, toArray, size, clear methods. All 8+ test cases pass. Buffer correctly handles overflow by dropping oldest entries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AutopilotLogger class with pino and ring buffer integration</name>
  <files>autopilot/src/logger/index.ts, autopilot/src/logger/__tests__/logger.test.ts, autopilot/src/index.ts</files>
  <action>
Create the AutopilotLogger class following the pattern from 01-RESEARCH.md, with adjustments based on user decisions.

**src/logger/index.ts:**

Import pino, join from node:path, mkdirSync from node:fs, RingBuffer from ./ring-buffer.js, LogEntry type from ../types/index.js.

AutopilotLogger class:
- constructor(logDir: string, ringBufferSize = 1000)
  - Store logDir
  - Create RingBuffer<LogEntry>(ringBufferSize)
  - mkdirSync(logDir, { recursive: true }) -- per research pitfall #4
  - Create default pino logger writing to join(logDir, 'autopilot.log') with async I/O (pino.destination with sync: false)
  - Set pino level to 'debug', timestamp to pino.stdTimeFunctions.isoTime

- createPhaseLogger(phase: number, step: string): pino.Logger
  - Create pino destination: join(logDir, `phase-${phase}-${step}.log`)
  - Per user decision: one log file per phase-step
  - Return child pino logger writing to that destination

- log(level: LogLevel, component: string, message: string, meta?: Record<string, unknown>): void
  - Create LogEntry object with timestamp (ISO string), level, component, message, phase/step from meta
  - Push to ring buffer (synchronous -- per research recommendation, keep ring buffer separate from pino pipeline)
  - Forward to pino logger at appropriate level

- getRecentEntries(): LogEntry[]
  - Return ringBuffer.toArray()

- getRingBuffer(): RingBuffer<LogEntry>
  - Return the ring buffer instance (for SSE consumers in Phase 4)

- async flush(): Promise<void>
  - Flush pino's SonicBoom destination (for graceful shutdown)

CRITICAL: Use path.join() for ALL path construction (log dir, file names). Never concatenate with / or \. (FNDN-03)
CRITICAL: mkdirSync(logDir, { recursive: true }) BEFORE creating pino destination (research pitfall #4)
CRITICAL: Ring buffer population happens in the log() method, NOT in pino's stream pipeline (per research recommendation)
CRITICAL: All imports use .js extensions

**Tests (src/logger/__tests__/logger.test.ts):**
1. Constructor creates log directory if it does not exist
2. log() adds entry to ring buffer (verify via getRecentEntries)
3. log() writes to pino (verify log file exists and contains JSON after flush)
4. createPhaseLogger() creates file named phase-{N}-{step}.log
5. Ring buffer accessible via getRingBuffer()
6. Log entries have correct structure (timestamp, level, component, message)

Use a temp directory for logDir in tests (os.tmpdir + random suffix). Clean up after tests.

**Update src/index.ts** to add re-export:
```typescript
export { AutopilotLogger } from './logger/index.js';
export { RingBuffer } from './logger/ring-buffer.js';
```

Run full test suite: `cd autopilot && npm test`
Run build: `cd autopilot && npm run build`
  </action>
  <verify>
- `cd autopilot && npm test` -- all tests pass (ring buffer + logger)
- `npm run build` -- compiles without errors
- `npm run typecheck` -- no type errors
- After running logger tests, verify log files were created in temp directory with valid JSON content
- `node -e "import('./dist/index.js').then(m => console.log(Object.keys(m)))"` shows AutopilotLogger and RingBuffer in exports
  </verify>
  <done>
AutopilotLogger class exists with log(), createPhaseLogger(), getRecentEntries(), getRingBuffer(), flush() methods. All tests pass. Logger creates per-phase-step log files (per user decision). Ring buffer captures entries synchronously. Log directory is created automatically. AutopilotLogger and RingBuffer are exported from the package entry point. npm run build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `cd autopilot && npm test` -- all tests pass (ring buffer + logger)
2. `npm run build` -- zero TypeScript errors
3. `grep -rn "path\.join" autopilot/src/logger/` -- confirms path.join usage for all path construction
4. `grep -rn "mkdirSync" autopilot/src/logger/` -- confirms directory creation before pino destination
5. Verify log file names follow `phase-{N}-{step}.log` convention (per user decision)
6. Verify ring buffer is populated in log() method, not in pino stream
</verification>

<success_criteria>
- RingBuffer handles overflow correctly (drops oldest, keeps newest)
- AutopilotLogger writes structured JSON to per-phase-step log files
- Ring buffer captures all log entries for future SSE consumption
- Log directory is created automatically if missing
- All paths use path.join() (FNDN-03)
- No console.log() in library code (per research anti-pattern)
- All tests pass, build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-types/01-04-SUMMARY.md`
</output>
