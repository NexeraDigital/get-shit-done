---
phase: 08-autopilot-should-be-able-to-be-executed-by-using-a-claude-command
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - autopilot/workflows/gsd-autopilot/pid-manager.js
  - autopilot/workflows/gsd-autopilot/launcher.js
autonomous: true

must_haves:
  truths:
    - "Autopilot launches as a detached background process and returns control immediately"
    - "PID is saved to a per-branch file for later stop/status"
    - "Status subcommand reports running state, phase progress, and dashboard URL"
    - "Stop subcommand sends SIGTERM and waits up to 5 seconds, then SIGKILL"
    - "If autopilot is already running for current branch, launch reports existing instance instead of starting a new one"
    - "If no args and no .planning exists, the launcher prompts for PRD path before spawning"
  artifacts:
    - path: "autopilot/workflows/gsd-autopilot/pid-manager.js"
      provides: "PID file read/write/check/cleanup for per-branch process tracking"
      exports: ["writePid", "readPid", "isProcessRunning", "stopProcess", "cleanupPid"]
      min_lines: 50
    - path: "autopilot/workflows/gsd-autopilot/launcher.js"
      provides: "Main entry point for slash command — routes subcommands, spawns background process"
      min_lines: 100
  key_links:
    - from: "autopilot/workflows/gsd-autopilot/launcher.js"
      to: "autopilot/workflows/gsd-autopilot/port-manager.js"
      via: "import assignPort"
      pattern: "import.*port-manager"
    - from: "autopilot/workflows/gsd-autopilot/launcher.js"
      to: "autopilot/workflows/gsd-autopilot/pid-manager.js"
      via: "import PID functions"
      pattern: "import.*pid-manager"
    - from: "autopilot/workflows/gsd-autopilot/launcher.js"
      to: "npx gsd-autopilot"
      via: "child_process.spawn detached"
      pattern: "spawn.*gsd-autopilot"
---

<objective>
Create the PID manager and launcher script that wire together port assignment, background process spawning, and subcommand routing (launch/status/stop).

Purpose: This is the runtime engine behind the `/gsd:autopilot` slash command. It manages process lifecycle (spawn, check, kill) and routes the three subcommands that the SKILL.md delegates to.

Output: `pid-manager.js` for process tracking, `launcher.js` as the main entry point.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-autopilot-should-be-able-to-be-executed-by-using-a-claude-command/08-RESEARCH.md
@.planning/phases/08-autopilot-should-be-able-to-be-executed-by-using-a-claude-command/08-01-SUMMARY.md

# Reference for existing CLI flags and server standalone
@autopilot/src/cli/index.ts
@autopilot/src/server/standalone.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PID manager for per-branch process tracking</name>
  <files>autopilot/workflows/gsd-autopilot/pid-manager.js</files>
  <action>
    Create `pid-manager.js` as a plain ESM .js module (NOT TypeScript — same rationale as port-manager: runs from ~/.claude/skills/ outside the TS build pipeline).

    Exports five functions:

    1. `writePid(branch, pid, projectDir)` — Write PID to `.planning/autopilot-{branch}.pid` file. The branch name must be sanitized for filenames (replace `/` with `--`). Use `node:fs/promises` writeFile.

    2. `readPid(branch, projectDir)` — Read PID from the branch's `.pid` file. Return the integer PID or null if file doesn't exist. Sanitize branch name same as writePid.

    3. `isProcessRunning(pid)` — Check if process with given PID exists using `process.kill(pid, 0)`. Return true if alive, false if ESRCH error. Re-throw any other error (EPERM means process exists but not owned — treat as running).

    4. `stopProcess(pid, timeoutMs = 5000)` — Send SIGTERM, then poll `isProcessRunning` every 100ms until process exits or timeout. If timeout, send SIGKILL. Return object: `{ status: 'stopped', graceful: boolean }` or `{ status: 'not_running' }` if PID was already dead.

    5. `cleanupPid(branch, projectDir)` — Delete the `.pid` file for the branch. Swallow ENOENT (file already gone).

    Use `node:path` join for all paths. PID files go in `path.join(projectDir, '.planning')` directory.

    Branch sanitization function: replace all `/` with `--` (e.g., `feature/auth` -> `feature--auth`) so filenames are valid on all platforms.
  </action>
  <verify>
    ```bash
    node -e "import('./autopilot/workflows/gsd-autopilot/pid-manager.js').then(m => console.log(Object.keys(m)))"
    ```
    Output includes: writePid, readPid, isProcessRunning, stopProcess, cleanupPid
  </verify>
  <done>
    pid-manager.js exports all 5 functions. writePid creates `.planning/autopilot-{sanitized-branch}.pid`. readPid returns integer or null. isProcessRunning uses signal 0 check. stopProcess has SIGTERM -> wait -> SIGKILL escalation with configurable timeout. cleanupPid removes pid file.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create launcher script with subcommand routing and background spawning</name>
  <files>autopilot/workflows/gsd-autopilot/launcher.js</files>
  <action>
    Create `launcher.js` as a plain ESM .js module. This is the main entry point called by the SKILL.md skill file.

    **Invocation:** `node launcher.js <branch> [subcommand|args...]`

    The script reads process.argv: argv[2] is the branch name (passed by SKILL.md), argv[3+] are the user's arguments.

    **Subcommand routing:**
    - If argv[3] === 'status' -> call handleStatus(branch, projectDir)
    - If argv[3] === 'stop' -> call handleStop(branch, projectDir)
    - Otherwise -> call handleLaunch(branch, projectDir, remainingArgs)

    **handleLaunch(branch, projectDir, args):**
    1. Check if already running: `readPid(branch, projectDir)` -> if PID exists AND `isProcessRunning(pid)`, print "Autopilot already running for branch '{branch}' on port {port}" + dashboard URL. Return early (do NOT spawn second instance — per research recommendation).
    2. Detect resume vs fresh: Check if `.planning/ROADMAP.md` exists in projectDir. If exists AND no `--prd` in args, this is a resume/continue (no PRD needed). If no ROADMAP.md AND no `--prd` in args, prompt for PRD path using `readline` (NOT @inquirer/prompts — this module must be dependency-free). Ask: "Enter path to PRD document: ". Add `--prd <answer>` to args.
    3. Assign port: `const port = await assignPort(branch, projectDir)` (from port-manager.js)
    4. Build spawn args: `['gsd-autopilot', '--port', String(port), ...args]`
    5. Spawn detached: `spawn('npx', spawnArgs, { detached: true, stdio: 'ignore', cwd: projectDir, env: process.env })` then `child.unref()`
    6. Write PID: `writePid(branch, child.pid, projectDir)`
    7. Health check: Attempt to fetch `http://127.0.0.1:${port}/api/health` up to 3 times with 1-second delays between attempts. Use `node:http` (NOT fetch — avoid experimental warnings on Node 20). If health check succeeds, print success. If all 3 fail, print "Autopilot process started (PID {pid}) but dashboard may take a moment to become available."
    8. Print: "Autopilot started on port {port}\nDashboard: http://localhost:{port}"

    **handleStatus(branch, projectDir):**
    1. Read PID file. If no PID or process not running, print "No autopilot running for branch '{branch}'" and return.
    2. Read `.planning/autopilot-state.json` to get currentPhase, status, phases array.
    3. Compute progress: completedPhases / totalPhases * 100.
    4. Read port from state file branches[branch].port.
    5. Print formatted status:
       ```
       Autopilot Status ({branch})
       Status: {status}
       Phase:  {currentPhase}/{totalPhases}
       Progress: {percent}%
       Dashboard: http://localhost:{port}
       PID: {pid}
       ```

    **handleStop(branch, projectDir):**
    1. Read PID. If no PID or not running, print "No autopilot running for branch '{branch}'".
    2. Print "Stopping autopilot for branch '{branch}'..."
    3. Call `stopProcess(pid)`. If graceful, print "Autopilot stopped gracefully." If forced, print "Autopilot force-stopped after timeout."
    4. Call `cleanupPid(branch, projectDir)`.

    Import port-manager.js and pid-manager.js using relative imports (`./port-manager.js`, `./pid-manager.js`).

    Use `import { createInterface } from 'node:readline'` for the PRD prompt (not @inquirer/prompts) to keep this module zero-dependency. Wrap in a promise for async usage.
  </action>
  <verify>
    ```bash
    node -e "import('./autopilot/workflows/gsd-autopilot/launcher.js').catch(e => console.log('Module loads:', !e))"
    ```
    Module loads without import errors. Also verify the three handler paths exist by checking the file structure.
  </verify>
  <done>
    launcher.js routes subcommands (status, stop, launch). Launch checks for existing instance, assigns port via port-manager, spawns detached npx process, writes PID, and performs health check. Status reads state file and reports progress. Stop sends SIGTERM with timeout escalation. PRD path prompt uses readline when needed.
  </done>
</task>

</tasks>

<verification>
1. `node -e "import('./autopilot/workflows/gsd-autopilot/pid-manager.js').then(m => console.log(Object.keys(m)))"` — exports 5 functions
2. `node -e "import('./autopilot/workflows/gsd-autopilot/launcher.js').catch(() => {})"` — module loads without syntax errors
3. launcher.js imports from both port-manager.js and pid-manager.js
</verification>

<success_criteria>
- pid-manager.js handles PID file lifecycle (write, read, check, stop, cleanup)
- launcher.js routes three subcommands correctly
- Launch detects already-running instance and avoids double-spawn
- Launch performs health check after spawn (3 retries, 1s apart)
- Stop uses SIGTERM -> wait -> SIGKILL escalation
- Status reads autopilot-state.json for progress reporting
- PRD prompt fallback uses readline (zero external dependencies)
- All imports between modules resolve correctly
</success_criteria>

<output>
After completion, create `.planning/phases/08-autopilot-should-be-able-to-be-executed-by-using-a-claude-command/08-02-SUMMARY.md`
</output>
