---
phase: 04-response-server-and-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - autopilot/package.json
  - autopilot/src/server/index.ts
  - autopilot/src/server/routes/api.ts
  - autopilot/src/server/middleware/error.ts
autonomous: true

must_haves:
  truths:
    - "Express server class accepts injected dependencies (StateStore, ClaudeService, Orchestrator, AutopilotLogger, config) via constructor"
    - "GET /api/health returns JSON { status: 'ok', uptime: <number> }"
    - "GET /api/status returns current phase, step, and computed progress percentage"
    - "GET /api/phases returns all phases with status from StateStore"
    - "GET /api/questions returns pending questions from ClaudeService"
    - "GET /api/questions/:questionId returns single question or 404"
    - "POST /api/questions/:questionId submits answer via ClaudeService.submitAnswer() and returns 200 or 404"
    - "Error middleware catches unhandled errors and returns 500 JSON"
  artifacts:
    - path: "autopilot/src/server/index.ts"
      provides: "ResponseServer class with start() and close() methods"
      exports: ["ResponseServer", "ResponseServerOptions"]
    - path: "autopilot/src/server/routes/api.ts"
      provides: "REST route factory returning an Express Router"
      exports: ["createApiRoutes"]
    - path: "autopilot/src/server/middleware/error.ts"
      provides: "Express error handling middleware"
      exports: ["errorHandler"]
  key_links:
    - from: "autopilot/src/server/routes/api.ts"
      to: "StateStore.getState()"
      via: "injected stateStore in route factory"
      pattern: "stateStore\\.getState\\(\\)"
    - from: "autopilot/src/server/routes/api.ts"
      to: "ClaudeService.getPendingQuestions()"
      via: "injected claudeService in route factory"
      pattern: "claudeService\\.getPendingQuestions\\(\\)"
    - from: "autopilot/src/server/routes/api.ts"
      to: "ClaudeService.submitAnswer()"
      via: "injected claudeService in POST handler"
      pattern: "claudeService\\.submitAnswer\\("
---

<objective>
Create the ResponseServer class and all REST API endpoints for the autopilot dashboard server.

Purpose: Establish the Express 5 HTTP server with dependency injection and all synchronous REST endpoints (health, status, phases, questions). This is the foundation that the SSE streaming and CLI wiring (Plan 02) build upon.

Output: ResponseServer class with start()/close(), REST routes, error middleware, Express 5 installed.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-response-server-and-api/04-RESEARCH.md
@autopilot/src/types/state.ts
@autopilot/src/types/config.ts
@autopilot/src/state/index.ts
@autopilot/src/claude/index.ts
@autopilot/src/logger/index.ts
@autopilot/src/orchestrator/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Express 5 and create ResponseServer class with REST routes</name>
  <files>
    autopilot/package.json
    autopilot/src/server/index.ts
    autopilot/src/server/routes/api.ts
    autopilot/src/server/middleware/error.ts
  </files>
  <action>
Install Express 5 and its types:
```bash
cd autopilot && npm install express && npm install -D @types/express
```

This installs Express 5 (now the npm default) and `@types/express@5.x`.

**Create `src/server/middleware/error.ts`:**

Express error-handling middleware (must have 4 parameters for Express to recognize it as error handler). Log the error and return `{ error: 'Internal server error' }` with status 500. Use `import type { Request, Response, NextFunction } from 'express';` for types. Export as `errorHandler`.

**Create `src/server/routes/api.ts`:**

Export a factory function `createApiRoutes(deps)` that takes `{ stateStore, claudeService }` and returns an Express `Router` with these endpoints:

1. `GET /health` - Returns `{ status: 'ok', uptime: process.uptime() }`. This is the simplest endpoint (DASH-08).

2. `GET /status` - Reads `stateStore.getState()`, computes progress percentage using a `computeProgress()` helper function. Progress formula: count completed steps across all phases (each phase has 4 steps: discuss, plan, execute, verify; a step is complete when its value is `'done'`), divide by total steps (phases.length * 4), multiply by 100, round. Return `{ status, currentPhase, currentStep, progress, startedAt, lastUpdatedAt }` (DASH-02).

3. `GET /phases` - Returns `{ phases: stateStore.getState().phases }` (DASH-03).

4. `GET /questions` - Returns `{ questions: claudeService.getPendingQuestions() }` (DASH-04).

5. `GET /questions/:questionId` - Finds question by ID from `claudeService.getPendingQuestions()`. Returns 404 JSON if not found (DASH-05).

6. `POST /questions/:questionId` - Reads `{ answers }` from `req.body`. Validates answers is a non-null object. Calls `claudeService.submitAnswer(req.params.questionId, answers)`. If `submitAnswer()` returns false, respond 404 with `{ error: 'Question not found or already answered' }`. If true, respond `{ ok: true }` (DASH-06).

Use `import type` for TypeScript types per the codebase convention. The factory function signature:
```typescript
import { Router } from 'express';
import type { Request, Response } from 'express';
import type { StateStore } from '../../state/index.js';
import type { ClaudeService } from '../../claude/index.js';

export interface ApiRouteDeps {
  stateStore: StateStore;
  claudeService: ClaudeService;
}

export function createApiRoutes(deps: ApiRouteDeps): Router { ... }
```

**Create `src/server/index.ts`:**

Export `ResponseServerOptions` interface and `ResponseServer` class:

```typescript
import express from 'express';
import type { Express } from 'express';
import { createServer, type Server } from 'node:http';
import { createApiRoutes } from './routes/api.js';
import { errorHandler } from './middleware/error.js';
import type { StateStore } from '../state/index.js';
import type { ClaudeService } from '../claude/index.js';
import type { Orchestrator } from '../orchestrator/index.js';
import type { AutopilotLogger } from '../logger/index.js';
import type { AutopilotConfig } from '../types/index.js';
```

ResponseServerOptions interface includes: `stateStore`, `claudeService`, `orchestrator`, `logger`, `config`. Also optional `dashboardDir?: string` for Phase 5 SPA serving.

ResponseServer class:
- Constructor receives `ResponseServerOptions`. Creates Express app. Registers `express.json()` middleware. Mounts API routes at `/api` using `createApiRoutes()`. Registers error middleware last.
- `async start(port: number): Promise<void>` - Creates `http.Server` via `this.app.listen(port)`, wraps in Promise that resolves on 'listening'. Catches `EADDRINUSE` and throws a clear error: `Port ${port} is already in use. Try --port <other>`.
- `async close(): Promise<void>` - Closes HTTP server via `server.close()` callback wrapped in Promise. No-op if server is null.
- Store `server` as private field, initially null.
- Export `ResponseServerOptions` as a type export.

Do NOT add SSE or SPA serving yet -- those come in Plan 02.
  </action>
  <verify>
Run from the autopilot directory:
```bash
cd autopilot && npx tsc --noEmit
```
TypeScript compilation must succeed with zero errors. Verify express and @types/express are in package.json dependencies/devDependencies.
  </verify>
  <done>
ResponseServer class exists at src/server/index.ts with start()/close() methods. All 6 REST endpoints defined in src/server/routes/api.ts. Error middleware at src/server/middleware/error.ts. Express 5 installed. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for REST endpoints and ResponseServer lifecycle</name>
  <files>
    autopilot/src/server/__tests__/api-routes.test.ts
    autopilot/src/server/__tests__/server.test.ts
  </files>
  <action>
Create two test files.

**`src/server/__tests__/api-routes.test.ts`:**

Test the REST endpoints by creating a minimal Express app, mounting the routes via `createApiRoutes()` with mock dependencies, and using Node's native `fetch()` to hit the running server.

Mock dependencies:
- `stateStore` - Object with `getState()` returning a fake `AutopilotState` with 2 phases (one completed, one in progress with discuss+plan done).
- `claudeService` - Object with `getPendingQuestions()` returning a fake array, and `submitAnswer()` that returns true for known IDs, false otherwise.

Tests:
1. `GET /api/health` returns 200 with `{ status: 'ok' }` and numeric `uptime`
2. `GET /api/status` returns 200 with `progress` as a number between 0-100, `currentPhase`, `currentStep`
3. `GET /api/status` progress calculation is correct (e.g., 2 phases with 4 steps each = 8 total; if 5 are done = 62.5% rounded to 63)
4. `GET /api/phases` returns 200 with `{ phases }` array matching state
5. `GET /api/questions` returns 200 with `{ questions }` array
6. `GET /api/questions/:id` returns 200 for existing question, 404 for unknown ID
7. `POST /api/questions/:id` with valid answers returns 200 `{ ok: true }`
8. `POST /api/questions/:id` with unknown ID returns 404
9. `POST /api/questions/:id` with missing/invalid answers returns 400

Pattern: Use `beforeAll` to start server on port 0 (let OS assign), extract port from `server.address()`. Use `afterAll` to close server.

**`src/server/__tests__/server.test.ts`:**

Test the ResponseServer class lifecycle:
1. `start()` opens a port and health endpoint responds
2. `close()` shuts down cleanly (subsequent requests fail)
3. Starting on an already-used port throws EADDRINUSE error message

Use real (but minimal) mock dependencies for the constructor. Start on port 0 for OS-assigned ports.
  </action>
  <verify>
```bash
cd autopilot && npx vitest run src/server/__tests__/
```
All tests pass with no timeouts.
  </verify>
  <done>
REST endpoint tests validate all 6 routes with correct status codes and response shapes. Server lifecycle tests confirm start/close/EADDRINUSE behavior. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cd autopilot && npx tsc --noEmit` -- zero TypeScript errors
2. `cd autopilot && npx vitest run src/server/__tests__/` -- all tests pass
3. Verify `express` in dependencies, `@types/express` in devDependencies in package.json
</verification>

<success_criteria>
- ResponseServer class with DI constructor, start(), close() methods
- 6 REST endpoints: health, status (with progress%), phases, questions list, question by ID, submit answer
- Error middleware returns 500 JSON for unhandled errors
- All endpoints tested with correct status codes and response shapes
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/04-response-server-and-api/04-01-SUMMARY.md`
</output>
