---
phase: 04-response-server-and-api
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - autopilot/src/server/routes/sse.ts
  - autopilot/src/server/index.ts
  - autopilot/src/logger/index.ts
  - autopilot/src/cli/index.ts
  - autopilot/src/index.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/log/stream opens an SSE connection with correct headers (text/event-stream, no-cache, keep-alive)"
    - "SSE pushes real-time events: phase-started, phase-completed, question-pending, question-answered, error, log-entry, build-complete"
    - "New SSE clients receive initial burst of recent log entries from ring buffer on connect"
    - "AutopilotLogger emits 'entry' event when log() is called, enabling real-time SSE delivery"
    - "Server shuts down cleanly when autopilot completes (SSE connections closed, HTTP server drained)"
    - "CLI wires ResponseServer startup before orchestrator.run() and shutdown via ShutdownManager"
    - "Non-API GET requests serve dashboard/dist/index.html if dashboard directory exists"
    - "ResponseServer is exported from package entry point"
  artifacts:
    - path: "autopilot/src/server/routes/sse.ts"
      provides: "SSE endpoint setup and broadcast function"
      exports: ["setupSSE"]
    - path: "autopilot/src/server/index.ts"
      provides: "ResponseServer with SSE and SPA support"
      exports: ["ResponseServer", "ResponseServerOptions"]
    - path: "autopilot/src/logger/index.ts"
      provides: "AutopilotLogger extending EventEmitter with 'entry' event"
    - path: "autopilot/src/cli/index.ts"
      provides: "CLI wiring for ResponseServer start/shutdown"
    - path: "autopilot/src/index.ts"
      provides: "Package exports including ResponseServer"
  key_links:
    - from: "autopilot/src/server/routes/sse.ts"
      to: "Orchestrator events"
      via: "orchestrator.on('phase:started' | 'phase:completed' | 'build:complete' | 'error:escalation')"
      pattern: "orchestrator\\.on\\("
    - from: "autopilot/src/server/routes/sse.ts"
      to: "ClaudeService events"
      via: "claudeService.on('question:pending' | 'question:answered')"
      pattern: "claudeService\\.on\\("
    - from: "autopilot/src/server/routes/sse.ts"
      to: "AutopilotLogger 'entry' event"
      via: "logger.on('entry', ...)"
      pattern: "logger\\.on\\('entry'"
    - from: "autopilot/src/cli/index.ts"
      to: "ResponseServer.start()"
      via: "server.start(config.port) before orchestrator.run()"
      pattern: "responseServer\\.start\\("
    - from: "autopilot/src/cli/index.ts"
      to: "ShutdownManager.register()"
      via: "shutdown.register(() => responseServer.close())"
      pattern: "responseServer\\.close\\(\\)"
---

<objective>
Add SSE streaming endpoint with real-time event wiring, SPA static serving, and integrate the ResponseServer into the CLI bootstrap.

Purpose: Complete the server by adding real-time event delivery (SSE) and wiring the server lifecycle into the existing CLI entry point. This makes the server operational end-to-end: starts with autopilot, streams events, and shuts down cleanly.

Output: Working SSE endpoint, AutopilotLogger EventEmitter enhancement, SPA fallback, CLI integration, package exports.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-response-server-and-api/04-RESEARCH.md
@.planning/phases/04-response-server-and-api/04-01-SUMMARY.md
@autopilot/src/server/index.ts
@autopilot/src/server/routes/api.ts
@autopilot/src/logger/index.ts
@autopilot/src/cli/index.ts
@autopilot/src/orchestrator/index.ts
@autopilot/src/claude/index.ts
@autopilot/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EventEmitter to AutopilotLogger and create SSE endpoint with event wiring</name>
  <files>
    autopilot/src/logger/index.ts
    autopilot/src/server/routes/sse.ts
    autopilot/src/server/index.ts
  </files>
  <action>
**Enhance `src/logger/index.ts`:**

Make `AutopilotLogger` extend `EventEmitter`. Import `EventEmitter` from `node:events`. Call `super()` in the constructor. In the `log()` method, after pushing the entry to the ring buffer, emit an `'entry'` event with the `LogEntry` object:
```typescript
this.emit('entry', entry);
```
This is a minimal change (~3 lines added) per research recommendation. Existing ring buffer behavior is unchanged. The event enables real-time SSE delivery without polling.

**Create `src/server/routes/sse.ts`:**

Export a `setupSSE` function that takes dependencies and configures the SSE endpoint and event wiring. Signature:
```typescript
import type { Express, Request, Response } from 'express';
import type { Orchestrator } from '../../orchestrator/index.js';
import type { ClaudeService } from '../../claude/index.js';
import type { AutopilotLogger } from '../../logger/index.js';

export interface SSEDeps {
  app: Express;
  orchestrator: Orchestrator;
  claudeService: ClaudeService;
  logger: AutopilotLogger;
}

export function setupSSE(deps: SSEDeps): { broadcast: (event: string, data: unknown) => void; closeAll: () => void } { ... }
```

Inside `setupSSE`:

1. Create a `Set<Response>` for connected SSE clients.

2. Register `GET /api/log/stream` route on `deps.app`:
   - Set headers: `Content-Type: text/event-stream`, `Cache-Control: no-cache`, `Connection: keep-alive`.
   - Call `res.flushHeaders()`.
   - Write `retry: 10000\n\n` for client reconnection interval.
   - Send initial burst: iterate `deps.logger.getRecentEntries()` and write each as `event: log-entry\ndata: ${JSON.stringify(entry)}\n\n`.
   - Add `res` to the client set.
   - Register `req.on('close', () => clients.delete(res))` for cleanup.

3. Create `broadcast(event: string, data: unknown)` function:
   - Format payload as `event: ${event}\ndata: ${JSON.stringify(data)}\n\n`.
   - Iterate clients and call `client.write(payload)`. Wrap in try-catch; on error, delete the client from the set (handles disconnected clients per Pitfall 2).

4. Wire Orchestrator events to broadcast (DASH-19):
   - `orchestrator.on('phase:started', (data) => broadcast('phase-started', data))`
   - `orchestrator.on('phase:completed', (data) => broadcast('phase-completed', data))`
   - `orchestrator.on('build:complete', () => broadcast('build-complete', {}))`
   - `orchestrator.on('error:escalation', (data) => broadcast('error', data))`

5. Wire ClaudeService events to broadcast (DASH-19):
   - `claudeService.on('question:pending', (data) => broadcast('question-pending', data))`
   - `claudeService.on('question:answered', (data) => broadcast('question-answered', data))`

6. Wire AutopilotLogger 'entry' event to broadcast:
   - `logger.on('entry', (entry) => broadcast('log-entry', entry))`

7. Create `closeAll()` function that ends all SSE connections and clears the set.

8. Return `{ broadcast, closeAll }`.

**Update `src/server/index.ts`:**

Import `setupSSE` from `./routes/sse.js`. Import `existsSync` from `node:fs`. Import `join` from `node:path`. Import `express` static middleware.

In the ResponseServer constructor, after mounting API routes and before error middleware:

1. Call `setupSSE({ app: this.app, orchestrator, claudeService, logger })` and store the returned `{ broadcast, closeAll }` on the class.

2. SPA fallback (DASH-09): Check if `options.dashboardDir` is provided and `existsSync(options.dashboardDir)` is true. If so:
   - Mount `express.static(options.dashboardDir)` middleware.
   - Add a catch-all `app.get('*', (req, res, next) => { ... })` that serves `index.html` for non-API routes. Check `!req.path.startsWith('/api/')` before sending the file. If the path starts with `/api/`, call `next()` to fall through to 404/error handling.
   If dashboard dir does not exist, skip static serving silently (Phase 5 hasn't built it yet per Pitfall 4).

3. Update `close()` to call `this.closeAll()` before closing the HTTP server (ends all SSE connections first).
  </action>
  <verify>
```bash
cd autopilot && npx tsc --noEmit
```
Zero TypeScript errors. Verify that AutopilotLogger now extends EventEmitter.
  </verify>
  <done>
SSE endpoint at GET /api/log/stream with proper headers, initial burst, and client tracking. Seven event types wired from Orchestrator, ClaudeService, and AutopilotLogger to SSE broadcast. SPA fallback serves dashboard/dist/ if it exists. AutopilotLogger emits 'entry' event on every log() call. close() ends SSE connections before shutting down HTTP server.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ResponseServer into CLI bootstrap and add package exports</name>
  <files>
    autopilot/src/cli/index.ts
    autopilot/src/index.ts
  </files>
  <action>
**Update `src/cli/index.ts`:**

Add import for ResponseServer:
```typescript
import { ResponseServer } from '../server/index.js';
```

In the CLI action handler, after creating the orchestrator and wiring event listeners (after section "h"), and before installing ShutdownManager (section "i"):

1. Create the ResponseServer instance:
```typescript
const responseServer = new ResponseServer({
  stateStore,
  claudeService,
  orchestrator,
  logger,
  config,
});
```

2. Start the server before the orchestrator runs. Move server start to be AFTER ShutdownManager install but BEFORE orchestrator.run(). Insert between section "i" (ShutdownManager) and section "j" (run orchestrator):
```typescript
// k. Start response server
await responseServer.start(config.port);
if (!options.quiet) {
  console.log(`Dashboard server: http://localhost:${config.port}`);
}
```

3. Register server shutdown with ShutdownManager. Add this BEFORE the existing shutdown handlers (the server should close first, before logger flush). Insert at the beginning of the shutdown registrations (before streamLogger flush registration):
```typescript
shutdown.register(async () => {
  logger.log('info', 'cli', 'Shutting down response server');
  await responseServer.close();
});
```

This follows LIFO order: server shuts down first (registered last among the early handlers), then stream logger flushes, then main logger flushes, then state persists. Actually, since register() pushes to an array and shutdown runs in reverse (LIFO), register the server shutdown AFTER the state persist handler so it runs FIRST during shutdown:

Revised approach -- add the server shutdown registration AFTER all existing shutdown.register() calls but before shutdown.install():
```typescript
// Register server shutdown (runs FIRST due to LIFO -- registered last)
shutdown.register(async () => {
  logger.log('info', 'cli', 'Shutting down response server');
  await responseServer.close();
});
```

4. In the success path (after orchestrator.run completes), close the server before exiting:
```typescript
await responseServer.close();
```

5. In the error catch block, also close the server:
```typescript
await responseServer.close();
```

**Update `src/index.ts`:**

Add exports for the ResponseServer:
```typescript
export { ResponseServer } from './server/index.js';
export type { ResponseServerOptions } from './server/index.js';
```
  </action>
  <verify>
```bash
cd autopilot && npx tsc --noEmit
```
Zero TypeScript errors.

```bash
cd autopilot && npx vitest run
```
All existing tests continue to pass (no regressions). New server tests from Plan 01 also pass.
  </verify>
  <done>
CLI creates ResponseServer, starts it on configured port before orchestrator.run(), prints dashboard URL, registers shutdown with ShutdownManager (LIFO: server closes first). ResponseServer and ResponseServerOptions exported from package entry point. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for SSE endpoint and event wiring</name>
  <files>
    autopilot/src/server/__tests__/sse.test.ts
  </files>
  <action>
Create `src/server/__tests__/sse.test.ts` to test the SSE endpoint and event broadcasting.

Use the following approach:
- Create a minimal ResponseServer with mock dependencies (EventEmitter-based mocks for orchestrator, claudeService, and logger).
- Start on port 0.
- Connect to `/api/log/stream` using native `fetch()` and read the response body as a ReadableStream.

Mock dependencies:
- `orchestrator` - new EventEmitter() (cast as needed)
- `claudeService` - new EventEmitter() with `getPendingQuestions()` returning `[]` and `submitAnswer()` returning false
- `logger` - new EventEmitter() with `getRecentEntries()` returning a small array of fake LogEntry objects, and `log()` as a no-op
- `stateStore` - object with `getState()` returning minimal state
- `config` - minimal AutopilotConfig with defaults

Tests:

1. **SSE headers**: Connect to `/api/log/stream`, verify response headers include `content-type: text/event-stream`.

2. **Initial burst**: Pre-populate logger mock's `getRecentEntries()` with 2 entries. Connect and verify the first data received contains those entries as `event: log-entry` payloads.

3. **Event broadcasting - phase-started**: Connect SSE, then emit `phase:started` on the mock orchestrator. Verify the client receives an `event: phase-started` payload.

4. **Event broadcasting - question-pending**: Connect SSE, then emit `question:pending` on the mock claudeService. Verify the client receives `event: question-pending` payload.

5. **Event broadcasting - log entry**: Connect SSE, emit `entry` on the mock logger. Verify client receives `event: log-entry` payload.

6. **Client cleanup on disconnect**: Connect SSE, disconnect, then emit an event. Verify no error is thrown (client was removed from set).

Helper function for reading SSE: Use `response.body.getReader()` and a TextDecoder to read chunks. Parse SSE format (`event: ...\ndata: ...\n\n`). Use a small timeout (500ms) to collect events before asserting.

Important: After each test, close the server to release the port. Use `afterEach` for cleanup.
  </action>
  <verify>
```bash
cd autopilot && npx vitest run src/server/__tests__/sse.test.ts
```
All SSE tests pass.

```bash
cd autopilot && npx vitest run
```
Full test suite passes (no regressions).
  </verify>
  <done>
SSE endpoint tested for: correct headers, initial burst delivery, event broadcasting for phase-started/question-pending/log-entry, and client cleanup on disconnect. All tests pass including full suite regression check.
  </done>
</task>

</tasks>

<verification>
1. `cd autopilot && npx tsc --noEmit` -- zero TypeScript errors
2. `cd autopilot && npx vitest run` -- all tests pass (including new SSE tests)
3. AutopilotLogger extends EventEmitter and emits 'entry' in log()
4. CLI creates and starts ResponseServer before orchestrator.run()
5. ShutdownManager closes server on shutdown (LIFO order)
6. ResponseServer exported from package entry point
</verification>

<success_criteria>
- SSE endpoint at GET /api/log/stream with text/event-stream headers, retry interval, and initial burst
- Seven SSE event types wired: phase-started, phase-completed, question-pending, question-answered, error, log-entry, build-complete
- AutopilotLogger extends EventEmitter, emits 'entry' event
- SPA fallback serves dashboard/dist/ when directory exists, skips silently when absent
- CLI wires ResponseServer lifecycle (start before run, close on shutdown)
- ResponseServer and ResponseServerOptions exported from @gsd/autopilot
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-response-server-and-api/04-02-SUMMARY.md`
</output>
