---
phase: 09-fix-recent-activity-persistence
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - autopilot/src/orchestrator/index.ts
  - autopilot/src/cli/index.ts
  - autopilot/src/server/standalone.ts
  - autopilot/src/server/index.ts
autonomous: true

must_haves:
  truths:
    - "Phase started/completed events create activities with server timestamps and phase name + action format"
    - "Step started/completed events create activities with blue-category step names"
    - "Question pending events create activities with truncated question text, not raw UUIDs"
    - "Question answered events create activities marked as answered"
    - "Error escalation events create activities with error messages"
    - "Build complete events create activities"
    - "Activities are persisted to disk at event source (server-side), not created client-side"
    - "ActivityStore is initialized (restored from disk) before orchestrator.run() begins"
    - "Standalone dashboard server exposes ActivityStore via /api/activities"
  artifacts:
    - path: "autopilot/src/orchestrator/index.ts"
      provides: "Orchestrator accepts and uses ActivityStore for phase/step/build activities"
      contains: "activityStore"
    - path: "autopilot/src/cli/index.ts"
      provides: "CLI creates ActivityStore, wires question/error/build activities, passes to orchestrator and server"
      contains: "ActivityStore"
    - path: "autopilot/src/server/standalone.ts"
      provides: "Standalone dashboard reads ActivityStore and passes to server as activityProvider"
      contains: "ActivityStore"
  key_links:
    - from: "autopilot/src/cli/index.ts"
      to: "autopilot/src/activity/index.ts"
      via: "import and instantiate ActivityStore"
      pattern: "new ActivityStore"
    - from: "autopilot/src/orchestrator/index.ts"
      to: "ActivityStore.addActivity"
      via: "called in runPhase and runStep for phase/step lifecycle events"
      pattern: "activityStore\\.addActivity"
    - from: "autopilot/src/server/standalone.ts"
      to: "ActivityStore"
      via: "import, restore, and inject as activityProvider"
      pattern: "activityProvider.*activityStore"
---

<objective>
Wire ActivityStore into the orchestrator, CLI, and standalone dashboard so all events create server-side activities with proper content formatting.

Purpose: Move activity creation from client-side (useSSE.ts with client timestamps and raw UUIDs) to server-side (orchestrator/CLI event handlers with server timestamps and human-readable content). This fixes the timestamp drift and UUID display issues.

Output: All activity-generating events create persisted ActivityEntry objects with correct formatting.
</objective>

<execution_context>
@C:/Users/russw/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/russw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-fix-recent-activity-so-it-persists-in-the-planning-folder-so-it-stays-consistant-and-time-works-properly/09-01-SUMMARY.md
@autopilot/src/orchestrator/index.ts
@autopilot/src/cli/index.ts
@autopilot/src/server/standalone.ts
@autopilot/src/server/index.ts
@autopilot/src/claude/question-handler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire ActivityStore into Orchestrator for phase/step lifecycle events</name>
  <files>autopilot/src/orchestrator/index.ts</files>
  <action>
Modify the Orchestrator class to accept and use an ActivityStore:

1. Add import at top:
```typescript
import type { ActivityStore } from '../activity/index.js';
```

2. Add `activityStore?: ActivityStore` to OrchestratorOptions interface (optional so existing callers without it still work).

3. Add private field: `private readonly activityStore?: ActivityStore;`
   Set in constructor: `this.activityStore = options.activityStore;`

4. In `runPhase()` -- after `this.emit('phase:started', ...)`:
```typescript
if (this.activityStore) {
  await this.activityStore.addActivity({
    type: 'phase-started',
    message: `Phase ${phase.number}: ${phase.name} — started`,
    timestamp: new Date().toISOString(),
    metadata: { phase: phase.number },
  });
}
```

5. In `runPhase()` -- after `this.emit('phase:completed', ...)`:
```typescript
if (this.activityStore) {
  await this.activityStore.addActivity({
    type: 'phase-completed',
    message: `Phase ${phase.number}: ${phase.name} — completed`,
    timestamp: new Date().toISOString(),
    metadata: { phase: phase.number },
  });
}
```

6. In `runStep()` -- after `this.emit('step:started', ...)`:
```typescript
if (this.activityStore) {
  await this.activityStore.addActivity({
    type: 'step-started',
    message: `Phase ${phase.number}: ${stepName} started`,
    timestamp: new Date().toISOString(),
    metadata: { phase: phase.number, step: stepName },
  });
}
```

7. In `runStep()` -- after `this.emit('step:completed', ...)`:
```typescript
if (this.activityStore) {
  await this.activityStore.addActivity({
    type: 'step-completed',
    message: `Phase ${phase.number}: ${stepName} completed`,
    timestamp: new Date().toISOString(),
    metadata: { phase: phase.number, step: stepName },
  });
}
```

8. In `run()` -- after `this.emit('build:complete')`:
```typescript
if (this.activityStore) {
  await this.activityStore.addActivity({
    type: 'build-complete',
    message: 'Build complete — all phases finished',
    timestamp: new Date().toISOString(),
  });
}
```

Use em-dash (—) separator for phase name + action format per locked decision.
  </action>
  <verify>
Run `npx tsc --noEmit` from autopilot/ directory. Grep for `activityStore.addActivity` in orchestrator/index.ts -- should find 5 calls (phase-started, phase-completed, step-started, step-completed, build-complete).
  </verify>
  <done>
Orchestrator creates server-side activities for all phase/step lifecycle events with server timestamps and human-readable messages using "Phase N: Name — action" format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ActivityStore in CLI for questions/errors and pass to orchestrator + server</name>
  <files>autopilot/src/cli/index.ts, autopilot/src/server/standalone.ts, autopilot/src/server/index.ts</files>
  <action>
**autopilot/src/cli/index.ts:**

1. Add import:
```typescript
import { ActivityStore, truncateText } from '../activity/index.js';
```

2. After stateStore creation (around the `// e. Create core components` section), create and restore ActivityStore:
```typescript
const activityStore = new ActivityStore(projectDir);
await activityStore.restore();
```

3. Pass activityStore to Orchestrator constructor:
```typescript
const orchestrator = new Orchestrator({
  stateStore,
  claudeService,
  logger,
  config,
  projectDir,
  activityStore,  // NEW
});
```

4. Wire question:pending -> activity creation. Replace or add alongside the existing `claudeService.on('question:pending', ...)` handlers. Add a NEW handler for activity creation (keep the existing ones for state persistence and notification dispatch):
```typescript
claudeService.on('question:pending', (event: QuestionEvent) => {
  const questionText = event.questions.map(q => q.question).join('; ');
  void activityStore.addActivity({
    type: 'question-pending',
    message: `Question: ${truncateText(questionText)}`,
    timestamp: new Date().toISOString(),
    metadata: { questionId: event.id, phase: event.phase },
  });
});
```

5. Wire question:answered -> activity creation:
```typescript
claudeService.on('question:answered', ({ id }: { id: string }) => {
  void activityStore.addActivity({
    type: 'question-answered',
    message: `Question answered`,
    timestamp: new Date().toISOString(),
    metadata: { questionId: id },
  });
});
```
Per locked decision: answered questions show in feed marked as answered but do NOT display the answer text.

6. Wire error:escalation -> activity creation:
```typescript
orchestrator.on('error:escalation', ({ phase, step, error }: { phase: number; step: string; error: string }) => {
  void activityStore.addActivity({
    type: 'error',
    message: truncateText(error, 100),
    timestamp: new Date().toISOString(),
    metadata: { phase, step },
  });
});
```

7. If using embedded server, pass activityStore as activityProvider. Modify the legacy ResponseServer constructor call to also include the activityProvider. Since the legacy path uses `ResponseServerOptionsLegacy`, we need to update the ResponseServer to accept activityProvider in both paths.

**autopilot/src/server/index.ts:**

Update the `ResponseServerOptions` interface to include `activityProvider`:
```typescript
export interface ResponseServerOptions {
  stateProvider: StateProvider;
  questionProvider: QuestionProvider;
  livenessProvider?: LivenessProvider;
  sseDeps?: SSEOptions;
  dashboardDir?: string;
  activityProvider?: import('./routes/api.js').ActivityProvider;  // NEW
}
```

Update `ResponseServerOptionsLegacy` to include `activityProvider`:
```typescript
export interface ResponseServerOptionsLegacy {
  // ... existing fields ...
  activityProvider?: import('./routes/api.js').ActivityProvider;  // NEW
}
```

In the constructor, extract activityProvider from both paths and pass to createApiRoutes:
```typescript
const activityProvider = opts.activityProvider; // works for both new and legacy
const apiRouter = createApiRoutes({ stateProvider, questionProvider, livenessProvider, activityProvider });
```

In CLI, for the legacy embedded server path, pass `activityProvider: activityStore`:
```typescript
responseServer = new ResponseServer({
  stateStore,
  claudeService,
  orchestrator,
  logger,
  config,
  dashboardDir,
  activityProvider: activityStore,  // NEW
});
```

**autopilot/src/server/standalone.ts:**

1. Add import:
```typescript
import { ActivityStore } from '../activity/index.js';
```

2. After creating IPC components, create and restore ActivityStore:
```typescript
const activityStore = new ActivityStore(projectDir);
await activityStore.restore();
```

3. Pass activityStore to ResponseServer as activityProvider:
```typescript
const server = new ResponseServer({
  stateProvider: stateReader,
  questionProvider,
  livenessProvider: stateReader,
  sseDeps: {
    mode: 'file-tail' as const,
    eventTailer,
  },
  dashboardDir: existsSync(dashboardDir) ? dashboardDir : undefined,
  activityProvider: activityStore,  // NEW
});
```
  </action>
  <verify>
Run `npx tsc --noEmit` from autopilot/ directory. Verify:
- CLI creates ActivityStore and passes to Orchestrator + ResponseServer
- Standalone server creates ActivityStore and passes to ResponseServer
- question:pending handler uses truncateText (not raw UUID)
- question:answered handler does NOT include answer text (per locked decision)
  </verify>
  <done>
All activity-generating events (phase lifecycle, step lifecycle, questions, errors, build complete) create server-side ActivityEntry objects with proper content formatting. ActivityStore is wired into both embedded and standalone dashboard server paths. Question activities show truncated question text instead of UUIDs.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors from autopilot/ directory
2. Orchestrator has 5 addActivity calls (phase-started, phase-completed, step-started, step-completed, build-complete)
3. CLI has 3 addActivity calls (question-pending, question-answered, error)
4. Question-pending activities use truncateText() on question text (not UUID)
5. Question-answered activities do NOT include answer text
6. Phase activities use "Phase N: Name — action" format (em-dash separator)
7. Standalone server creates ActivityStore and passes as activityProvider
8. All addActivity calls use `new Date().toISOString()` for server timestamps
</verification>

<success_criteria>
- Activity creation happens server-side at event source with server timestamps
- Question activities display truncated question text, not raw UUIDs
- Phase activities use "Phase N: Name — action" format per locked decision
- Answered question activities are marked without exposing answer text
- Both embedded and standalone server paths serve activities via REST
</success_criteria>

<output>
After completion, create `.planning/phases/09-fix-recent-activity-so-it-persists-in-the-planning-folder-so-it-stays-consistant-and-time-works-properly/09-02-SUMMARY.md`
</output>
