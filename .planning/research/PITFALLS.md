# Domain Pitfalls

**Domain:** Node.js CLI tool orchestrating AI code generation via child processes, with embedded Express web server, SSE real-time updates, pluggable notifications, and npm package distribution
**Researched:** 2026-02-13
**Overall confidence:** HIGH (based on Node.js official docs, npm issue trackers, Claude Code CLI docs, and verified community patterns)

---

## Critical Pitfalls

Mistakes that cause rewrites, data loss, or fundamental architecture failures.

### Pitfall 1: Using spawnSync for Long-Running Claude Commands

**What goes wrong:** The PRD shows `spawnSync('claude', ['-p', command], { timeout: 600000 })` for running GSD commands. `spawnSync` blocks the entire Node.js event loop for up to 10 minutes per command. While blocked, the Express web server cannot serve dashboard requests, SSE connections drop, health checks fail, and the notification system cannot process webhook responses. The tool appears frozen to the user.

**Why it happens:** `spawnSync` is simpler to reason about sequentially. Developers reach for it to avoid callback/promise complexity in the orchestrator loop. The PRD's example code uses it directly.

**Consequences:** Dashboard is completely unresponsive during command execution. SSE connections timeout and disconnect. Health check endpoint returns nothing (looks like the process crashed). If the user sends a question response via the web UI while a command is running, the response cannot be received. The entire value proposition of the web dashboard is negated.

**Prevention:** Use async `spawn()` wrapped in a Promise from day one. Structure the orchestrator as an async state machine using `async/await`. This is non-negotiable -- the embedded web server and SSE streaming require a live event loop.

```javascript
function runGsdCommand(command, projectDir) {
  return new Promise((resolve, reject) => {
    const child = spawn('claude', ['-p', command, '--output-format', 'json'], {
      cwd: projectDir,
      shell: true  // Required for Windows
    });
    let stdout = '', stderr = '';
    child.stdout.on('data', (chunk) => { stdout += chunk; });
    child.stderr.on('data', (chunk) => { stderr += chunk; });
    child.on('close', (code) => resolve({ stdout, stderr, exitCode: code }));
    child.on('error', reject);
    setTimeout(() => { child.kill('SIGTERM'); reject(new Error('Timeout')); }, 600000);
  });
}
```

**Detection:** If the dashboard freezes every time a phase runs, this is the cause. Test by hitting `/api/health` during a `claude -p` execution.

**Affects phase:** Phase 1 (Core Orchestrator) -- must be async from the start. Retrofitting sync-to-async later requires rewriting the entire orchestrator loop.

**Confidence:** HIGH -- based on Node.js official child_process documentation and standard async patterns.

---

### Pitfall 2: Fragile Output Parsing with String Matching on Claude CLI Output

**What goes wrong:** The PRD specifies parsing `claude -p` stdout for patterns like `"PROJECT INITIALIZED"`, `"PHASE X PLANNED"`, `"GAPS_FOUND"`. These strings are generated by GSD agent prompts, not by a formal API contract. Claude's output is non-deterministic -- the model may rephrase, wrap in markdown, add context, or change casing. A Claude Code CLI update could also change output formatting. Any of these breaks the parser silently, causing the orchestrator to misinterpret phase status.

**Why it happens:** When prototyping, regex/string matching on stdout is the fastest path. The developer sees consistent output in a few test runs and assumes stability. But LLM output has inherent variance even with the same prompt.

**Consequences:** Orchestrator misreads phase status. A successful phase gets marked as failed (retry storm). A failed phase gets marked as successful (corrupted project state, cascading failures in later phases). Verification status misread leads to shipping broken code. The tool becomes unreliable in a way that is hard to diagnose because failures are intermittent.

**Prevention:** Use `claude -p --output-format json` to get structured JSON output with a `result` field. Parse the JSON, not raw text. For status determination, have GSD commands write explicit status to a known file (e.g., `.planning/autopilot-state.json` with a `lastCommandStatus` field) rather than parsing stdout. Use `--json-schema` when available for guaranteed structured output. As a fallback parser, use multiple signal detection (check both stdout patterns AND file-system state like whether `VERIFICATION.md` exists and contains "passed").

**Detection:** Intermittent failures where the same phase sometimes succeeds and sometimes fails without code changes. Orchestrator logs showing "unknown status" or unexpected parsing results.

**Affects phase:** Phase 1 (Core Orchestrator) -- output parsing strategy must be decided before building the command execution layer.

**Confidence:** HIGH -- based on Claude Code CLI documentation confirming `--output-format json` availability and documented LLM output variance patterns.

---

### Pitfall 3: Zombie Child Processes and Orphaned Claude Sessions

**What goes wrong:** When the autopilot is interrupted (Ctrl+C, crash, power loss, terminal close), spawned `claude -p` processes continue running in the background. Each Claude session consumes API credits, holds file locks in the project directory, and may continue writing to `.planning/` files. On resume, the new autopilot instance conflicts with the orphaned process -- both try to write state files, both modify source code, causing corruption.

**Why it happens:** Node.js child processes are not automatically terminated when the parent exits. The default behavior on SIGINT is to exit the parent immediately. Without explicit cleanup, child processes become orphans that are re-parented to PID 1 (Unix) or persist as independent processes (Windows). Windows is especially problematic because `SIGTERM` is not a real signal -- `child.kill()` calls `TerminateProcess` which does not propagate to grandchild processes.

**Consequences:** Wasted API credits from orphaned Claude sessions. State file corruption from concurrent writes. Project files modified by ghost processes after the user thinks the tool has stopped. On resume, conflicting state causes the orchestrator to make wrong decisions.

**Prevention:**
1. Track all spawned child PIDs in an array.
2. Register cleanup handlers on `process.on('exit')`, `process.on('SIGINT')`, `process.on('SIGTERM')`, and `process.on('uncaughtException')`.
3. On Windows, use `spawn` with `{ shell: true }` and track the PID, then use `taskkill /PID <pid> /T /F` to kill the process tree.
4. Write the current child PID to `autopilot-state.json`. On startup, check if that PID is still running and kill it before proceeding.
5. Use `--max-turns` and `--max-budget-usd` flags on `claude -p` as safety limits to prevent runaway sessions.
6. Consider using `tree-kill` npm package for cross-platform process tree termination.

**Detection:** After a crash, check `ps aux | grep claude` (Unix) or `tasklist | findstr claude` (Windows). If Claude processes exist without a parent autopilot, cleanup is not working.

**Affects phase:** Phase 1 (Core Orchestrator) -- process lifecycle management must be designed into the spawn wrapper from the start.

**Confidence:** HIGH -- based on Node.js GitHub issues (#46569, #40189, #14445) documenting zombie process behavior, and Windows-specific process management documentation.

---

### Pitfall 4: State File Corruption from Non-Atomic Writes

**What goes wrong:** The orchestrator writes state to `autopilot-state.json` after every step. Using `fs.writeFileSync(path, JSON.stringify(state))` is not atomic -- if the process crashes mid-write (or the system loses power), the file contains a truncated JSON string. On resume, `JSON.parse()` throws, and the orchestrator cannot recover. The entire run's progress is lost.

**Why it happens:** `fs.writeFileSync` does NOT perform an atomic write. It writes directly to the file, and if interrupted, the file is partially written. This is documented in Node.js issue #1058. Most developers assume sync writes are safe because they block.

**Consequences:** Complete loss of run progress requiring restart from scratch. Corrupted JSON files that need manual repair. Silent data loss if the parse error is caught but the fallback is "start fresh."

**Prevention:** Use the write-then-rename pattern (atomic writes):
1. Write to a temporary file (`autopilot-state.json.tmp`)
2. Call `fs.fsyncSync(fd)` to flush to disk
3. Rename the temp file to the real file (`fs.renameSync` is atomic on most filesystems)

Or use the `write-file-atomic` npm package which implements this pattern. Additionally, keep the previous state file as a backup (`autopilot-state.json.bak`) so recovery can fall back to the last-known-good state.

**Detection:** After a forced kill during a write, check if `autopilot-state.json` contains valid JSON. If it is truncated or empty, atomic writes are not being used.

**Affects phase:** Phase 1 (Core Orchestrator) -- state persistence is foundational and hard to retrofit.

**Confidence:** HIGH -- based on Node.js GitHub issue #1058, npm `write-file-atomic` documentation, and filesystem atomicity guarantees.

---

### Pitfall 5: Cross-Platform Child Process Spawning Failures

**What goes wrong:** `spawn('claude', ['-p', command])` works on macOS/Linux where `claude` is a shell script in PATH. On Windows, the `claude` command is actually `claude.cmd` (a cmd.exe shim created by npm). Without `{ shell: true }`, `spawn` cannot find `.cmd` files on Windows. The tool works perfectly on the developer's Mac but fails immediately for Windows users with `ENOENT` errors.

**Why it happens:** On Unix, `spawn` uses `execvp` which searches PATH for any executable. On Windows, `spawn` without `shell: true` only finds `.exe` files. npm installs CLI tools as `.cmd` shims on Windows, which require `cmd.exe` to execute. This is one of the most common cross-platform Node.js mistakes.

**Consequences:** The tool is completely broken on Windows. Since `claude` is the core dependency, nothing works. Windows users (who may be a significant portion of the audience for a local dev tool) cannot use the product at all.

**Prevention:**
1. Always use `spawn(command, args, { shell: true })` for commands that may be `.cmd` shims.
2. Alternatively, use the `cross-spawn` npm package which handles this transparently.
3. Test on Windows in CI (GitHub Actions `windows-latest` runner).
4. For path construction, always use `path.join()` and `path.resolve()` -- never string concatenation with `/`.
5. Normalize all file paths read from state files using `path.normalize()`.

**Detection:** Any `ENOENT` error when spawning `claude` on Windows. Test spawning in a Windows environment early.

**Affects phase:** Phase 1 (Core Orchestrator) -- the spawn wrapper must handle this from the first implementation.

**Confidence:** HIGH -- based on Node.js official child_process documentation and the well-documented `cross-spawn` rationale.

---

## Moderate Pitfalls

Mistakes that cause significant bugs, poor user experience, or painful debugging sessions.

### Pitfall 6: Express Server Lifecycle Mismanagement

**What goes wrong:** The Express server starts at tool launch and should stop when the autopilot completes. Common failures: (a) port 3847 is already in use from a previous crashed run (EADDRINUSE), (b) server keeps running after the orchestrator finishes because event loop handles prevent exit, (c) `process.exit()` is called without closing the server first, dropping in-flight SSE connections and potentially corrupting any pending response.

**Why it happens:** Express servers hold the event loop open by default. Most developers either forget to close the server on completion (process hangs) or call `process.exit(0)` which skips cleanup. The EADDRINUSE case happens because a previous run crashed without releasing the port, and there is no stale-port detection.

**Prevention:**
1. On startup, attempt to bind the port. If EADDRINUSE, either auto-increment the port or detect/kill the stale process.
2. Implement a centralized shutdown manager that registers cleanup handlers for the server, SSE connections, and child processes.
3. Call `server.close()` before exiting, with a timeout fallback (e.g., force exit after 5 seconds if connections do not drain).
4. Write the active port to `autopilot-state.json` so the stale-port detector knows what to clean up.

**Detection:** Process hangs after "Build Complete" message. Port conflict errors on re-run. Dashboard continues serving after the CLI reports completion.

**Affects phase:** Phase 2 (Web Dashboard) -- server lifecycle should be designed alongside the initial Express setup.

---

### Pitfall 7: SSE Connection Drops Without Recovery

**What goes wrong:** The SSE connection between the React dashboard and Express server drops due to: network blips on localhost (rare but possible with VPNs/proxies), browser tab going to sleep, or the Express server restarting. The `EventSource` API auto-reconnects, but without message IDs and server-side replay, the client misses all events that occurred during the disconnection. The dashboard shows stale state until the user manually refreshes.

**Why it happens:** Basic SSE implementations just push events without tracking what each client has received. The `EventSource` reconnection mechanism sends a `Last-Event-ID` header, but if the server does not implement replay from that ID, the reconnection just resumes from the current moment, missing gap events.

**Prevention:**
1. Assign incrementing IDs to every SSE event using the `id:` field.
2. Keep a bounded event buffer (last 100-200 events) on the server.
3. On reconnection, check the `Last-Event-ID` header and replay missed events.
4. Send heartbeat comments (`: heartbeat\n\n`) every 15-30 seconds to detect dead connections.
5. On the React side, if reconnection detects a gap it cannot recover from, fall back to a full state fetch via `GET /api/status` and `GET /api/phases`.
6. Set `Cache-Control: no-cache` and `X-Accel-Buffering: no` headers to prevent proxy interference.

**Detection:** Open the dashboard, disconnect your network briefly, reconnect. If the dashboard does not show events that occurred during disconnection, replay is missing.

**Affects phase:** Phase 2 (Web Dashboard) -- SSE reliability should be built into the initial implementation, not bolted on later.

---

### Pitfall 8: npm Package Bloat from Bundled React Build

**What goes wrong:** The npm package includes the pre-built React SPA (HTML, JS, CSS, assets). Without careful configuration, the package also includes: source maps (large), development dependencies, Vite config/cache, test files, and the `node_modules` of the dashboard. Package size balloons from a few hundred KB to 10-50+ MB. This makes `npx gsd-autopilot` painfully slow on first run and wastes disk space.

**Why it happens:** npm's `files` field in `package.json` defaults to including everything not in `.gitignore`. Developers build the React app and forget that source maps, development artifacts, and intermediate build files get included. Vite's default build generates source maps.

**Prevention:**
1. Use the `files` field in `package.json` to explicitly whitelist only the production build output (e.g., `["bin", "lib", "dashboard/dist"]`).
2. Configure Vite to not emit source maps in production (`build.sourcemap: false`).
3. Add a `prepublishOnly` script that builds the dashboard and validates package size.
4. Use `npm pack --dry-run` during CI to verify package contents before publishing.
5. Set a `size-limit` budget (e.g., 2MB max) and fail CI if exceeded.
6. Consider lazy-loading the dashboard build or fetching it on first use instead of bundling.

**Detection:** Run `npm pack --dry-run` and check the listed files and total size. If it exceeds 5MB, investigate what is included.

**Affects phase:** Phase 4 (npm Package Distribution) -- but the dashboard build pipeline in Phase 2 must be configured with distribution in mind.

---

### Pitfall 9: Error Cascade from Failed Phase Execution

**What goes wrong:** Phase 3 fails (e.g., Claude generates code with a syntax error that breaks the verify step). The orchestrator retries, fails again, then moves to Phase 4. Phase 4 depends on Phase 3's output (imports, types, APIs). Phase 4 also fails. Each failure triggers notifications, creating a cascade of error messages. The user gets 6-8 error notifications in rapid succession and has no clear picture of what the root problem is.

**Why it happens:** The orchestrator treats each phase independently without checking preconditions. It does not verify that the project is in a valid state before starting the next phase. The retry-then-skip logic does not assess downstream impact.

**Prevention:**
1. Before each phase, run a lightweight precondition check (does the project build? do expected files from previous phases exist?).
2. When a phase fails after retry, STOP and notify the user with the root failure context, not just "Phase N failed."
3. Implement a "damage assessment" step that identifies which downstream phases are blocked by the failure.
4. Batch error notifications -- do not send one per failure. Send a single "Phase 3 failed, phases 4-7 are blocked" notification.
5. Use the `error.cause` chain (Node.js 16.9+) to preserve the original error context through the cascade.

**Detection:** If the user receives more than 2 error notifications in sequence, cascade protection is not working.

**Affects phase:** Phase 1 (Core Orchestrator) -- error handling strategy and phase dependency tracking must be designed upfront.

---

### Pitfall 10: Webhook Delivery Failures Silently Swallowed

**What goes wrong:** The Teams/Slack webhook URL returns a 429 (rate limited), 500 (server error), or the network times out. The notification adapter logs the error but the orchestrator continues, assuming the user was notified. The user never receives the question notification. The autopilot blocks waiting for a response that the user does not know about. The tool appears hung indefinitely.

**Why it happens:** Webhook delivery is treated as fire-and-forget. The notification adapter's `send()` returns `false` on failure, but the orchestrator does not check the return value or have a fallback strategy.

**Prevention:**
1. The notification manager must verify that at least one adapter successfully delivered the message.
2. Implement retry with exponential backoff (3 attempts, 1s/5s/15s delays) for webhook failures.
3. If all adapters fail, fall back to console output (always available).
4. For question-type notifications, set a "notification-sent" flag in state. If the response timeout expires without the flag being set, re-attempt notification via the fallback channel.
5. Rate limit outbound webhooks (max 1 per 5 seconds) to avoid triggering platform rate limits.

**Detection:** Simulate webhook failure (use an invalid URL). If the orchestrator blocks indefinitely without any user-visible indication, the fallback is missing.

**Affects phase:** Phase 3 (Notification System) -- retry and fallback logic must be part of the adapter interface contract.

---

### Pitfall 11: Windows Path Handling Throughout the Codebase

**What goes wrong:** The tool constructs file paths using string concatenation (`projectDir + '/planning/STATE.md'`), hardcodes forward slashes in glob patterns, or uses Unix-specific path separators. On Windows, paths use backslashes. `path.join()` returns different separators per platform. Glob patterns may not work. File reads fail with `ENOENT` on paths that look correct in logs but have mixed separators.

**Why it happens:** Development happens on macOS. Paths work with forward slashes on macOS/Linux. Windows tests are deferred or skipped. The issue surfaces only when real Windows users try the tool.

**Prevention:**
1. Use `path.join()` and `path.resolve()` for ALL path construction. Never concatenate strings with `/`.
2. Use `path.normalize()` when reading paths from configuration files or state files.
3. When comparing paths, normalize both sides first.
4. For glob patterns, use libraries like `glob` or `fast-glob` that handle Windows paths internally.
5. Add Windows to CI matrix (GitHub Actions `windows-latest`).
6. Store paths in state files using forward slashes (POSIX-style) and convert on read using `path.resolve()`.

**Detection:** Any `ENOENT` error on Windows where the file clearly exists. Path strings in logs containing mixed `/` and `\` separators.

**Affects phase:** All phases -- this must be a coding standard from Phase 1 onward. Add a linting rule or code review checklist item.

---

## Minor Pitfalls

Issues that cause friction, confusion, or minor bugs.

### Pitfall 12: Log Files Growing Unbounded

**What goes wrong:** The orchestrator logs all `claude -p` output to `.planning/autopilot-log/phase-N-step.log`. A single Claude session can produce 10-100KB of output. A full project build with 8 phases, 3+ steps each, retries, and verbose output can generate 5-50MB of logs. Over multiple runs (especially during development/testing), log files accumulate without limit, consuming disk space and making the `/api/log` endpoint slow.

**Prevention:**
1. Implement log rotation: keep the current log and at most 2-3 previous runs.
2. Cap individual log files at 1MB by truncating older content.
3. For the `/api/log` endpoint, use streaming with pagination rather than loading the entire log into memory.
4. Add a `--clean` flag that removes previous run logs before starting.

**Affects phase:** Phase 1 (Core Orchestrator) -- log management should be designed with the initial logging implementation.

---

### Pitfall 13: SSE Connection Limit with HTTP/1.1

**What goes wrong:** A user opens the dashboard in multiple browser tabs. Each tab opens an SSE connection to `/api/log/stream`. Browsers limit SSE connections to 6 per domain under HTTP/1.1. After 6 tabs, new connections are queued and the dashboard appears unresponsive.

**Prevention:**
1. Use `SharedWorker` or `BroadcastChannel` in the React app to share a single SSE connection across tabs.
2. Alternatively, serve the Express app over HTTP/2 (which allows ~100 concurrent streams).
3. Display a warning if a second tab is detected using the `BroadcastChannel` API.
4. Pragmatically, this is a localhost tool -- document that only one dashboard tab is needed.

**Affects phase:** Phase 2 (Web Dashboard) -- minor but worth noting in documentation.

---

### Pitfall 14: node-notifier Platform Quirks

**What goes wrong:** `node-notifier` has platform-specific limitations that cause confusing behavior: on Windows, notifications require a valid `appID` matching the installed application (Fall Creators Update+). On macOS, Notification Center requires 10.8+. On Linux, `notify-send` must be installed. In tmux sessions, `node-notifier` can hang the process. Notification images must be absolute-path PNGs under 200KB on Windows.

**Prevention:**
1. Make the `system` notification channel explicitly opt-in, not default.
2. Default to `console` which has zero platform dependencies.
3. On init, test that the notification subsystem works by sending a silent test notification and checking for errors.
4. Document platform requirements clearly in the README.
5. Detect tmux sessions (`process.env.TMUX`) and warn or skip system notifications.

**Affects phase:** Phase 3 (Notification System) -- adapter initialization should validate platform capabilities.

---

### Pitfall 15: Claude Code CLI Update Breaking Automation

**What goes wrong:** The user runs `claude update` (or it auto-updates). A new Claude Code version changes: the `--output-format json` schema (field names, nesting), exit codes for different failure modes, error message formats, or the behavior of `--continue`/`--resume` flags. The autopilot breaks until updated to match.

**Prevention:**
1. On startup, check `claude --version` and validate it against a known-compatible range.
2. Pin to specific Claude Code version ranges in documentation.
3. Write defensive JSON parsing that handles missing/extra fields gracefully.
4. Use the `session_id` from JSON output for `--resume` rather than relying on `--continue` behavior.
5. Wrap all Claude Code interactions in a thin adapter layer that can be updated in one place when the CLI changes.
6. Monitor the Claude Code changelog/GitHub releases for breaking changes.

**Affects phase:** Phase 1 (Core Orchestrator) -- the Claude Code adapter should be a distinct module with version checking.

---

### Pitfall 16: Discuss-Phase Question Overload

**What goes wrong:** The discuss-phase handler generates too many questions. If a phase has 8 gray areas and each becomes a notification, the user gets overwhelmed. They either ignore notifications (autopilot blocks forever) or rush through answers (poor decisions that affect the entire build). The "async human-in-the-loop" value proposition becomes a burden.

**Prevention:**
1. Batch questions (the PRD mentions 2-3 at a time -- enforce this as a hard limit).
2. Provide sensible defaults for each question so the user can "accept all defaults" with one click.
3. Set a response timeout (e.g., 30 minutes) after which the orchestrator uses Claude's recommended defaults and continues, notifying the user what was auto-decided.
4. Track response times across questions. If the user consistently responds in < 5 seconds, they are rubber-stamping -- suggest `--skip-discuss` for future runs.
5. Prioritize questions by impact: only ask about decisions that would significantly change the implementation.

**Affects phase:** Phase 1 (Core Orchestrator) and Phase 3 (Notification System) -- question batching and timeout logic should be specified in the orchestrator design.

---

### Pitfall 17: Bin Script Line Endings Break Linux/macOS After Windows Development

**What goes wrong:** A developer on Windows edits the bin entry script (e.g., `bin/gsd-autopilot.js`). Their editor saves with CRLF line endings. The shebang line `#!/usr/bin/env node\r` causes Linux/macOS to look for an interpreter called `node\r` (with carriage return), producing a cryptic "No such file or directory" error when running `npx gsd-autopilot`.

**Prevention:**
1. Add a `.gitattributes` file forcing bin scripts to LF: `bin/* eol=lf`.
2. Configure `.editorconfig` with `end_of_line = lf` for JavaScript files.
3. Add a CI check that validates bin scripts have Unix line endings.
4. Keep the bin entry script minimal (just the shebang and a `require()` call) so there is less to go wrong.

**Affects phase:** Phase 4 (npm Package Distribution) -- must be configured before first publish.

---

## Phase-Specific Warnings

| Phase Topic | Likely Pitfall | Mitigation |
|---|---|---|
| Phase 1: Core Orchestrator | spawnSync blocks event loop (Pitfall 1) | Use async spawn from day one, never spawnSync |
| Phase 1: Core Orchestrator | Fragile output parsing (Pitfall 2) | Use `--output-format json`, write status to files |
| Phase 1: Core Orchestrator | Zombie processes on crash (Pitfall 3) | Process tree cleanup on all exit signals, PID tracking |
| Phase 1: Core Orchestrator | State file corruption (Pitfall 4) | Atomic writes via write-then-rename pattern |
| Phase 1: Core Orchestrator | Windows spawn failures (Pitfall 5) | `shell: true` or `cross-spawn`, CI on Windows |
| Phase 1: Core Orchestrator | Error cascade (Pitfall 9) | Precondition checks, batch error notifications, stop on failure |
| Phase 2: Web Dashboard | Server lifecycle (Pitfall 6) | Centralized shutdown manager, port conflict detection |
| Phase 2: Web Dashboard | SSE gaps (Pitfall 7) | Event IDs, replay buffer, heartbeats |
| Phase 2: Web Dashboard | SSE connection limits (Pitfall 13) | SharedWorker or document the single-tab expectation |
| Phase 3: Notification System | Webhook failures silenced (Pitfall 10) | Retry with backoff, mandatory console fallback |
| Phase 3: Notification System | node-notifier quirks (Pitfall 14) | Console default, platform detection, tmux guard |
| Phase 3: Notification System | Question overload (Pitfall 16) | Batch limits, defaults, response timeouts |
| Phase 4: npm Distribution | Package bloat (Pitfall 8) | Explicit `files` whitelist, size-limit CI check |
| Phase 4: npm Distribution | Line ending breakage (Pitfall 17) | `.gitattributes` with `eol=lf` for bin scripts |
| All Phases | Windows path handling (Pitfall 11) | `path.join()` everywhere, Windows CI, normalize on read |
| All Phases | Log file growth (Pitfall 12) | Rotation, per-file cap, paginated API |
| All Phases | Claude CLI update breakage (Pitfall 15) | Version check on startup, adapter abstraction layer |

## Meta-Pitfall: Testing Only on macOS

The single most likely meta-failure is developing and testing exclusively on macOS (or exclusively on one OS). Pitfalls 5, 11, 14, and 17 are all Windows-specific failures that will only surface when real Windows users try the tool. Since this is a local dev tool distributed via npm, Windows users are a significant audience.

**Prevention:** Add `windows-latest` and `ubuntu-latest` to the CI matrix from Phase 1. Run the core orchestrator tests (spawn, state persistence, path handling) on all three platforms before any release.

## Sources

- [Node.js child_process documentation (v25.6.1)](https://nodejs.org/api/child_process.html) -- spawn vs spawnSync, shell option, timeout behavior, Windows .cmd limitation
- [Node.js zombie process issues (#46569, #40189, #14445)](https://github.com/nodejs/node/issues/46569) -- zombie processes from worker threads and unref'd child processes
- [Node.js fs.writeFile corruption (#1058)](https://github.com/nodejs/node/issues/1058) -- partial write corruption documentation
- [write-file-atomic npm package](https://www.npmjs.com/package/write-file-atomic) -- atomic file write implementation
- [Claude Code CLI reference](https://code.claude.com/docs/en/cli-reference) -- all flags including `--output-format`, `--max-turns`, `--max-budget-usd`
- [Claude Code headless mode documentation](https://code.claude.com/docs/en/headless) -- JSON output format, streaming, session management
- [Claude Code CLI bug #19498](https://github.com/anthropics/claude-code/issues/19498) -- "No messages returned" crash in print mode
- [Express.js graceful shutdown guide](https://expressjs.com/en/advanced/healthcheck-graceful-shutdown.html) -- health checks and shutdown patterns
- [MDN Server-Sent Events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events) -- SSE reconnection, Last-Event-ID, connection limits
- [cross-spawn npm package](https://www.npmjs.com/package/cross-spawn) -- cross-platform spawn wrapper rationale
- [npm/cli issue #502](https://github.com/npm/cli/issues/502) -- npx path spaces on Windows
- [node-notifier GitHub](https://github.com/mikaelbr/node-notifier) -- platform-specific notification requirements and limitations
- [Writing cross-platform Node.js (shapeshed.com)](https://shapeshed.com/writing-cross-platform-node/) -- path handling, line endings, shell differences
